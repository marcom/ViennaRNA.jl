module LibRNA

using ViennaRNA_jll
export ViennaRNA_jll

using CEnum

# this file was autogenerated by gen/generator.jl

# package versions used to generate this file
const VERSION_GEN_Clang = v"0.17.6"
const VERSION_GEN_ViennaRNA_jll = v"2.6.1+0"


"""
    vrna_md_s

 @brief The data structure that contains the complete model details used throughout the calculations

 For convenience reasons, we provide the type name #vrna_md_t to address this data structure
 without the use of the struct keyword

 @see  vrna_md_set_default(), set_model_details(), vrna_md_update(), #vrna_md_t
"""
struct vrna_md_s
    temperature::Cdouble
    betaScale::Cdouble
    pf_smooth::Cint
    dangles::Cint
    special_hp::Cint
    noLP::Cint
    noGU::Cint
    noGUclosure::Cint
    logML::Cint
    circ::Cint
    gquad::Cint
    uniq_ML::Cint
    energy_set::Cint
    backtrack::Cint
    backtrack_type::Cchar
    compute_bpp::Cint
    nonstandards::NTuple{64, Cchar}
    max_bp_span::Cint
    min_loop_size::Cint
    window_size::Cint
    oldAliEn::Cint
    ribo::Cint
    cv_fact::Cdouble
    nc_fact::Cdouble
    sfact::Cdouble
    rtype::NTuple{8, Cint}
    alias::NTuple{21, Cshort}
    pair::NTuple{21, NTuple{21, Cint}}
    pair_dist::NTuple{7, NTuple{7, Cfloat}}
    salt::Cdouble
    saltMLLower::Cint
    saltMLUpper::Cint
    saltDPXInit::Cint
    saltDPXInitFact::Cfloat
    helical_rise::Cfloat
    backbone_length::Cfloat
end

"""
@brief Typename for the model details data structure #vrna_md_s 
"""
const vrna_md_t = vrna_md_s

"""
    vrna_basepair_s

 @brief  Base pair data structure used in subopt.c
"""
struct vrna_basepair_s
    i::Cint
    j::Cint
end

"""
@brief Typename for the base pair repesenting data structure #vrna_basepair_s 
"""
const vrna_basepair_t = vrna_basepair_s

"""
    vrna_elem_prob_s

 @brief  Data structure representing a single entry of an element probability list
         (e.g. list of pair probabilities)

 @see vrna_plist(), vrna_plist_from_probs(), vrna_db_from_plist(),

 #VRNA_PLIST_TYPE_BASEPAIR, #VRNA_PLIST_TYPE_GQUAD, #VRNA_PLIST_TYPE_H_MOTIF, #VRNA_PLIST_TYPE_I_MOTIF,
 #VRNA_PLIST_TYPE_UD_MOTIF, #VRNA_PLIST_TYPE_STACK
"""
struct vrna_elem_prob_s
    i::Cint
    j::Cint
    p::Cfloat
    type::Cint
end

"""
@brief Typename for the base pair list repesenting data structure #vrna_elem_prob_s 
"""
const vrna_plist_t = vrna_elem_prob_s

"""
    vrna_bp_stack_s

 @brief  Base pair stack element
"""
struct vrna_bp_stack_s
    i::Cuint
    j::Cuint
end

"""
@brief Typename for the base pair stack repesenting data structure #vrna_bp_stack_s 
"""
const vrna_bp_stack_t = vrna_bp_stack_s

"""
    vrna_cpair_s

 @brief this datastructure is used as input parameter in functions of PS_dot.c
"""
struct vrna_cpair_s
    i::Cint
    j::Cint
    mfe::Cint
    p::Cfloat
    hue::Cfloat
    sat::Cfloat
    type::Cint
end

"""
@brief Typename for data structure #vrna_cpair_s 
"""
const vrna_cpair_t = vrna_cpair_s

"""
    vrna_sect_s

 @brief  Stack of partial structures for backtracking
"""
struct vrna_sect_s
    i::Cint
    j::Cint
    ml::Cint
end

"""
@brief Typename for stack of partial structures #vrna_sect_s 
"""
const vrna_sect_t = vrna_sect_s

struct vrna_color_s
    hue::Cfloat
    sat::Cfloat
    bri::Cfloat
end

const vrna_color_t = vrna_color_s

struct vrna_data_linear_s
    position::Cuint
    value::Cfloat
    color::vrna_color_t
end

const vrna_data_lin_t = vrna_data_linear_s

const FLT_OR_DBL = Cdouble

"""
 @brief Old typename of #vrna_basepair_s
 @deprecated Use #vrna_basepair_t instead!
"""
const PAIR = vrna_basepair_s

"""
 @brief Old typename of #vrna_elem_prob_s
 @deprecated Use #vrna_ep_t or #vrna_elem_prob_s instead!
"""
const plist = vrna_elem_prob_s

"""
 @brief Old typename of #vrna_cpair_s
 @deprecated Use #vrna_cpair_t instead!
"""
const cpair = vrna_cpair_s

"""
 @brief Old typename of #vrna_sect_s
 @deprecated Use #vrna_sect_t instead!
"""
const sect = vrna_sect_s

"""
 @brief Old typename of #vrna_bp_stack_s
 @deprecated Use #vrna_bp_stack_t instead!
"""
const bondT = vrna_bp_stack_s

"""
    vrna_md_set_default(md)

@brief Apply default model details to a provided #vrna_md_t data structure

 Use this function to initialize a #vrna_md_t data structure with
 its default values

 @param md A pointer to the data structure that is about to be initialized
### Prototype
```c
void vrna_md_set_default(vrna_md_t *md);
```
"""
function vrna_md_set_default(md)
    ccall((:vrna_md_set_default, libRNA), Cvoid, (Ptr{vrna_md_t},), md)
end

"""
    vrna_md_update(md)

 @brief Update the model details data structure

 This function should be called after changing the vrna_md_t.energy_set attribute
 since it re-initializes base pairing related arrays within the #vrna_md_t data
 structure. In particular, #vrna_md_t.pair, #vrna_md_t.alias, and #vrna_md_t.rtype
 are set to the values that correspond to the specified #vrna_md_t.energy_set
 option

 @see  #vrna_md_t, #vrna_md_t.energy_set, #vrna_md_t.pair, #vrna_md_t.rtype,
       #vrna_md_t.alias, vrna_md_set_default()
### Prototype
```c
void vrna_md_update(vrna_md_t *md);
```
"""
function vrna_md_update(md)
    ccall((:vrna_md_update, libRNA), Cvoid, (Ptr{vrna_md_t},), md)
end

"""
    vrna_md_copy(md_to, md_from)

 @brief Copy/Clone a #vrna_md_t model

 Use this function to clone a given model either inplace (target container @p md_to
 given) or create a copy by cloning the source model and returning it (@p md_to == NULL).

 @param md_to    The model to be overwritten (if non-NULL and @p md_to != @p md_from)
 @param md_from  The model to copy (if non-NULL)
 @return         A pointer to the copy model (or NULL if @p md_from == NULL)
### Prototype
```c
vrna_md_t * vrna_md_copy(vrna_md_t *md_to, const vrna_md_t *md_from);
```
"""
function vrna_md_copy(md_to, md_from)
    ccall((:vrna_md_copy, libRNA), Ptr{vrna_md_t}, (Ptr{vrna_md_t}, Ptr{vrna_md_t}), md_to, md_from)
end

"""
    vrna_md_option_string(md)

 @brief  Get a corresponding commandline parameter string of the options in a #vrna_md_t

 @note This function is not threadsafe!
### Prototype
```c
char * vrna_md_option_string(vrna_md_t *md);
```
"""
function vrna_md_option_string(md)
    ccall((:vrna_md_option_string, libRNA), Ptr{Cchar}, (Ptr{vrna_md_t},), md)
end

"""
    vrna_md_set_nonstandards(md, ns_bases)


### Prototype
```c
void vrna_md_set_nonstandards(vrna_md_t *md, const char *ns_bases);
```
"""
function vrna_md_set_nonstandards(md, ns_bases)
    ccall((:vrna_md_set_nonstandards, libRNA), Cvoid, (Ptr{vrna_md_t}, Ptr{Cchar}), md, ns_bases)
end

"""
    vrna_md_defaults_reset(md_p)

 @brief  Reset the global default model details to a specific set of parameters, or their initial values

 This function resets the global default model details to their initial values,
 i.e. as specified by the ViennaRNA Package release, upon passing NULL as argument.
 Alternatively it resets them according to a set of provided parameters.

 @note The global default parameters affect all function calls of RNAlib where
       model details are not explicitly provided. Hence, any change of them
       is not considered threadsafe

 @warning  This function first resets the global default settings to factory
           defaults, and only then applies user provided settings (if any).
           User settings that do not meet specifications are skipped.

 @see  vrna_md_set_default(), #vrna_md_t

 @param md_p A set of model details to use as global default (if NULL is passed, factory defaults are restored)
### Prototype
```c
void vrna_md_defaults_reset(vrna_md_t *md_p);
```
"""
function vrna_md_defaults_reset(md_p)
    ccall((:vrna_md_defaults_reset, libRNA), Cvoid, (Ptr{vrna_md_t},), md_p)
end

"""
    vrna_md_defaults_temperature(T)

 @brief  Set default temperature for energy evaluation of loops

 @see vrna_md_defaults_reset(), vrna_md_set_default(), #vrna_md_t, #VRNA_MODEL_DEFAULT_TEMPERATURE

 @param T  Temperature in centigrade
### Prototype
```c
void vrna_md_defaults_temperature(double T);
```
"""
function vrna_md_defaults_temperature(T)
    ccall((:vrna_md_defaults_temperature, libRNA), Cvoid, (Cdouble,), T)
end

"""
    vrna_md_defaults_temperature_get()

 @brief  Get default temperature for energy evaluation of loops

 @see vrna_md_defaults_temperature(), vrna_md_defaults_reset(), vrna_md_set_default(), #vrna_md_t, #VRNA_MODEL_DEFAULT_TEMPERATURE

 @return  The global default settings for temperature in centigrade
### Prototype
```c
double vrna_md_defaults_temperature_get(void);
```
"""
function vrna_md_defaults_temperature_get()
    ccall((:vrna_md_defaults_temperature_get, libRNA), Cdouble, ())
end

"""
    vrna_md_defaults_betaScale(b)

 @brief  Set default scaling factor of thermodynamic temperature in Boltzmann factors

 Bolzmann factors are then computed as @f\$ exp(-E / (b \\cdot kT))@f\$.

 @see vrna_md_defaults_reset(), vrna_md_set_default(), #vrna_md_t, #VRNA_MODEL_DEFAULT_BETA_SCALE

 @param b  The scaling factor, default is 1.0
### Prototype
```c
void vrna_md_defaults_betaScale(double b);
```
"""
function vrna_md_defaults_betaScale(b)
    ccall((:vrna_md_defaults_betaScale, libRNA), Cvoid, (Cdouble,), b)
end

"""
    vrna_md_defaults_betaScale_get()

 @brief  Get default scaling factor of thermodynamic temperature in Boltzmann factors

 @see vrna_md_defaults_betaScale(), vrna_md_defaults_reset(), vrna_md_set_default(), #vrna_md_t, #VRNA_MODEL_DEFAULT_BETA_SCALE

 @return  The global default thermodynamic temperature scaling factor
### Prototype
```c
double vrna_md_defaults_betaScale_get(void);
```
"""
function vrna_md_defaults_betaScale_get()
    ccall((:vrna_md_defaults_betaScale_get, libRNA), Cdouble, ())
end

"""
    vrna_md_defaults_pf_smooth(s)


### Prototype
```c
void vrna_md_defaults_pf_smooth(int s);
```
"""
function vrna_md_defaults_pf_smooth(s)
    ccall((:vrna_md_defaults_pf_smooth, libRNA), Cvoid, (Cint,), s)
end

"""
    vrna_md_defaults_pf_smooth_get()


### Prototype
```c
int vrna_md_defaults_pf_smooth_get(void);
```
"""
function vrna_md_defaults_pf_smooth_get()
    ccall((:vrna_md_defaults_pf_smooth_get, libRNA), Cint, ())
end

"""
    vrna_md_defaults_dangles(d)

 @brief  Set default dangle model for structure prediction

 @see vrna_md_defaults_reset(), vrna_md_set_default(), #vrna_md_t, #VRNA_MODEL_DEFAULT_DANGLES

 @param d  The dangle model
### Prototype
```c
void vrna_md_defaults_dangles(int d);
```
"""
function vrna_md_defaults_dangles(d)
    ccall((:vrna_md_defaults_dangles, libRNA), Cvoid, (Cint,), d)
end

"""
    vrna_md_defaults_dangles_get()

 @brief  Get default dangle model for structure prediction

 @see vrna_md_defaults_dangles(), vrna_md_defaults_reset(), vrna_md_set_default(), #vrna_md_t, #VRNA_MODEL_DEFAULT_DANGLES

 @return The global default settings for the dangle model
### Prototype
```c
int vrna_md_defaults_dangles_get(void);
```
"""
function vrna_md_defaults_dangles_get()
    ccall((:vrna_md_defaults_dangles_get, libRNA), Cint, ())
end

"""
    vrna_md_defaults_special_hp(flag)

 @brief  Set default behavior for lookup of tabulated free energies for special hairpin loops, such as Tri-, Tetra-, or Hexa-loops.

 @see vrna_md_defaults_reset(), vrna_md_set_default(), #vrna_md_t, #VRNA_MODEL_DEFAULT_SPECIAL_HP

 @param  flag  On/Off switch (0 = OFF, else = ON)
### Prototype
```c
void vrna_md_defaults_special_hp(int flag);
```
"""
function vrna_md_defaults_special_hp(flag)
    ccall((:vrna_md_defaults_special_hp, libRNA), Cvoid, (Cint,), flag)
end

"""
    vrna_md_defaults_special_hp_get()

 @brief  Get default behavior for lookup of tabulated free energies for special hairpin loops, such as Tri-, Tetra-, or Hexa-loops.

 @see vrna_md_defaults_special_hp(), vrna_md_defaults_reset(), vrna_md_set_default(), #vrna_md_t, #VRNA_MODEL_DEFAULT_SPECIAL_HP

 @return  The global default settings for the treatment of special hairpin loops
### Prototype
```c
int vrna_md_defaults_special_hp_get(void);
```
"""
function vrna_md_defaults_special_hp_get()
    ccall((:vrna_md_defaults_special_hp_get, libRNA), Cint, ())
end

"""
    vrna_md_defaults_noLP(flag)

 @brief  Set default behavior for prediction of canonical secondary structures

 @see vrna_md_defaults_reset(), vrna_md_set_default(), #vrna_md_t, #VRNA_MODEL_DEFAULT_NO_LP

 @param  flag  On/Off switch (0 = OFF, else = ON)
### Prototype
```c
void vrna_md_defaults_noLP(int flag);
```
"""
function vrna_md_defaults_noLP(flag)
    ccall((:vrna_md_defaults_noLP, libRNA), Cvoid, (Cint,), flag)
end

"""
    vrna_md_defaults_noLP_get()

 @brief  Get default behavior for prediction of canonical secondary structures

 @see vrna_md_defaults_noLP(), vrna_md_defaults_reset(), vrna_md_set_default(), #vrna_md_t, #VRNA_MODEL_DEFAULT_NO_LP

 @return  The global default settings for predicting canonical secondary structures
### Prototype
```c
int vrna_md_defaults_noLP_get(void);
```
"""
function vrna_md_defaults_noLP_get()
    ccall((:vrna_md_defaults_noLP_get, libRNA), Cint, ())
end

"""
    vrna_md_defaults_noGU(flag)

 @brief  Set default behavior for treatment of G-U wobble pairs

 @see vrna_md_defaults_reset(), vrna_md_set_default(), #vrna_md_t, #VRNA_MODEL_DEFAULT_NO_GU

 @param  flag  On/Off switch (0 = OFF, else = ON)
### Prototype
```c
void vrna_md_defaults_noGU(int flag);
```
"""
function vrna_md_defaults_noGU(flag)
    ccall((:vrna_md_defaults_noGU, libRNA), Cvoid, (Cint,), flag)
end

"""
    vrna_md_defaults_noGU_get()

 @brief  Get default behavior for treatment of G-U wobble pairs

 @see vrna_md_defaults_noGU(), vrna_md_defaults_reset(), vrna_md_set_default(), #vrna_md_t, #VRNA_MODEL_DEFAULT_NO_GU

 @return The global default settings for treatment of G-U wobble pairs
### Prototype
```c
int vrna_md_defaults_noGU_get(void);
```
"""
function vrna_md_defaults_noGU_get()
    ccall((:vrna_md_defaults_noGU_get, libRNA), Cint, ())
end

"""
    vrna_md_defaults_noGUclosure(flag)

 @brief  Set default behavior for G-U pairs as closing pair for loops

 @see vrna_md_defaults_reset(), vrna_md_set_default(), #vrna_md_t, #VRNA_MODEL_DEFAULT_NO_GU_CLOSURE

 @param  flag  On/Off switch (0 = OFF, else = ON)
### Prototype
```c
void vrna_md_defaults_noGUclosure(int flag);
```
"""
function vrna_md_defaults_noGUclosure(flag)
    ccall((:vrna_md_defaults_noGUclosure, libRNA), Cvoid, (Cint,), flag)
end

"""
    vrna_md_defaults_noGUclosure_get()

 @brief  Get default behavior for G-U pairs as closing pair for loops

 @see vrna_md_defaults_noGUclosure(), vrna_md_defaults_reset(), vrna_md_set_default(), #vrna_md_t, #VRNA_MODEL_DEFAULT_NO_GU_CLOSURE

 @return The global default settings for treatment of G-U pairs closing a loop
### Prototype
```c
int vrna_md_defaults_noGUclosure_get(void);
```
"""
function vrna_md_defaults_noGUclosure_get()
    ccall((:vrna_md_defaults_noGUclosure_get, libRNA), Cint, ())
end

"""
    vrna_md_defaults_logML(flag)

 @brief  Set default behavior recomputing free energies of multi-branch loops using a logarithmic model

 @see vrna_md_defaults_reset(), vrna_md_set_default(), #vrna_md_t, #VRNA_MODEL_DEFAULT_LOG_ML

 @param  flag  On/Off switch (0 = OFF, else = ON)
### Prototype
```c
void vrna_md_defaults_logML(int flag);
```
"""
function vrna_md_defaults_logML(flag)
    ccall((:vrna_md_defaults_logML, libRNA), Cvoid, (Cint,), flag)
end

"""
    vrna_md_defaults_logML_get()

 @brief  Get default behavior recomputing free energies of multi-branch loops using a logarithmic model

 @see vrna_md_defaults_logML(), vrna_md_defaults_reset(), vrna_md_set_default(), #vrna_md_t, #VRNA_MODEL_DEFAULT_LOG_ML

 @return The global default settings for logarithmic model in multi-branch loop free energy evaluation
### Prototype
```c
int vrna_md_defaults_logML_get(void);
```
"""
function vrna_md_defaults_logML_get()
    ccall((:vrna_md_defaults_logML_get, libRNA), Cint, ())
end

"""
    vrna_md_defaults_circ(flag)

 @brief  Set default behavior whether input sequences are circularized

 @see vrna_md_defaults_reset(), vrna_md_set_default(), #vrna_md_t, #VRNA_MODEL_DEFAULT_CIRC

 @param  flag  On/Off switch (0 = OFF, else = ON)
### Prototype
```c
void vrna_md_defaults_circ(int flag);
```
"""
function vrna_md_defaults_circ(flag)
    ccall((:vrna_md_defaults_circ, libRNA), Cvoid, (Cint,), flag)
end

"""
    vrna_md_defaults_circ_get()

 @brief  Get default behavior whether input sequences are circularized

 @see vrna_md_defaults_circ(), vrna_md_defaults_reset(), vrna_md_set_default(), #vrna_md_t, #VRNA_MODEL_DEFAULT_CIRC

 @return The global default settings for treating input sequences as circular
### Prototype
```c
int vrna_md_defaults_circ_get(void);
```
"""
function vrna_md_defaults_circ_get()
    ccall((:vrna_md_defaults_circ_get, libRNA), Cint, ())
end

"""
    vrna_md_defaults_gquad(flag)

 @brief  Set default behavior for treatment of G-Quadruplexes

 @see vrna_md_defaults_reset(), vrna_md_set_default(), #vrna_md_t, #VRNA_MODEL_DEFAULT_GQUAD

 @param  flag  On/Off switch (0 = OFF, else = ON)
### Prototype
```c
void vrna_md_defaults_gquad(int flag);
```
"""
function vrna_md_defaults_gquad(flag)
    ccall((:vrna_md_defaults_gquad, libRNA), Cvoid, (Cint,), flag)
end

"""
    vrna_md_defaults_gquad_get()

 @brief  Get default behavior for treatment of G-Quadruplexes

 @see vrna_md_defaults_gquad(), vrna_md_defaults_reset(), vrna_md_set_default(), #vrna_md_t, #VRNA_MODEL_DEFAULT_GQUAD

 @return The global default settings for treatment of G-Quadruplexes
### Prototype
```c
int vrna_md_defaults_gquad_get(void);
```
"""
function vrna_md_defaults_gquad_get()
    ccall((:vrna_md_defaults_gquad_get, libRNA), Cint, ())
end

"""
    vrna_md_defaults_uniq_ML(flag)

 @brief  Set default behavior for creating additional matrix for unique multi-branch loop prediction

 @note   Activating this option usually results in higher memory consumption!

 @see vrna_md_defaults_reset(), vrna_md_set_default(), #vrna_md_t, #VRNA_MODEL_DEFAULT_UNIQ_ML

 @param  flag  On/Off switch (0 = OFF, else = ON)
### Prototype
```c
void vrna_md_defaults_uniq_ML(int flag);
```
"""
function vrna_md_defaults_uniq_ML(flag)
    ccall((:vrna_md_defaults_uniq_ML, libRNA), Cvoid, (Cint,), flag)
end

"""
    vrna_md_defaults_uniq_ML_get()

 @brief  Get default behavior for creating additional matrix for unique multi-branch loop prediction

 @see vrna_md_defaults_uniq_ML(), vrna_md_defaults_reset(), vrna_md_set_default(), #vrna_md_t, #VRNA_MODEL_DEFAULT_UNIQ_ML

 @return The global default settings for creating additional matrices for unique multi-branch loop prediction
### Prototype
```c
int vrna_md_defaults_uniq_ML_get(void);
```
"""
function vrna_md_defaults_uniq_ML_get()
    ccall((:vrna_md_defaults_uniq_ML_get, libRNA), Cint, ())
end

"""
    vrna_md_defaults_energy_set(e)

 @brief  Set default energy set

 @see vrna_md_defaults_reset(), vrna_md_set_default(), #vrna_md_t, #VRNA_MODEL_DEFAULT_ENERGY_SET

 @param  e   Energy set (0, 1, 2, 3)
### Prototype
```c
void vrna_md_defaults_energy_set(int e);
```
"""
function vrna_md_defaults_energy_set(e)
    ccall((:vrna_md_defaults_energy_set, libRNA), Cvoid, (Cint,), e)
end

"""
    vrna_md_defaults_energy_set_get()

 @brief  Get default energy set

 @see vrna_md_defaults_energy_set(), vrna_md_defaults_reset(), vrna_md_set_default(), #vrna_md_t, #VRNA_MODEL_DEFAULT_ENERGY_SET

 @return The global default settings for the energy set
### Prototype
```c
int vrna_md_defaults_energy_set_get(void);
```
"""
function vrna_md_defaults_energy_set_get()
    ccall((:vrna_md_defaults_energy_set_get, libRNA), Cint, ())
end

"""
    vrna_md_defaults_backtrack(flag)

 @brief  Set default behavior for whether to backtrack secondary structures

 @see vrna_md_defaults_reset(), vrna_md_set_default(), #vrna_md_t, #VRNA_MODEL_DEFAULT_BACKTRACK

 @param  flag  On/Off switch (0 = OFF, else = ON)
### Prototype
```c
void vrna_md_defaults_backtrack(int flag);
```
"""
function vrna_md_defaults_backtrack(flag)
    ccall((:vrna_md_defaults_backtrack, libRNA), Cvoid, (Cint,), flag)
end

"""
    vrna_md_defaults_backtrack_get()

 @brief  Get default behavior for whether to backtrack secondary structures

 @see vrna_md_defaults_backtrack(), vrna_md_defaults_reset(), vrna_md_set_default(), #vrna_md_t, #VRNA_MODEL_DEFAULT_BACKTRACK

 @return The global default settings for backtracking structures
### Prototype
```c
int vrna_md_defaults_backtrack_get(void);
```
"""
function vrna_md_defaults_backtrack_get()
    ccall((:vrna_md_defaults_backtrack_get, libRNA), Cint, ())
end

"""
    vrna_md_defaults_backtrack_type(t)

 @brief  Set default backtrack type, i.e. which DP matrix is used

 @see vrna_md_defaults_reset(), vrna_md_set_default(), #vrna_md_t, #VRNA_MODEL_DEFAULT_BACKTRACK_TYPE

 @param  t   The type ('F', 'C', or 'M')
### Prototype
```c
void vrna_md_defaults_backtrack_type(char t);
```
"""
function vrna_md_defaults_backtrack_type(t)
    ccall((:vrna_md_defaults_backtrack_type, libRNA), Cvoid, (Cchar,), t)
end

"""
    vrna_md_defaults_backtrack_type_get()

 @brief  Get default backtrack type, i.e. which DP matrix is used

 @see vrna_md_defaults_backtrack_type(), vrna_md_defaults_reset(), vrna_md_set_default(), #vrna_md_t, #VRNA_MODEL_DEFAULT_BACKTRACK_TYPE

 @return The global default settings that specify which DP matrix is used for backtracking
### Prototype
```c
char vrna_md_defaults_backtrack_type_get(void);
```
"""
function vrna_md_defaults_backtrack_type_get()
    ccall((:vrna_md_defaults_backtrack_type_get, libRNA), Cchar, ())
end

"""
    vrna_md_defaults_compute_bpp(flag)

 @brief  Set the default behavior for whether to compute base pair probabilities after partition function computation

 @see vrna_md_defaults_reset(), vrna_md_set_default(), #vrna_md_t, #VRNA_MODEL_DEFAULT_COMPUTE_BPP

 @param  flag  On/Off switch (0 = OFF, else = ON)
### Prototype
```c
void vrna_md_defaults_compute_bpp(int flag);
```
"""
function vrna_md_defaults_compute_bpp(flag)
    ccall((:vrna_md_defaults_compute_bpp, libRNA), Cvoid, (Cint,), flag)
end

"""
    vrna_md_defaults_compute_bpp_get()

 @brief  Get the default behavior for whether to compute base pair probabilities after partition function computation

 @see vrna_md_defaults_compute_bpp(), vrna_md_defaults_reset(), vrna_md_set_default(), #vrna_md_t, #VRNA_MODEL_DEFAULT_COMPUTE_BPP

 @return The global default settings that specify whether base pair probabilities are computed together with partition function
### Prototype
```c
int vrna_md_defaults_compute_bpp_get(void);
```
"""
function vrna_md_defaults_compute_bpp_get()
    ccall((:vrna_md_defaults_compute_bpp_get, libRNA), Cint, ())
end

"""
    vrna_md_defaults_max_bp_span(span)

 @brief  Set default maximal base pair span

 @see vrna_md_defaults_reset(), vrna_md_set_default(), #vrna_md_t, #VRNA_MODEL_DEFAULT_MAX_BP_SPAN

 @param  span  Maximal base pair span
### Prototype
```c
void vrna_md_defaults_max_bp_span(int span);
```
"""
function vrna_md_defaults_max_bp_span(span)
    ccall((:vrna_md_defaults_max_bp_span, libRNA), Cvoid, (Cint,), span)
end

"""
    vrna_md_defaults_max_bp_span_get()

 @brief  Get default maximal base pair span

 @see vrna_md_defaults_max_bp_span(), vrna_md_defaults_reset(), vrna_md_set_default(), #vrna_md_t, #VRNA_MODEL_DEFAULT_MAX_BP_SPAN

 @return The global default settings for maximum base pair span
### Prototype
```c
int vrna_md_defaults_max_bp_span_get(void);
```
"""
function vrna_md_defaults_max_bp_span_get()
    ccall((:vrna_md_defaults_max_bp_span_get, libRNA), Cint, ())
end

"""
    vrna_md_defaults_min_loop_size(size)

 @brief  Set default minimal loop size

 @see vrna_md_defaults_reset(), vrna_md_set_default(), #vrna_md_t, #TURN

 @param  size  Minimal size, i.e. number of unpaired nucleotides for a hairpin loop
### Prototype
```c
void vrna_md_defaults_min_loop_size(int size);
```
"""
function vrna_md_defaults_min_loop_size(size)
    ccall((:vrna_md_defaults_min_loop_size, libRNA), Cvoid, (Cint,), size)
end

"""
    vrna_md_defaults_min_loop_size_get()

 @brief  Get default minimal loop size

 @see vrna_md_defaults_min_loop_size(), vrna_md_defaults_reset(), vrna_md_set_default(), #vrna_md_t, #TURN

 @return The global default settings for minimal size of hairpin loops
### Prototype
```c
int vrna_md_defaults_min_loop_size_get(void);
```
"""
function vrna_md_defaults_min_loop_size_get()
    ccall((:vrna_md_defaults_min_loop_size_get, libRNA), Cint, ())
end

"""
    vrna_md_defaults_window_size(size)

 @brief  Set default window size for sliding window structure prediction approaches

 @see vrna_md_defaults_reset(), vrna_md_set_default(), #vrna_md_t, #VRNA_MODEL_DEFAULT_WINDOW_SIZE

 @param  size  The size of the sliding window
### Prototype
```c
void vrna_md_defaults_window_size(int size);
```
"""
function vrna_md_defaults_window_size(size)
    ccall((:vrna_md_defaults_window_size, libRNA), Cvoid, (Cint,), size)
end

"""
    vrna_md_defaults_window_size_get()

 @brief  Get default window size for sliding window structure prediction approaches

 @see vrna_md_defaults_window_size(), vrna_md_defaults_reset(), vrna_md_set_default(), #vrna_md_t, #VRNA_MODEL_DEFAULT_WINDOW_SIZE

 @return The global default settings for the size of the sliding window
### Prototype
```c
int vrna_md_defaults_window_size_get(void);
```
"""
function vrna_md_defaults_window_size_get()
    ccall((:vrna_md_defaults_window_size_get, libRNA), Cint, ())
end

"""
    vrna_md_defaults_oldAliEn(flag)

 @brief  Set default behavior for whether to use old energy model for comparative structure prediction

 @note   This option is outdated. Activating the old energy model usually results in worse consensus
         structure predictions.

 @see vrna_md_defaults_reset(), vrna_md_set_default(), #vrna_md_t, #VRNA_MODEL_DEFAULT_ALI_OLD_EN

 @param  flag  On/Off switch (0 = OFF, else = ON)
### Prototype
```c
void vrna_md_defaults_oldAliEn(int flag);
```
"""
function vrna_md_defaults_oldAliEn(flag)
    ccall((:vrna_md_defaults_oldAliEn, libRNA), Cvoid, (Cint,), flag)
end

"""
    vrna_md_defaults_oldAliEn_get()

 @brief  Get default behavior for whether to use old energy model for comparative structure prediction

 @see vrna_md_defaults_oldAliEn(), vrna_md_defaults_reset(), vrna_md_set_default(), #vrna_md_t, #VRNA_MODEL_DEFAULT_ALI_OLD_EN

 @return The global default settings for using old energy model for comparative structure prediction
### Prototype
```c
int vrna_md_defaults_oldAliEn_get(void);
```
"""
function vrna_md_defaults_oldAliEn_get()
    ccall((:vrna_md_defaults_oldAliEn_get, libRNA), Cint, ())
end

"""
    vrna_md_defaults_ribo(flag)

 @brief  Set default behavior for whether to use Ribosum Scoring in comparative structure prediction

 @see vrna_md_defaults_reset(), vrna_md_set_default(), #vrna_md_t, #VRNA_MODEL_DEFAULT_ALI_RIBO

 @param  flag  On/Off switch (0 = OFF, else = ON)
### Prototype
```c
void vrna_md_defaults_ribo(int flag);
```
"""
function vrna_md_defaults_ribo(flag)
    ccall((:vrna_md_defaults_ribo, libRNA), Cvoid, (Cint,), flag)
end

"""
    vrna_md_defaults_ribo_get()

 @brief  Get default behavior for whether to use Ribosum Scoring in comparative structure prediction

 @see vrna_md_defaults_ribo(), vrna_md_defaults_reset(), vrna_md_set_default(), #vrna_md_t, #VRNA_MODEL_DEFAULT_ALI_RIBO

 @return The global default settings for using Ribosum scoring in comparative structure prediction
### Prototype
```c
int vrna_md_defaults_ribo_get(void);
```
"""
function vrna_md_defaults_ribo_get()
    ccall((:vrna_md_defaults_ribo_get, libRNA), Cint, ())
end

"""
    vrna_md_defaults_cv_fact(factor)

 @brief  Set the default co-variance scaling factor used in comparative structure prediction

 @see vrna_md_defaults_reset(), vrna_md_set_default(), #vrna_md_t, #VRNA_MODEL_DEFAULT_ALI_CV_FACT

 @param  factor  The co-variance factor
### Prototype
```c
void vrna_md_defaults_cv_fact(double factor);
```
"""
function vrna_md_defaults_cv_fact(factor)
    ccall((:vrna_md_defaults_cv_fact, libRNA), Cvoid, (Cdouble,), factor)
end

"""
    vrna_md_defaults_cv_fact_get()

 @brief  Get the default co-variance scaling factor used in comparative structure prediction

 @see vrna_md_defaults_cv_fact(), vrna_md_defaults_reset(), vrna_md_set_default(), #vrna_md_t, #VRNA_MODEL_DEFAULT_ALI_CV_FACT

 @return The global default settings for the co-variance factor
### Prototype
```c
double vrna_md_defaults_cv_fact_get(void);
```
"""
function vrna_md_defaults_cv_fact_get()
    ccall((:vrna_md_defaults_cv_fact_get, libRNA), Cdouble, ())
end

"""
    vrna_md_defaults_nc_fact(factor)

 @brief

 @see vrna_md_defaults_reset(), vrna_md_set_default(), #vrna_md_t, #VRNA_MODEL_DEFAULT_ALI_NC_FACT

 @param factor
### Prototype
```c
void vrna_md_defaults_nc_fact(double factor);
```
"""
function vrna_md_defaults_nc_fact(factor)
    ccall((:vrna_md_defaults_nc_fact, libRNA), Cvoid, (Cdouble,), factor)
end

"""
    vrna_md_defaults_nc_fact_get()

 @brief

 @see vrna_md_defaults_nc_fact(), vrna_md_defaults_reset(), vrna_md_set_default(), #vrna_md_t, #VRNA_MODEL_DEFAULT_ALI_NC_FACT

 @return
### Prototype
```c
double vrna_md_defaults_nc_fact_get(void);
```
"""
function vrna_md_defaults_nc_fact_get()
    ccall((:vrna_md_defaults_nc_fact_get, libRNA), Cdouble, ())
end

"""
    vrna_md_defaults_sfact(factor)

 @brief  Set the default scaling factor used to avoid under-/overflows in partition function computation

 @see vrna_md_defaults_reset(), vrna_md_set_default(), #vrna_md_t

 @param  factor  The scaling factor  (default: 1.07)
### Prototype
```c
void vrna_md_defaults_sfact(double factor);
```
"""
function vrna_md_defaults_sfact(factor)
    ccall((:vrna_md_defaults_sfact, libRNA), Cvoid, (Cdouble,), factor)
end

"""
    vrna_md_defaults_sfact_get()

 @brief  Get the default scaling factor used to avoid under-/overflows in partition function computation

 @see vrna_md_defaults_sfact(), vrna_md_defaults_reset(), vrna_md_set_default(), #vrna_md_t

 @return The global default settings of the scaling factor
### Prototype
```c
double vrna_md_defaults_sfact_get(void);
```
"""
function vrna_md_defaults_sfact_get()
    ccall((:vrna_md_defaults_sfact_get, libRNA), Cdouble, ())
end

"""
    vrna_md_defaults_salt(salt)

 @brief Set the default salt concentration

 @param salt The sodium concentration in M (default: 1.021)
### Prototype
```c
void vrna_md_defaults_salt(double salt);
```
"""
function vrna_md_defaults_salt(salt)
    ccall((:vrna_md_defaults_salt, libRNA), Cvoid, (Cdouble,), salt)
end

"""
    vrna_md_defaults_salt_get()

 @brief Get the default salt concentration
 @return The default salt concentration
### Prototype
```c
double vrna_md_defaults_salt_get(void);
```
"""
function vrna_md_defaults_salt_get()
    ccall((:vrna_md_defaults_salt_get, libRNA), Cdouble, ())
end

"""
    vrna_md_defaults_saltMLLower(lower)

 @brief Set the default multiloop size lower bound for loop salt correciton linear fitting

 @param lower Size lower bound (number of backbone in loop)
### Prototype
```c
void vrna_md_defaults_saltMLLower(int lower);
```
"""
function vrna_md_defaults_saltMLLower(lower)
    ccall((:vrna_md_defaults_saltMLLower, libRNA), Cvoid, (Cint,), lower)
end

"""
    vrna_md_defaults_saltMLLower_get()

 @brief Get the default multiloop size lower bound for loop salt correciton linear fitting
 @return The default lower bound
### Prototype
```c
int vrna_md_defaults_saltMLLower_get(void);
```
"""
function vrna_md_defaults_saltMLLower_get()
    ccall((:vrna_md_defaults_saltMLLower_get, libRNA), Cint, ())
end

"""
    vrna_md_defaults_saltMLUpper(upper)

 @brief Set the default multiloop size upper bound for loop salt correciton linear fitting

 @param upper Size Upper bound (number of backbone in loop)
### Prototype
```c
void vrna_md_defaults_saltMLUpper(int upper);
```
"""
function vrna_md_defaults_saltMLUpper(upper)
    ccall((:vrna_md_defaults_saltMLUpper, libRNA), Cvoid, (Cint,), upper)
end

"""
    vrna_md_defaults_saltMLUpper_get()

 @brief Get the default multiloop size upper bound for loop salt correciton linear fitting
 @return The default upper bound
### Prototype
```c
int vrna_md_defaults_saltMLUpper_get(void);
```
"""
function vrna_md_defaults_saltMLUpper_get()
    ccall((:vrna_md_defaults_saltMLUpper_get, libRNA), Cint, ())
end

"""
    vrna_md_defaults_saltDPXInit(value)

 @brief Set user-provided salt correciton for duplex initialization
 If value is 99999 the default value from fitting is used

 @param value The value of salt correction for duplex initialization (in dcal/mol)
### Prototype
```c
void vrna_md_defaults_saltDPXInit(int value);
```
"""
function vrna_md_defaults_saltDPXInit(value)
    ccall((:vrna_md_defaults_saltDPXInit, libRNA), Cvoid, (Cint,), value)
end

"""
    vrna_md_defaults_saltDPXInit_get()

 @brief Get user-provided salt correciton for duplex initialization
 If value is 99999 the default value from fitting is used

 @return The user-provided salt correction for duplex initialization
### Prototype
```c
int vrna_md_defaults_saltDPXInit_get(void);
```
"""
function vrna_md_defaults_saltDPXInit_get()
    ccall((:vrna_md_defaults_saltDPXInit_get, libRNA), Cint, ())
end

"""
    vrna_md_defaults_saltDPXInitFact(value)


### Prototype
```c
void vrna_md_defaults_saltDPXInitFact(float value);
```
"""
function vrna_md_defaults_saltDPXInitFact(value)
    ccall((:vrna_md_defaults_saltDPXInitFact, libRNA), Cvoid, (Cfloat,), value)
end

"""
    vrna_md_defaults_saltDPXInitFact_get()


### Prototype
```c
float vrna_md_defaults_saltDPXInitFact_get(void);
```
"""
function vrna_md_defaults_saltDPXInitFact_get()
    ccall((:vrna_md_defaults_saltDPXInitFact_get, libRNA), Cfloat, ())
end

"""
    vrna_md_defaults_helical_rise(value)


### Prototype
```c
void vrna_md_defaults_helical_rise(float value);
```
"""
function vrna_md_defaults_helical_rise(value)
    ccall((:vrna_md_defaults_helical_rise, libRNA), Cvoid, (Cfloat,), value)
end

"""
    vrna_md_defaults_helical_rise_get()


### Prototype
```c
float vrna_md_defaults_helical_rise_get(void);
```
"""
function vrna_md_defaults_helical_rise_get()
    ccall((:vrna_md_defaults_helical_rise_get, libRNA), Cfloat, ())
end

"""
    vrna_md_defaults_backbone_length(value)


### Prototype
```c
void vrna_md_defaults_backbone_length(float value);
```
"""
function vrna_md_defaults_backbone_length(value)
    ccall((:vrna_md_defaults_backbone_length, libRNA), Cvoid, (Cfloat,), value)
end

"""
    vrna_md_defaults_backbone_length_get()


### Prototype
```c
float vrna_md_defaults_backbone_length_get(void);
```
"""
function vrna_md_defaults_backbone_length_get()
    ccall((:vrna_md_defaults_backbone_length_get, libRNA), Cfloat, ())
end

"""
    set_model_details(md)

@brief Set default model details

 Use this function if you wish to initialize a #vrna_md_t data structure with
 its default values, i.e. the global model settings as provided by the deprecated
 global variables.

 @deprecated This function will vanish as soon as backward compatibility of
             RNAlib is dropped (expected in version 3).
             Use vrna_md_set_default() instead!

 @param md A pointer to the data structure that is about to be initialized
### Prototype
```c
void set_model_details(vrna_md_t *md);
```
"""
function set_model_details(md)
    ccall((:set_model_details, libRNA), Cvoid, (Ptr{vrna_md_t},), md)
end

"""
    option_string()


### Prototype
```c
char * option_string(void);
```
"""
function option_string()
    ccall((:option_string, libRNA), Ptr{Cchar}, ())
end

"""
    vrna_param_s

 @brief The datastructure that contains temperature scaled energy parameters.
"""
struct vrna_param_s
    id::Cint
    stack::NTuple{8, NTuple{8, Cint}}
    hairpin::NTuple{31, Cint}
    bulge::NTuple{31, Cint}
    internal_loop::NTuple{31, Cint}
    mismatchExt::NTuple{8, NTuple{5, NTuple{5, Cint}}}
    mismatchI::NTuple{8, NTuple{5, NTuple{5, Cint}}}
    mismatch1nI::NTuple{8, NTuple{5, NTuple{5, Cint}}}
    mismatch23I::NTuple{8, NTuple{5, NTuple{5, Cint}}}
    mismatchH::NTuple{8, NTuple{5, NTuple{5, Cint}}}
    mismatchM::NTuple{8, NTuple{5, NTuple{5, Cint}}}
    dangle5::NTuple{8, NTuple{5, Cint}}
    dangle3::NTuple{8, NTuple{5, Cint}}
    int11::NTuple{8, NTuple{8, NTuple{5, NTuple{5, Cint}}}}
    int21::NTuple{8, NTuple{8, NTuple{5, NTuple{5, NTuple{5, Cint}}}}}
    int22::NTuple{8, NTuple{8, NTuple{5, NTuple{5, NTuple{5, NTuple{5, Cint}}}}}}
    ninio::NTuple{5, Cint}
    lxc::Cdouble
    MLbase::Cint
    MLintern::NTuple{8, Cint}
    MLclosing::Cint
    TerminalAU::Cint
    DuplexInit::Cint
    Tetraloop_E::NTuple{200, Cint}
    Tetraloops::NTuple{1401, Cchar}
    Triloop_E::NTuple{40, Cint}
    Triloops::NTuple{241, Cchar}
    Hexaloop_E::NTuple{40, Cint}
    Hexaloops::NTuple{1801, Cchar}
    TripleC::Cint
    MultipleCA::Cint
    MultipleCB::Cint
    gquad::NTuple{8, NTuple{46, Cint}}
    gquadLayerMismatch::Cint
    gquadLayerMismatchMax::Cint
    temperature::Cdouble
    model_details::vrna_md_t
    param_file::NTuple{256, Cchar}
    SaltStack::Cint
    SaltLoop::NTuple{32, Cint}
    SaltLoopDbl::NTuple{32, Cdouble}
    SaltMLbase::Cint
    SaltMLintern::Cint
    SaltMLclosing::Cint
    SaltDPXInit::Cint
end

"""
@brief Typename for the free energy parameter data structure #vrna_params 
"""
const vrna_param_t = vrna_param_s

"""
    vrna_exp_param_s

 @brief  The data structure that contains temperature scaled Boltzmann weights of the energy parameters.
"""
struct vrna_exp_param_s
    id::Cint
    expstack::NTuple{8, NTuple{8, Cdouble}}
    exphairpin::NTuple{31, Cdouble}
    expbulge::NTuple{31, Cdouble}
    expinternal::NTuple{31, Cdouble}
    expmismatchExt::NTuple{8, NTuple{5, NTuple{5, Cdouble}}}
    expmismatchI::NTuple{8, NTuple{5, NTuple{5, Cdouble}}}
    expmismatch23I::NTuple{8, NTuple{5, NTuple{5, Cdouble}}}
    expmismatch1nI::NTuple{8, NTuple{5, NTuple{5, Cdouble}}}
    expmismatchH::NTuple{8, NTuple{5, NTuple{5, Cdouble}}}
    expmismatchM::NTuple{8, NTuple{5, NTuple{5, Cdouble}}}
    expdangle5::NTuple{8, NTuple{5, Cdouble}}
    expdangle3::NTuple{8, NTuple{5, Cdouble}}
    expint11::NTuple{8, NTuple{8, NTuple{5, NTuple{5, Cdouble}}}}
    expint21::NTuple{8, NTuple{8, NTuple{5, NTuple{5, NTuple{5, Cdouble}}}}}
    expint22::NTuple{8, NTuple{8, NTuple{5, NTuple{5, NTuple{5, NTuple{5, Cdouble}}}}}}
    expninio::NTuple{5, NTuple{31, Cdouble}}
    lxc::Cdouble
    expMLbase::Cdouble
    expMLintern::NTuple{8, Cdouble}
    expMLclosing::Cdouble
    expTermAU::Cdouble
    expDuplexInit::Cdouble
    exptetra::NTuple{40, Cdouble}
    exptri::NTuple{40, Cdouble}
    exphex::NTuple{40, Cdouble}
    Tetraloops::NTuple{1401, Cchar}
    expTriloop::NTuple{40, Cdouble}
    Triloops::NTuple{241, Cchar}
    Hexaloops::NTuple{1801, Cchar}
    expTripleC::Cdouble
    expMultipleCA::Cdouble
    expMultipleCB::Cdouble
    expgquad::NTuple{8, NTuple{46, Cdouble}}
    expgquadLayerMismatch::Cdouble
    gquadLayerMismatchMax::Cint
    kT::Cdouble
    pf_scale::Cdouble
    temperature::Cdouble
    alpha::Cdouble
    model_details::vrna_md_t
    param_file::NTuple{256, Cchar}
    expSaltStack::Cdouble
    expSaltLoop::NTuple{32, Cdouble}
    SaltLoopDbl::NTuple{32, Cdouble}
    SaltMLbase::Cint
    SaltMLintern::Cint
    SaltMLclosing::Cint
    SaltDPXInit::Cint
end

"""
@brief Typename for the Boltzmann factor data structure #vrna_exp_params 
"""
const vrna_exp_param_t = vrna_exp_param_s

"""
    vrna_params(md)

 @brief  Get a data structure containing prescaled free energy parameters

 If a NULL pointer is passed for the model details parameter, the default
 model parameters are stored within the requested #vrna_param_t structure.

 @see #vrna_md_t, vrna_md_set_default(), vrna_exp_params()

 @param  md  A pointer to the model details to store inside the structure (Maybe NULL)
 @return     A pointer to the memory location where the requested parameters are stored
### Prototype
```c
vrna_param_t * vrna_params(vrna_md_t *md);
```
"""
function vrna_params(md)
    ccall((:vrna_params, libRNA), Ptr{vrna_param_t}, (Ptr{vrna_md_t},), md)
end

"""
    vrna_params_copy(par)

 @brief Get a copy of the provided free energy parameters

 If NULL is passed as parameter, a default set of energy parameters is created
 and returned.

 @see vrna_params(), #vrna_param_t

 @param  par   The free energy parameters that are to be copied (Maybe NULL)
 @return       A copy or a default set of the (provided) parameters
### Prototype
```c
vrna_param_t * vrna_params_copy(vrna_param_t *par);
```
"""
function vrna_params_copy(par)
    ccall((:vrna_params_copy, libRNA), Ptr{vrna_param_t}, (Ptr{vrna_param_t},), par)
end

"""
    vrna_exp_params(md)

 @brief  Get a data structure containing prescaled free energy parameters
         already transformed to Boltzmann factors

 This function returns a data structure that contains all necessary precomputed
 energy contributions for each type of loop.

 In contrast to vrna_params(), the free energies within this data structure
 are stored as their Boltzmann factors, i.e.

 @f\$ exp(-E / kT) @f\$

 where @f\$ E @f\$ is the free energy.

 If a NULL pointer is passed for the model details parameter, the default
 model parameters are stored within the requested #vrna_exp_param_t structure.

 @see #vrna_md_t, vrna_md_set_default(), vrna_params(), vrna_rescale_pf_params()

 @param  md  A pointer to the model details to store inside the structure (Maybe NULL)
 @return     A pointer to the memory location where the requested parameters are stored
### Prototype
```c
vrna_exp_param_t * vrna_exp_params(vrna_md_t *md);
```
"""
function vrna_exp_params(md)
    ccall((:vrna_exp_params, libRNA), Ptr{vrna_exp_param_t}, (Ptr{vrna_md_t},), md)
end

"""
    vrna_exp_params_comparative(n_seq, md)

 @brief  Get a data structure containing prescaled free energy parameters
         already transformed to Boltzmann factors (alifold version)

 If a NULL pointer is passed for the model details parameter, the default
 model parameters are stored within the requested #vrna_exp_param_t structure.

 @see #vrna_md_t, vrna_md_set_default(), vrna_exp_params(), vrna_params()

 @param  n_seq   The number of sequences in the alignment
 @param  md      A pointer to the model details to store inside the structure (Maybe NULL)
 @return         A pointer to the memory location where the requested parameters are stored
### Prototype
```c
vrna_exp_param_t * vrna_exp_params_comparative(unsigned int n_seq, vrna_md_t *md);
```
"""
function vrna_exp_params_comparative(n_seq, md)
    ccall((:vrna_exp_params_comparative, libRNA), Ptr{vrna_exp_param_t}, (Cuint, Ptr{vrna_md_t}), n_seq, md)
end

"""
    vrna_exp_params_copy(par)

 @brief Get a copy of the provided free energy parameters (provided as Boltzmann factors)

 If NULL is passed as parameter, a default set of energy parameters is created
 and returned.

 @see vrna_exp_params(), #vrna_exp_param_t

 @param  par   The free energy parameters that are to be copied (Maybe NULL)
 @return       A copy or a default set of the (provided) parameters
### Prototype
```c
vrna_exp_param_t * vrna_exp_params_copy(vrna_exp_param_t *par);
```
"""
function vrna_exp_params_copy(par)
    ccall((:vrna_exp_params_copy, libRNA), Ptr{vrna_exp_param_t}, (Ptr{vrna_exp_param_t},), par)
end

"""
    vrna_fc_type_e

 @brief  An enumerator that is used to specify the type of a #vrna_fold_compound_t
"""
@cenum vrna_fc_type_e::UInt32 begin
    VRNA_FC_TYPE_SINGLE = 0
    VRNA_FC_TYPE_COMPARATIVE = 1
end

"""
    vrna_seq_type_e

 @brief  A enumerator used in #vrna_sequence_s to distinguish different nucleotide sequences
"""
@cenum vrna_seq_type_e::UInt32 begin
    VRNA_SEQ_UNKNOWN = 0
    VRNA_SEQ_RNA = 1
    VRNA_SEQ_DNA = 2
end

"""
    vrna_sequence_s

 @brief  Data structure representing a nucleotide sequence
"""
struct vrna_sequence_s
    type::vrna_seq_type_e
    name::Ptr{Cchar}
    string::Ptr{Cchar}
    encoding::Ptr{Cshort}
    encoding5::Ptr{Cshort}
    encoding3::Ptr{Cshort}
    length::Cuint
end

"""
@brief Typename for nucleotide sequence representation data structure #vrna_sequence_s 
"""
const vrna_seq_t = vrna_sequence_s

struct vrna_alignment_s
    n_seq::Cuint
    sequences::Ptr{vrna_seq_t}
    gapfree_seq::Ptr{Ptr{Cchar}}
    gapfree_size::Ptr{Cuint}
    genome_size::Ptr{Culonglong}
    start::Ptr{Culonglong}
    orientation::Ptr{Cuchar}
    a2s::Ptr{Ptr{Cuint}}
end

const vrna_msa_t = vrna_alignment_s

"""
    vrna_hc_type_e

 @brief  The hard constraints type

 Global and local structure prediction methods use a slightly different way to
 handle hard constraints internally. This enum is used to distinguish both types.
"""
@cenum vrna_hc_type_e::UInt32 begin
    VRNA_HC_DEFAULT = 0
    VRNA_HC_WINDOW = 1
end

# typedef unsigned char ( * vrna_hc_eval_f ) ( int i , int j , int k , int l , unsigned char d , void * data )
"""
@brief Callback to evaluate whether or not a particular decomposition step is contributing to the solution space

@ingroup hard_constraints

This is the prototype for callback functions used by the folding recursions to evaluate generic
hard constraints. The first four parameters passed indicate the delimiting nucleotide positions
of the decomposition, and the parameter @p denotes the decomposition step. The last parameter
@p data is the auxiliary data structure associated to the hard constraints via vrna_hc_add_data(),
or NULL if no auxiliary data was added.

@callback
@parblock
This callback enables one to over-rule default hard constraints in secondary structure
decompositions.
@endparblock

@see #VRNA_DECOMP_PAIR_HP, #VRNA_DECOMP_PAIR_IL, #VRNA_DECOMP_PAIR_ML, #VRNA_DECOMP_ML_ML_ML,
     #VRNA_DECOMP_ML_STEM, #VRNA_DECOMP_ML_ML, #VRNA_DECOMP_ML_UP, #VRNA_DECOMP_ML_ML_STEM,
     #VRNA_DECOMP_ML_COAXIAL, #VRNA_DECOMP_EXT_EXT, #VRNA_DECOMP_EXT_UP, #VRNA_DECOMP_EXT_STEM,
     #VRNA_DECOMP_EXT_EXT_EXT, #VRNA_DECOMP_EXT_STEM_EXT, #VRNA_DECOMP_EXT_EXT_STEM,
     #VRNA_DECOMP_EXT_EXT_STEM1, vrna_hc_add_f(), vrna_hc_add_data()

@param i         Left (5') delimiter position of substructure
@param j         Right (3') delimiter position of substructure
@param k         Left delimiter of decomposition
@param l         Right delimiter of decomposition
@param d         Decomposition step indicator
@param data      Auxiliary data
@return          A non-zero value if the decomposition is valid, 0 otherwise
"""
const vrna_hc_eval_f = Ptr{Cvoid}

# typedef void ( * vrna_auxdata_free_f ) ( void * data )
"""
 @brief Callback to free memory allocated for auxiliary user-provided data

 This type of user-implemented function usually deletes auxiliary data structures.
 The user must take care to free all the memory occupied by the data structure passed.

 @callback
 @parblock
 This callback is supposed to free memory occupied by an auxiliary data structure.
 It will be called when the #vrna_fold_compound_t is erased from memory through a
 call to vrna_fold_compound_free() and will be passed the address of memory previously
 bound to the #vrna_fold_compound_t via vrna_fold_compound_add_auxdata().
 @endparblock

 @see vrna_fold_compound_add_auxdata(), vrna_fold_compound_free(), vrna_fold_compound_add_callback()

 @param data    The data that needs to be free'd
"""
const vrna_auxdata_free_f = Ptr{Cvoid}

mutable struct vrna_hc_depot_s end

const vrna_hc_depot_t = vrna_hc_depot_s

"""
    vrna_hc_s

 @brief  The hard constraints data structure

 The content of this data structure determines the decomposition pattern
 used in the folding recursions. Attribute 'matrix' is used as source for
 the branching pattern of the decompositions during all folding recursions.
 Any entry in matrix[i,j] consists of the 6 LSB that allows one to distinguish the
 following types of base pairs:
 - in the exterior loop (#VRNA_CONSTRAINT_CONTEXT_EXT_LOOP)
 - enclosing a hairpin (#VRNA_CONSTRAINT_CONTEXT_HP_LOOP)
 - enclosing an interior loop (#VRNA_CONSTRAINT_CONTEXT_INT_LOOP)
 - enclosed by an exterior loop (#VRNA_CONSTRAINT_CONTEXT_INT_LOOP_ENC)
 - enclosing a multi branch loop (#VRNA_CONSTRAINT_CONTEXT_MB_LOOP)
 - enclosed by a multi branch loop (#VRNA_CONSTRAINT_CONTEXT_MB_LOOP_ENC)

 The four linear arrays 'up_xxx' provide the number of available unpaired
 nucleotides (including position i) 3' of each position in the sequence.

 @see  vrna_hc_init(), vrna_hc_free(), #VRNA_CONSTRAINT_CONTEXT_EXT_LOOP,
       #VRNA_CONSTRAINT_CONTEXT_HP_LOOP, #VRNA_CONSTRAINT_CONTEXT_INT_LOOP,
       #VRNA_CONSTRAINT_CONTEXT_MB_LOOP, #VRNA_CONSTRAINT_CONTEXT_MB_LOOP_ENC

 @ingroup hard_constraints
"""
struct vrna_hc_s
    type::vrna_hc_type_e
    n::Cuint
    state::Cuchar
    mx::Ptr{Cuchar}
    matrix_local::Ptr{Ptr{Cuchar}}
    up_ext::Ptr{Cint}
    up_hp::Ptr{Cint}
    up_int::Ptr{Cint}
    up_ml::Ptr{Cint}
    f::vrna_hc_eval_f
    data::Ptr{Cvoid}
    free_data::vrna_auxdata_free_f
    depot::Ptr{vrna_hc_depot_t}
end

"""
 @brief Typename for the hard constraints data structure #vrna_hc_s
 @ingroup  hard_constraints
"""
const vrna_hc_t = vrna_hc_s

"""
    vrna_mx_type_e

 @brief  An enumerator that is used to specify the type of a polymorphic Dynamic Programming (DP)
 matrix data structure

 @see #vrna_mx_mfe_t, #vrna_mx_pf_t
"""
@cenum vrna_mx_type_e::UInt32 begin
    VRNA_MX_DEFAULT = 0
    VRNA_MX_WINDOW = 1
    VRNA_MX_2DFOLD = 2
end

"""
    vrna_mx_mfe_s

 @brief  Minimum Free Energy (MFE) Dynamic Programming (DP) matrices data structure required within the #vrna_fold_compound_t
"""
struct vrna_mx_mfe_s
    type::vrna_mx_type_e
    length::Cuint
    strands::Cuint
    c::Ptr{Cint}
    f5::Ptr{Cint}
    f3::Ptr{Cint}
    fms5::Ptr{Ptr{Cint}}
    fms3::Ptr{Ptr{Cint}}
    fML::Ptr{Cint}
    fM1::Ptr{Cint}
    fM2::Ptr{Cint}
    ggg::Ptr{Cint}
    Fc::Cint
    FcH::Cint
    FcI::Cint
    FcM::Cint
    c_local::Ptr{Ptr{Cint}}
    f3_local::Ptr{Cint}
    fML_local::Ptr{Ptr{Cint}}
    ggg_local::Ptr{Ptr{Cint}}
    E_F5::Ptr{Ptr{Ptr{Cint}}}
    l_min_F5::Ptr{Ptr{Cint}}
    l_max_F5::Ptr{Ptr{Cint}}
    k_min_F5::Ptr{Cint}
    k_max_F5::Ptr{Cint}
    E_F3::Ptr{Ptr{Ptr{Cint}}}
    l_min_F3::Ptr{Ptr{Cint}}
    l_max_F3::Ptr{Ptr{Cint}}
    k_min_F3::Ptr{Cint}
    k_max_F3::Ptr{Cint}
    E_C::Ptr{Ptr{Ptr{Cint}}}
    l_min_C::Ptr{Ptr{Cint}}
    l_max_C::Ptr{Ptr{Cint}}
    k_min_C::Ptr{Cint}
    k_max_C::Ptr{Cint}
    E_M::Ptr{Ptr{Ptr{Cint}}}
    l_min_M::Ptr{Ptr{Cint}}
    l_max_M::Ptr{Ptr{Cint}}
    k_min_M::Ptr{Cint}
    k_max_M::Ptr{Cint}
    E_M1::Ptr{Ptr{Ptr{Cint}}}
    l_min_M1::Ptr{Ptr{Cint}}
    l_max_M1::Ptr{Ptr{Cint}}
    k_min_M1::Ptr{Cint}
    k_max_M1::Ptr{Cint}
    E_M2::Ptr{Ptr{Ptr{Cint}}}
    l_min_M2::Ptr{Ptr{Cint}}
    l_max_M2::Ptr{Ptr{Cint}}
    k_min_M2::Ptr{Cint}
    k_max_M2::Ptr{Cint}
    E_Fc::Ptr{Ptr{Cint}}
    l_min_Fc::Ptr{Cint}
    l_max_Fc::Ptr{Cint}
    k_min_Fc::Cint
    k_max_Fc::Cint
    E_FcH::Ptr{Ptr{Cint}}
    l_min_FcH::Ptr{Cint}
    l_max_FcH::Ptr{Cint}
    k_min_FcH::Cint
    k_max_FcH::Cint
    E_FcI::Ptr{Ptr{Cint}}
    l_min_FcI::Ptr{Cint}
    l_max_FcI::Ptr{Cint}
    k_min_FcI::Cint
    k_max_FcI::Cint
    E_FcM::Ptr{Ptr{Cint}}
    l_min_FcM::Ptr{Cint}
    l_max_FcM::Ptr{Cint}
    k_min_FcM::Cint
    k_max_FcM::Cint
    E_F5_rem::Ptr{Cint}
    E_F3_rem::Ptr{Cint}
    E_C_rem::Ptr{Cint}
    E_M_rem::Ptr{Cint}
    E_M1_rem::Ptr{Cint}
    E_M2_rem::Ptr{Cint}
    E_Fc_rem::Cint
    E_FcH_rem::Cint
    E_FcI_rem::Cint
    E_FcM_rem::Cint
end

"""
@brief Typename for the Minimum Free Energy (MFE) DP matrices data structure #vrna_mx_mfe_s 
"""
const vrna_mx_mfe_t = vrna_mx_mfe_s

"""
    vrna_mx_pf_s

 @brief  Partition function (PF) Dynamic Programming (DP) matrices data structure required within the #vrna_fold_compound_t
"""
struct vrna_mx_pf_s
    type::vrna_mx_type_e
    length::Cuint
    scale::Ptr{FLT_OR_DBL}
    expMLbase::Ptr{FLT_OR_DBL}
    q::Ptr{FLT_OR_DBL}
    qb::Ptr{FLT_OR_DBL}
    qm::Ptr{FLT_OR_DBL}
    qm1::Ptr{FLT_OR_DBL}
    probs::Ptr{FLT_OR_DBL}
    q1k::Ptr{FLT_OR_DBL}
    qln::Ptr{FLT_OR_DBL}
    G::Ptr{FLT_OR_DBL}
    qo::FLT_OR_DBL
    qm2::Ptr{FLT_OR_DBL}
    qho::FLT_OR_DBL
    qio::FLT_OR_DBL
    qmo::FLT_OR_DBL
    q_local::Ptr{Ptr{FLT_OR_DBL}}
    qb_local::Ptr{Ptr{FLT_OR_DBL}}
    qm_local::Ptr{Ptr{FLT_OR_DBL}}
    pR::Ptr{Ptr{FLT_OR_DBL}}
    qm2_local::Ptr{Ptr{FLT_OR_DBL}}
    QI5::Ptr{Ptr{FLT_OR_DBL}}
    q2l::Ptr{Ptr{FLT_OR_DBL}}
    qmb::Ptr{Ptr{FLT_OR_DBL}}
    G_local::Ptr{Ptr{FLT_OR_DBL}}
    Q::Ptr{Ptr{Ptr{FLT_OR_DBL}}}
    l_min_Q::Ptr{Ptr{Cint}}
    l_max_Q::Ptr{Ptr{Cint}}
    k_min_Q::Ptr{Cint}
    k_max_Q::Ptr{Cint}
    Q_B::Ptr{Ptr{Ptr{FLT_OR_DBL}}}
    l_min_Q_B::Ptr{Ptr{Cint}}
    l_max_Q_B::Ptr{Ptr{Cint}}
    k_min_Q_B::Ptr{Cint}
    k_max_Q_B::Ptr{Cint}
    Q_M::Ptr{Ptr{Ptr{FLT_OR_DBL}}}
    l_min_Q_M::Ptr{Ptr{Cint}}
    l_max_Q_M::Ptr{Ptr{Cint}}
    k_min_Q_M::Ptr{Cint}
    k_max_Q_M::Ptr{Cint}
    Q_M1::Ptr{Ptr{Ptr{FLT_OR_DBL}}}
    l_min_Q_M1::Ptr{Ptr{Cint}}
    l_max_Q_M1::Ptr{Ptr{Cint}}
    k_min_Q_M1::Ptr{Cint}
    k_max_Q_M1::Ptr{Cint}
    Q_M2::Ptr{Ptr{Ptr{FLT_OR_DBL}}}
    l_min_Q_M2::Ptr{Ptr{Cint}}
    l_max_Q_M2::Ptr{Ptr{Cint}}
    k_min_Q_M2::Ptr{Cint}
    k_max_Q_M2::Ptr{Cint}
    Q_c::Ptr{Ptr{FLT_OR_DBL}}
    l_min_Q_c::Ptr{Cint}
    l_max_Q_c::Ptr{Cint}
    k_min_Q_c::Cint
    k_max_Q_c::Cint
    Q_cH::Ptr{Ptr{FLT_OR_DBL}}
    l_min_Q_cH::Ptr{Cint}
    l_max_Q_cH::Ptr{Cint}
    k_min_Q_cH::Cint
    k_max_Q_cH::Cint
    Q_cI::Ptr{Ptr{FLT_OR_DBL}}
    l_min_Q_cI::Ptr{Cint}
    l_max_Q_cI::Ptr{Cint}
    k_min_Q_cI::Cint
    k_max_Q_cI::Cint
    Q_cM::Ptr{Ptr{FLT_OR_DBL}}
    l_min_Q_cM::Ptr{Cint}
    l_max_Q_cM::Ptr{Cint}
    k_min_Q_cM::Cint
    k_max_Q_cM::Cint
    Q_rem::Ptr{FLT_OR_DBL}
    Q_B_rem::Ptr{FLT_OR_DBL}
    Q_M_rem::Ptr{FLT_OR_DBL}
    Q_M1_rem::Ptr{FLT_OR_DBL}
    Q_M2_rem::Ptr{FLT_OR_DBL}
    Q_c_rem::FLT_OR_DBL
    Q_cH_rem::FLT_OR_DBL
    Q_cI_rem::FLT_OR_DBL
    Q_cM_rem::FLT_OR_DBL
end

"""
@brief Typename for the Partition Function (PF) DP matrices data structure #vrna_mx_pf_s 
"""
const vrna_mx_pf_t = vrna_mx_pf_s

# typedef void ( * vrna_recursion_status_f ) ( unsigned char status , void * data )
"""
 @brief Callback to perform specific user-defined actions before, or after recursive computations

 @callback
 @parblock
 This function will be called to notify a third-party implementation about the status of
 a currently ongoing recursion. The purpose of this callback mechanism is to provide users
 with a simple way to ensure pre- and post conditions for auxiliary mechanisms attached to
 our implementations.
 @endparblock

 @see vrna_fold_compound_add_auxdata(), vrna_fold_compound_add_callback(), vrna_mfe(),
      vrna_pf(),
      #VRNA_STATUS_MFE_PRE, #VRNA_STATUS_MFE_POST, #VRNA_STATUS_PF_PRE, #VRNA_STATUS_PF_POST

 @param status   The status indicator
 @param data     The data structure that was assigned with vrna_fold_compound_add_auxdata()
"""
const vrna_recursion_status_f = Ptr{Cvoid}

struct vrna_structured_domains_s
    __placeholder::Cchar
end

"""
 @addtogroup domains_struc

 @brief  Add and modify structured domains to the RNA folding grammar

 This module provides the tools to add and modify structured domains to the production rules of the RNA folding grammar.
 Usually this functionality is utilized for incorporating self-enclosed structural modules that exhibit a more or less
 complex base pairing pattern.
"""
const vrna_sd_t = vrna_structured_domains_s

# typedef void ( * vrna_ud_production_f ) ( vrna_fold_compound_t * fc , void * data )
"""
 @brief Callback for pre-processing the production rule of the ligand binding to unpaired stretches feature

 @ingroup domains_up

 @callback
 @parblock
 The production rule for the unstructured domain grammar extension
 @endparblock
"""
const vrna_ud_production_f = Ptr{Cvoid}

# typedef void ( * vrna_ud_exp_production_f ) ( vrna_fold_compound_t * fc , void * data )
"""
 @brief Callback for pre-processing the production rule of the ligand binding to unpaired stretches feature (partition function variant)

 @ingroup domains_up

 @callback
 @parblock
 The production rule for the unstructured domain grammar extension (Partition function variant)
 @endparblock
"""
const vrna_ud_exp_production_f = Ptr{Cvoid}

# typedef int ( * vrna_ud_f ) ( vrna_fold_compound_t * fc , int i , int j , unsigned int loop_type , void * data )
"""
 @brief Callback to retrieve binding free energy of a ligand bound to an unpaired sequence segment

 @ingroup domains_up

 @callback
 @parblock
 This function will be called to determine the additional energy contribution of a specific unstructured
 domain, e.g. the binding free energy of some ligand.
 @endparblock

 @param  fc        The current #vrna_fold_compound_t
 @param  i         The start of the unstructured domain (5' end)
 @param  j         The end of the unstructured domain (3' end)
 @param  loop_type The loop context of the unstructured domain
 @param  data      Auxiliary data
 @return           The auxiliary energy contribution in deka-cal/mol
"""
const vrna_ud_f = Ptr{Cvoid}

# typedef FLT_OR_DBL ( * vrna_ud_exp_f ) ( vrna_fold_compound_t * fc , int i , int j , unsigned int loop_type , void * data )
"""
 @brief Callback to retrieve Boltzmann factor of the binding free energy of a ligand bound to an unpaired sequence segment
 @ingroup domains_up

 @callback
 @parblock
 This function will be called to determine the additional energy contribution of a specific unstructured
 domain, e.g. the binding free energy of some ligand (Partition function variant, i.e. the Boltzmann factors
 instead of actual free energies).
 @endparblock

 @param  fc        The current #vrna_fold_compound_t
 @param  i         The start of the unstructured domain (5' end)
 @param  j         The end of the unstructured domain (3' end)
 @param  loop_type The loop context of the unstructured domain
 @param  data      Auxiliary data
 @return           The auxiliary energy contribution as Boltzmann factor
"""
const vrna_ud_exp_f = Ptr{Cvoid}

# typedef void ( * vrna_ud_add_probs_f ) ( vrna_fold_compound_t * fc , int i , int j , unsigned int loop_type , FLT_OR_DBL exp_energy , void * data )
"""
 @brief Callback to store/add equilibrium probability for a ligand bound to an unpaired sequence segment
 @ingroup domains_up

 @callback
 @parblock
 A callback function to store equilibrium probabilities for the unstructured domain feature
 @endparblock
"""
const vrna_ud_add_probs_f = Ptr{Cvoid}

# typedef FLT_OR_DBL ( * vrna_ud_get_probs_f ) ( vrna_fold_compound_t * fc , int i , int j , unsigned int loop_type , int motif , void * data )
"""
 @brief Callback to retrieve equilibrium probability for a ligand bound to an unpaired sequence segment
 @ingroup domains_up

 @callback
 @parblock
 A callback function to retrieve equilibrium probabilities for the unstructured domain feature
 @endparblock
"""
const vrna_ud_get_probs_f = Ptr{Cvoid}

"""
    vrna_unstructured_domain_s

 @brief  Data structure to store all functionality for ligand binding
 @ingroup domains_up
"""
struct vrna_unstructured_domain_s
    uniq_motif_count::Cint
    uniq_motif_size::Ptr{Cuint}
    motif_count::Cint
    motif::Ptr{Ptr{Cchar}}
    motif_name::Ptr{Ptr{Cchar}}
    motif_size::Ptr{Cuint}
    motif_en::Ptr{Cdouble}
    motif_type::Ptr{Cuint}
    prod_cb::vrna_ud_production_f
    exp_prod_cb::vrna_ud_exp_production_f
    energy_cb::vrna_ud_f
    exp_energy_cb::vrna_ud_exp_f
    data::Ptr{Cvoid}
    free_data::vrna_auxdata_free_f
    probs_add::vrna_ud_add_probs_f
    probs_get::vrna_ud_get_probs_f
end

"""
@brief Typename for the ligand binding extension data structure #vrna_unstructured_domain_s
 @ingroup domains_up
"""
const vrna_ud_t = vrna_unstructured_domain_s

# typedef void ( * vrna_grammar_cond_f ) ( vrna_fold_compound_t * fc , unsigned char stage , void * data )
const vrna_grammar_cond_f = Ptr{Cvoid}

# typedef int ( * vrna_grammar_rule_f ) ( vrna_fold_compound_t * fc , int i , int j , void * data )
const vrna_grammar_rule_f = Ptr{Cvoid}

# typedef void ( * vrna_grammar_rule_f_aux ) ( vrna_fold_compound_t * fc , int i , int j , void * data )
const vrna_grammar_rule_f_aux = Ptr{Cvoid}

# typedef FLT_OR_DBL ( * vrna_grammar_rule_f_exp ) ( vrna_fold_compound_t * fc , int i , int j , void * data )
const vrna_grammar_rule_f_exp = Ptr{Cvoid}

# typedef void ( * vrna_grammar_rule_f_aux_exp ) ( vrna_fold_compound_t * fc , int i , int j , void * data )
const vrna_grammar_rule_f_aux_exp = Ptr{Cvoid}

# typedef void ( * vrna_grammar_data_free_f ) ( void * data )
"""
 @brief  Free auxiliary data
 @param  data  The auxiliary data to be free'd
"""
const vrna_grammar_data_free_f = Ptr{Cvoid}

struct vrna_gr_aux_s
    cb_proc::vrna_grammar_cond_f
    cb_aux_f::vrna_grammar_rule_f
    cb_aux_c::vrna_grammar_rule_f
    cb_aux_m::vrna_grammar_rule_f
    cb_aux_m1::vrna_grammar_rule_f
    cb_aux::vrna_grammar_rule_f_aux
    cb_aux_exp_f::vrna_grammar_rule_f_exp
    cb_aux_exp_c::vrna_grammar_rule_f_exp
    cb_aux_exp_m::vrna_grammar_rule_f_exp
    cb_aux_exp_m1::vrna_grammar_rule_f_exp
    cb_aux_exp::vrna_grammar_rule_f_aux_exp
    data::Ptr{Cvoid}
    free_data::vrna_grammar_data_free_f
end

const vrna_gr_aux_t = vrna_gr_aux_s

"""
    vrna_sc_type_e

 @brief  The type of a soft constraint
"""
@cenum vrna_sc_type_e::UInt32 begin
    VRNA_SC_DEFAULT = 0
    VRNA_SC_WINDOW = 1
end

"""
    vrna_sc_bp_storage_t

 @brief  A base pair constraint
"""
struct vrna_sc_bp_storage_t
    interval_start::Cuint
    interval_end::Cuint
    e::Cint
end

# typedef int ( * vrna_sc_f ) ( int i , int j , int k , int l , unsigned char d , void * data )
"""
@brief Callback to retrieve pseudo energy contribution for soft constraint feature

@ingroup soft_constraints

This is the prototype for callback functions used by the folding recursions to evaluate generic
soft constraints. The first four parameters passed indicate the delimiting nucleotide positions
of the decomposition, and the parameter @p denotes the decomposition step. The last parameter
@p data is the auxiliary data structure associated to the hard constraints via vrna_sc_add_data(),
or NULL if no auxiliary data was added.

@callback
@parblock
This callback enables one to add (pseudo-)energy contributions to individual decompositions
of the secondary structure.
@endparblock

@see #VRNA_DECOMP_PAIR_HP, #VRNA_DECOMP_PAIR_IL, #VRNA_DECOMP_PAIR_ML, #VRNA_DECOMP_ML_ML_ML,
     #VRNA_DECOMP_ML_STEM, #VRNA_DECOMP_ML_ML, #VRNA_DECOMP_ML_UP, #VRNA_DECOMP_ML_ML_STEM,
     #VRNA_DECOMP_ML_COAXIAL, #VRNA_DECOMP_EXT_EXT, #VRNA_DECOMP_EXT_UP, #VRNA_DECOMP_EXT_STEM,
     #VRNA_DECOMP_EXT_EXT_EXT, #VRNA_DECOMP_EXT_STEM_EXT, #VRNA_DECOMP_EXT_EXT_STEM,
     #VRNA_DECOMP_EXT_EXT_STEM1, vrna_sc_add_f(), vrna_sc_add_exp_f(), vrna_sc_add_bt(),
     vrna_sc_add_data()

@param i         Left (5') delimiter position of substructure
@param j         Right (3') delimiter position of substructure
@param k         Left delimiter of decomposition
@param l         Right delimiter of decomposition
@param d         Decomposition step indicator
@param data      Auxiliary data
@return          Pseudo energy contribution in deka-kalories per mol
"""
const vrna_sc_f = Ptr{Cvoid}

# typedef vrna_basepair_t * ( * vrna_sc_bt_f ) ( int i , int j , int k , int l , unsigned char d , void * data )
"""
@brief Callback to retrieve auxiliary base pairs for soft constraint feature

@ingroup soft_constraints

@callback
@parblock
This callback enables one to add auxiliary base pairs in the backtracking steps
of hairpin- and interior loops.
@endparblock

@see #VRNA_DECOMP_PAIR_HP, #VRNA_DECOMP_PAIR_IL, #VRNA_DECOMP_PAIR_ML, #VRNA_DECOMP_ML_ML_ML,
     #VRNA_DECOMP_ML_STEM, #VRNA_DECOMP_ML_ML, #VRNA_DECOMP_ML_UP, #VRNA_DECOMP_ML_ML_STEM,
     #VRNA_DECOMP_ML_COAXIAL, #VRNA_DECOMP_EXT_EXT, #VRNA_DECOMP_EXT_UP, #VRNA_DECOMP_EXT_STEM,
     #VRNA_DECOMP_EXT_EXT_EXT, #VRNA_DECOMP_EXT_STEM_EXT, #VRNA_DECOMP_EXT_EXT_STEM,
     #VRNA_DECOMP_EXT_EXT_STEM1, vrna_sc_add_bt(), vrna_sc_add_f(), vrna_sc_add_exp_f(),
     vrna_sc_add_data()

@param i         Left (5') delimiter position of substructure
@param j         Right (3') delimiter position of substructure
@param k         Left delimiter of decomposition
@param l         Right delimiter of decomposition
@param d         Decomposition step indicator
@param data      Auxiliary data
@return          List of additional base pairs
"""
const vrna_sc_bt_f = Ptr{Cvoid}

# typedef FLT_OR_DBL ( * vrna_sc_exp_f ) ( int i , int j , int k , int l , unsigned char d , void * data )
"""
@brief Callback to retrieve pseudo energy contribution as Boltzmann Factors for soft constraint feature

@ingroup soft_constraints

This is the prototype for callback functions used by the partition function recursions to evaluate generic
soft constraints. The first four parameters passed indicate the delimiting nucleotide positions
of the decomposition, and the parameter @p denotes the decomposition step. The last parameter
@p data is the auxiliary data structure associated to the hard constraints via vrna_sc_add_data(),
or NULL if no auxiliary data was added.

@callback
@parblock
This callback enables one to add (pseudo-)energy contributions to individual decompositions
of the secondary structure (Partition function variant, i.e. contributions must be returned as Boltzmann factors).
@endparblock

@see #VRNA_DECOMP_PAIR_HP, #VRNA_DECOMP_PAIR_IL, #VRNA_DECOMP_PAIR_ML, #VRNA_DECOMP_ML_ML_ML,
     #VRNA_DECOMP_ML_STEM, #VRNA_DECOMP_ML_ML, #VRNA_DECOMP_ML_UP, #VRNA_DECOMP_ML_ML_STEM,
     #VRNA_DECOMP_ML_COAXIAL, #VRNA_DECOMP_EXT_EXT, #VRNA_DECOMP_EXT_UP, #VRNA_DECOMP_EXT_STEM,
     #VRNA_DECOMP_EXT_EXT_EXT, #VRNA_DECOMP_EXT_STEM_EXT, #VRNA_DECOMP_EXT_EXT_STEM,
     #VRNA_DECOMP_EXT_EXT_STEM1, vrna_sc_add_exp_f(), vrna_sc_add_f(), vrna_sc_add_bt(),
     vrna_sc_add_data()

@param i         Left (5') delimiter position of substructure
@param j         Right (3') delimiter position of substructure
@param k         Left delimiter of decomposition
@param l         Right delimiter of decomposition
@param d         Decomposition step indicator
@param data      Auxiliary data
@return          Pseudo energy contribution in deka-kalories per mol
"""
const vrna_sc_exp_f = Ptr{Cvoid}

"""
    vrna_sc_s

 @brief  The soft constraints data structure

 @ingroup soft_constraints
"""
struct vrna_sc_s
    type::vrna_sc_type_e
    n::Cuint
    state::Cuchar
    energy_up::Ptr{Ptr{Cint}}
    exp_energy_up::Ptr{Ptr{FLT_OR_DBL}}
    up_storage::Ptr{Cint}
    bp_storage::Ptr{Ptr{vrna_sc_bp_storage_t}}
    energy_bp::Ptr{Cint}
    exp_energy_bp::Ptr{FLT_OR_DBL}
    energy_bp_local::Ptr{Ptr{Cint}}
    exp_energy_bp_local::Ptr{Ptr{FLT_OR_DBL}}
    energy_stack::Ptr{Cint}
    exp_energy_stack::Ptr{FLT_OR_DBL}
    f::vrna_sc_f
    bt::vrna_sc_bt_f
    exp_f::vrna_sc_exp_f
    data::Ptr{Cvoid}
    free_data::vrna_auxdata_free_f
end

"""
@brief Typename for the soft constraints data structure #vrna_sc_s
 @ingroup  soft_constraints
"""
const vrna_sc_t = vrna_sc_s

"""
    vrna_fc_s

 @brief  The most basic data structure required by many functions throughout the RNAlib

 @note   Please read the documentation of this data structure carefully! Some attributes are only available for
         specific types this data structure can adopt.

 @warning  Reading/Writing from/to attributes that are not within the scope of the current type usually result
           in undefined behavior!

 @see  #vrna_fold_compound_t.type, vrna_fold_compound(), vrna_fold_compound_comparative(), vrna_fold_compound_free(),
       #VRNA_FC_TYPE_SINGLE, #VRNA_FC_TYPE_COMPARATIVE
"""
struct vrna_fc_s
    type::vrna_fc_type_e
    length::Cuint
    cutpoint::Cint
    strand_number::Ptr{Cuint}
    strand_order::Ptr{Cuint}
    strand_order_uniq::Ptr{Cuint}
    strand_start::Ptr{Cuint}
    strand_end::Ptr{Cuint}
    strands::Cuint
    nucleotides::Ptr{vrna_seq_t}
    alignment::Ptr{vrna_msa_t}
    hc::Ptr{vrna_hc_t}
    matrices::Ptr{vrna_mx_mfe_t}
    exp_matrices::Ptr{vrna_mx_pf_t}
    params::Ptr{vrna_param_t}
    exp_params::Ptr{vrna_exp_param_t}
    iindx::Ptr{Cint}
    jindx::Ptr{Cint}
    stat_cb::vrna_recursion_status_f
    auxdata::Ptr{Cvoid}
    free_auxdata::vrna_auxdata_free_f
    domains_struc::Ptr{vrna_sd_t}
    domains_up::Ptr{vrna_ud_t}
    aux_grammar::Ptr{vrna_gr_aux_t}
    sequence::Ptr{Cchar}
    sequence_encoding::Ptr{Cshort}
    encoding5::Ptr{Cshort}
    encoding3::Ptr{Cshort}
    sequence_encoding2::Ptr{Cshort}
    ptype::Ptr{Cchar}
    ptype_pf_compat::Ptr{Cchar}
    sc::Ptr{vrna_sc_t}
    sequences::Ptr{Ptr{Cchar}}
    n_seq::Cuint
    cons_seq::Ptr{Cchar}
    S_cons::Ptr{Cshort}
    S::Ptr{Ptr{Cshort}}
    S5::Ptr{Ptr{Cshort}}
    S3::Ptr{Ptr{Cshort}}
    Ss::Ptr{Ptr{Cchar}}
    a2s::Ptr{Ptr{Cuint}}
    pscore::Ptr{Cint}
    pscore_local::Ptr{Ptr{Cint}}
    pscore_pf_compat::Ptr{Cshort}
    scs::Ptr{Ptr{vrna_sc_t}}
    oldAliEn::Cint
    maxD1::Cuint
    maxD2::Cuint
    reference_pt1::Ptr{Cshort}
    reference_pt2::Ptr{Cshort}
    referenceBPs1::Ptr{Cuint}
    referenceBPs2::Ptr{Cuint}
    bpdist::Ptr{Cuint}
    mm1::Ptr{Cuint}
    mm2::Ptr{Cuint}
    window_size::Cint
    ptype_local::Ptr{Ptr{Cchar}}
end

"""
 @brief Typename for the fold_compound data structure #vrna_fc_s
"""
const vrna_fold_compound_t = vrna_fc_s

"""
    vrna_params_subst(fc, par)

 @brief  Update/Reset energy parameters data structure within a #vrna_fold_compound_t

 Passing NULL as second argument leads to a reset of the energy parameters within
 fc to their default values. Otherwise, the energy parameters provided will be copied
 over into fc.

 @see vrna_params_reset(), #vrna_param_t, #vrna_md_t, vrna_params()

 @param  fc    The #vrna_fold_compound_t that is about to receive updated energy parameters
 @param  par   The energy parameters used to substitute those within fc (Maybe NULL)
### Prototype
```c
void vrna_params_subst(vrna_fold_compound_t *fc, vrna_param_t *par);
```
"""
function vrna_params_subst(fc, par)
    ccall((:vrna_params_subst, libRNA), Cvoid, (Ptr{vrna_fold_compound_t}, Ptr{vrna_param_t}), fc, par)
end

"""
    vrna_exp_params_subst(fc, params)

 @brief Update the energy parameters for subsequent partition function computations

 This function can be used to properly assign new energy parameters for partition
 function computations to a #vrna_fold_compound_t. For this purpose, the data of the
 provided pointer `params`  will be copied into `fc` and a recomputation of the partition
 function scaling factor is issued, if the `pf_scale` attribute of `params` is less than `1.0`.

 Passing NULL as second argument leads to a reset of the energy parameters within
 fc to their default values

 @see  vrna_exp_params_reset(), vrna_exp_params_rescale(), #vrna_exp_param_t, #vrna_md_t,
       vrna_exp_params()

 @param  fc      The fold compound data structure
 @param  params  A pointer to the new energy parameters
### Prototype
```c
void vrna_exp_params_subst(vrna_fold_compound_t *fc, vrna_exp_param_t *params);
```
"""
function vrna_exp_params_subst(fc, params)
    ccall((:vrna_exp_params_subst, libRNA), Cvoid, (Ptr{vrna_fold_compound_t}, Ptr{vrna_exp_param_t}), fc, params)
end

"""
    vrna_exp_params_rescale(fc, mfe)

 @brief Rescale Boltzmann factors for partition function computations

 This function may be used to (automatically) rescale the Boltzmann factors used
 in partition function computations. Since partition functions over subsequences
 can easily become extremely large, the RNAlib internally rescales them to avoid
 numerical over- and/or underflow. Therefore, a proper scaling factor @f\$s@f\$ needs to
 be chosen that in turn is then used to normalize the corresponding
 partition functions @f\$\\hat{q}[i,j] = q[i,j] / s^{(j-i+1)}@f\$.

 This function provides two ways to automatically adjust the scaling
 factor.
 1. Automatic guess
 2. Automatic adjustment according to MFE

 Passing `NULL` as second parameter activates the _automatic guess mode_. Here,
 the scaling factor is recomputed according to a mean free energy of `184.3*length` cal
 for random sequences.
 @note This recomputation only takes place if the `pf_scale` attribute of the
       `exp_params` data structure contained in `fc` has a value below `1.0`.

 On the other hand, if the MFE for a sequence is known, it can be used to recompute
 a more robust scaling factor, since it represents the lowest free energy of the entire
 ensemble of structures, i.e. the highest Boltzmann factor. To activate this second
 mode of _automatic adjustment according to MFE_, a pointer to the MFE value needs to
 be passed as second argument. This value is then taken to compute the scaling factor
 as @f\$ s = exp((sfact * MFE) / kT / length )@f\$, where sfact is an additional
 scaling weight located in the vrna_md_t data structure of `exp_params` in `fc`.

 The computed scaling factor @f\$s@f\$ will be stored as `pf_scale` attribute of the
 `exp_params` data structure in `fc`.

 @see vrna_exp_params_subst(), vrna_md_t, vrna_exp_param_t, #vrna_fold_compound_t

 @param  fc  The fold compound data structure
 @param  mfe A pointer to the MFE (in kcal/mol) or NULL
### Prototype
```c
void vrna_exp_params_rescale(vrna_fold_compound_t *fc, double *mfe);
```
"""
function vrna_exp_params_rescale(fc, mfe)
    ccall((:vrna_exp_params_rescale, libRNA), Cvoid, (Ptr{vrna_fold_compound_t}, Ptr{Cdouble}), fc, mfe)
end

"""
    vrna_params_reset(fc, md)

 @brief  Reset free energy parameters within a #vrna_fold_compound_t
         according to provided, or default model details

 This function allows one to rescale free energy parameters for subsequent structure
 prediction or evaluation according to a set of model details, e.g. temperature
 values. To do so, the caller provides either a pointer to a set of model details
 to be used for rescaling, or NULL if global default setting should be used.

 @see vrna_exp_params_reset(), vrna_params_subs()

 @param  fc    The fold compound data structure
 @param  md    A pointer to the new model details (or NULL for reset to defaults)
### Prototype
```c
void vrna_params_reset(vrna_fold_compound_t *fc, vrna_md_t *md);
```
"""
function vrna_params_reset(fc, md)
    ccall((:vrna_params_reset, libRNA), Cvoid, (Ptr{vrna_fold_compound_t}, Ptr{vrna_md_t}), fc, md)
end

"""
    vrna_exp_params_reset(fc, md)

 @brief  Reset Boltzmann factors for partition function computations
         within a #vrna_fold_compound_t according to provided, or
         default model details

 This function allows one to rescale Boltzmann factors for subsequent partition
 function computations according to a set of model details, e.g. temperature
 values. To do so, the caller provides either a pointer to a set of model details
 to be used for rescaling, or NULL if global default setting should be used.

 @see vrna_params_reset(), vrna_exp_params_subst(), vrna_exp_params_rescale()

 @param  fc    The fold compound data structure
 @param  md    A pointer to the new model details (or NULL for reset to defaults)
### Prototype
```c
void vrna_exp_params_reset(vrna_fold_compound_t *fc, vrna_md_t *md);
```
"""
function vrna_exp_params_reset(fc, md)
    ccall((:vrna_exp_params_reset, libRNA), Cvoid, (Ptr{vrna_fold_compound_t}, Ptr{vrna_md_t}), fc, md)
end

"""
    vrna_params_prepare(fc, options)


### Prototype
```c
void vrna_params_prepare(vrna_fold_compound_t *fc, unsigned int options);
```
"""
function vrna_params_prepare(fc, options)
    ccall((:vrna_params_prepare, libRNA), Cvoid, (Ptr{vrna_fold_compound_t}, Cuint), fc, options)
end

"""
 @brief Old typename of #vrna_param_s
 @deprecated Use #vrna_param_t instead!
"""
const paramT = vrna_param_s

"""
 @brief Old typename of #vrna_exp_param_s
 @deprecated Use #vrna_exp_param_t instead!
"""
const pf_paramT = vrna_exp_param_s

"""
    get_parameter_copy(par)


### Prototype
```c
;
```
"""
function get_parameter_copy(par)
    ccall((:get_parameter_copy, libRNA), Ptr{vrna_param_t}, (Ptr{vrna_param_t},), par)
end

"""
    get_scaled_pf_parameters()


### Prototype
```c
;
```
"""
function get_scaled_pf_parameters()
    ccall((:get_scaled_pf_parameters, libRNA), Ptr{vrna_exp_param_t}, ())
end

"""
    get_boltzmann_factors(temperature, betaScale, md, pf_scale)


### Prototype
```c
;
```
"""
function get_boltzmann_factors(temperature, betaScale, md, pf_scale)
    ccall((:get_boltzmann_factors, libRNA), Ptr{vrna_exp_param_t}, (Cdouble, Cdouble, vrna_md_t, Cdouble), temperature, betaScale, md, pf_scale)
end

"""
    get_boltzmann_factor_copy(parameters)


### Prototype
```c
;
```
"""
function get_boltzmann_factor_copy(parameters)
    ccall((:get_boltzmann_factor_copy, libRNA), Ptr{vrna_exp_param_t}, (Ptr{vrna_exp_param_t},), parameters)
end

"""
    get_scaled_alipf_parameters(n_seq)


### Prototype
```c
;
```
"""
function get_scaled_alipf_parameters(n_seq)
    ccall((:get_scaled_alipf_parameters, libRNA), Ptr{vrna_exp_param_t}, (Cuint,), n_seq)
end

"""
    get_boltzmann_factors_ali(n_seq, temperature, betaScale, md, pf_scale)


### Prototype
```c
;
```
"""
function get_boltzmann_factors_ali(n_seq, temperature, betaScale, md, pf_scale)
    ccall((:get_boltzmann_factors_ali, libRNA), Ptr{vrna_exp_param_t}, (Cuint, Cdouble, Cdouble, vrna_md_t, Cdouble), n_seq, temperature, betaScale, md, pf_scale)
end

"""
    scale_parameters()


### Prototype
```c
;
```
"""
function scale_parameters()
    ccall((:scale_parameters, libRNA), Ptr{vrna_param_t}, ())
end

"""
    get_scaled_parameters(temperature, md)


### Prototype
```c
;
```
"""
function get_scaled_parameters(temperature, md)
    ccall((:get_scaled_parameters, libRNA), Ptr{vrna_param_t}, (Cdouble, vrna_md_t), temperature, md)
end

"""
    copy_parameters()


### Prototype
```c
;
```
"""
function copy_parameters()
    ccall((:copy_parameters, libRNA), Ptr{vrna_param_t}, ())
end

"""
    set_parameters(dest)


### Prototype
```c
;
```
"""
function set_parameters(dest)
    ccall((:set_parameters, libRNA), Ptr{vrna_param_t}, (Ptr{vrna_param_t},), dest)
end

"""
    scale_pf_parameters()


### Prototype
```c
;
```
"""
function scale_pf_parameters()
    ccall((:scale_pf_parameters, libRNA), Ptr{vrna_exp_param_t}, ())
end

"""
    copy_pf_param()


### Prototype
```c
;
```
"""
function copy_pf_param()
    ccall((:copy_pf_param, libRNA), Ptr{vrna_exp_param_t}, ())
end

"""
    set_pf_param(dest)


### Prototype
```c
;
```
"""
function set_pf_param(dest)
    ccall((:set_pf_param, libRNA), Ptr{vrna_exp_param_t}, (Ptr{vrna_param_t},), dest)
end

"""
    vrna_sequence(string, options)


### Prototype
```c
vrna_seq_t * vrna_sequence(const char *string, unsigned int options);
```
"""
function vrna_sequence(string, options)
    ccall((:vrna_sequence, libRNA), Ptr{vrna_seq_t}, (Ptr{Cchar}, Cuint), string, options)
end

"""
    vrna_sequence_add(fc, string, options)


### Prototype
```c
int vrna_sequence_add(vrna_fold_compound_t *fc, const char *string, unsigned int options);
```
"""
function vrna_sequence_add(fc, string, options)
    ccall((:vrna_sequence_add, libRNA), Cint, (Ptr{vrna_fold_compound_t}, Ptr{Cchar}, Cuint), fc, string, options)
end

"""
    vrna_sequence_remove(fc, i)


### Prototype
```c
int vrna_sequence_remove(vrna_fold_compound_t *fc, unsigned int i);
```
"""
function vrna_sequence_remove(fc, i)
    ccall((:vrna_sequence_remove, libRNA), Cint, (Ptr{vrna_fold_compound_t}, Cuint), fc, i)
end

"""
    vrna_sequence_remove_all(fc)


### Prototype
```c
void vrna_sequence_remove_all(vrna_fold_compound_t *fc);
```
"""
function vrna_sequence_remove_all(fc)
    ccall((:vrna_sequence_remove_all, libRNA), Cvoid, (Ptr{vrna_fold_compound_t},), fc)
end

"""
    vrna_sequence_prepare(fc)


### Prototype
```c
void vrna_sequence_prepare(vrna_fold_compound_t *fc);
```
"""
function vrna_sequence_prepare(fc)
    ccall((:vrna_sequence_prepare, libRNA), Cvoid, (Ptr{vrna_fold_compound_t},), fc)
end

"""
    vrna_sequence_order_update(fc, order)


### Prototype
```c
int vrna_sequence_order_update(vrna_fold_compound_t *fc, const unsigned int *order);
```
"""
function vrna_sequence_order_update(fc, order)
    ccall((:vrna_sequence_order_update, libRNA), Cint, (Ptr{vrna_fold_compound_t}, Ptr{Cuint}), fc, order)
end

"""
    vrna_msa_add(fc, alignment, names, orientation, start, genome_size, options)


### Prototype
```c
int vrna_msa_add( vrna_fold_compound_t *fc, const char **alignment, const char **names, const unsigned char *orientation, const unsigned long long *start, const unsigned long long *genome_size, unsigned int options);
```
"""
function vrna_msa_add(fc, alignment, names, orientation, start, genome_size, options)
    ccall((:vrna_msa_add, libRNA), Cint, (Ptr{vrna_fold_compound_t}, Ptr{Ptr{Cchar}}, Ptr{Ptr{Cchar}}, Ptr{Cuchar}, Ptr{Culonglong}, Ptr{Culonglong}, Cuint), fc, alignment, names, orientation, start, genome_size, options)
end

"""
    vrna_mx_add(fc, type, options)

 @brief  Add Dynamic Programming (DP) matrices (allocate memory)

 This function adds DP matrices of a specific type to the provided
 #vrna_fold_compound_t, such that successive DP recursion can be applied.
 The function caller has to specify which type of DP matrix is requested,
 see #vrna_mx_type_e, and what kind of recursive algorithm will be applied
 later on, using the parameters type, and options, respectively. For the
 latter, Minimum free energy (MFE), and Partition function (PF)
 computations are distinguished. A third option that may be passed
 is #VRNA_OPTION_HYBRID, indicating that auxiliary DP arrays are
 required for RNA-RNA interaction prediction.

 @note Usually, there is no need to call this function, since
       the constructors of #vrna_fold_compound_t are handling all the DP
       matrix memory allocation.

 @see  vrna_mx_mfe_add(), vrna_mx_pf_add(), vrna_fold_compound(),
       vrna_fold_compound_comparative(), vrna_fold_compound_free(),
       vrna_mx_pf_free(), vrna_mx_mfe_free(), #vrna_mx_type_e,
       #VRNA_OPTION_MFE, #VRNA_OPTION_PF, #VRNA_OPTION_HYBRID, #VRNA_OPTION_EVAL_ONLY

 @param  fc      The #vrna_fold_compound_t that holds pointers to the DP matrices
 @param  type    The type of DP matrices requested
 @param  options Option flags that specify the kind of DP matrices, such
                 as MFE or PF arrays, and auxiliary requirements
 @returns        1 if DP matrices were properly allocated and attached,
                 0 otherwise
### Prototype
```c
int vrna_mx_add(vrna_fold_compound_t *fc, vrna_mx_type_e type, unsigned int options);
```
"""
function vrna_mx_add(fc, type, options)
    ccall((:vrna_mx_add, libRNA), Cint, (Ptr{vrna_fold_compound_t}, vrna_mx_type_e, Cuint), fc, type, options)
end

"""
    vrna_mx_mfe_add(fc, mx_type, options)


### Prototype
```c
int vrna_mx_mfe_add(vrna_fold_compound_t *fc, vrna_mx_type_e mx_type, unsigned int options);
```
"""
function vrna_mx_mfe_add(fc, mx_type, options)
    ccall((:vrna_mx_mfe_add, libRNA), Cint, (Ptr{vrna_fold_compound_t}, vrna_mx_type_e, Cuint), fc, mx_type, options)
end

"""
    vrna_mx_pf_add(fc, mx_type, options)


### Prototype
```c
int vrna_mx_pf_add(vrna_fold_compound_t *fc, vrna_mx_type_e mx_type, unsigned int options);
```
"""
function vrna_mx_pf_add(fc, mx_type, options)
    ccall((:vrna_mx_pf_add, libRNA), Cint, (Ptr{vrna_fold_compound_t}, vrna_mx_type_e, Cuint), fc, mx_type, options)
end

"""
    vrna_mx_prepare(fc, options)


### Prototype
```c
int vrna_mx_prepare(vrna_fold_compound_t *fc, unsigned int options);
```
"""
function vrna_mx_prepare(fc, options)
    ccall((:vrna_mx_prepare, libRNA), Cint, (Ptr{vrna_fold_compound_t}, Cuint), fc, options)
end

"""
    vrna_mx_mfe_free(fc)

 @brief  Free memory occupied by the Minimum Free Energy (MFE) Dynamic Programming (DP) matrices

 @see vrna_fold_compound(), vrna_fold_compound_comparative(), vrna_fold_compound_free(), vrna_mx_pf_free()

 @param  fc  The #vrna_fold_compound_t storing the MFE DP matrices that are to be erased from memory
### Prototype
```c
void vrna_mx_mfe_free(vrna_fold_compound_t *fc);
```
"""
function vrna_mx_mfe_free(fc)
    ccall((:vrna_mx_mfe_free, libRNA), Cvoid, (Ptr{vrna_fold_compound_t},), fc)
end

"""
    vrna_mx_pf_free(fc)

 @brief  Free memory occupied by the Partition Function (PF) Dynamic Programming (DP) matrices

 @see vrna_fold_compound(), vrna_fold_compound_comparative(), vrna_fold_compound_free(), vrna_mx_mfe_free()

 @param  fc  The #vrna_fold_compound_t storing the PF DP matrices that are to be erased from memory
### Prototype
```c
void vrna_mx_pf_free(vrna_fold_compound_t *fc);
```
"""
function vrna_mx_pf_free(fc)
    ccall((:vrna_mx_pf_free, libRNA), Cvoid, (Ptr{vrna_fold_compound_t},), fc)
end

"""
    vrna_hc_up_s

 @brief  A single hard constraint for a single nucleotide

 @ingroup hard_constraints
"""
struct vrna_hc_up_s
    position::Cint
    strand::Cint
    options::Cuchar
end

"""
 @brief Typename for the single nucleotide hard constraint data structure #vrna_hc_up_s
 @ingroup  hard_constraints
"""
const vrna_hc_up_t = vrna_hc_up_s

"""
    vrna_constraints_add(fc, constraint, options)

 @brief  Add constraints to a #vrna_fold_compound_t data structure

 Use this function to add/update the hard/soft constraints
 The function allows for passing a string 'constraint' that can either be a
 filename that points to a constraints definition file or it may be a
 pseudo dot-bracket notation indicating hard constraints. For the latter, the
 user has to pass the #VRNA_CONSTRAINT_DB option. Also, the
 user has to specify, which characters are allowed to be interpreted as
 constraints by passing the corresponding options via the third parameter.

 @ingroup  constraints

 The following is an example for adding hard constraints given in
 pseudo dot-bracket notation. Here, @p fc is the #vrna_fold_compound_t object,
 @p structure is a char array with the hard constraint in dot-bracket notation,
 and @p enforceConstraints is a flag indicating whether or not constraints for
 base pairs should be enforced instead of just doing a removal of base pair that
 conflict with the constraint.

 @snippet RNAfold.c Adding hard constraints from pseudo dot-bracket

 In constrat to the above, constraints may also be read from file:

 @snippet RNAfold.c Adding hard constraints from file

 @see  vrna_hc_add_from_db(), vrna_hc_add_up(), vrna_hc_add_up_batch()
       vrna_hc_add_bp_unspecific(), vrna_hc_add_bp(),
       vrna_hc_init(), vrna_sc_set_up(), vrna_sc_set_bp(),
       vrna_sc_add_SHAPE_deigan(),  vrna_sc_add_SHAPE_zarringhalam(),
       vrna_hc_free(), vrna_sc_free(),
       #VRNA_CONSTRAINT_DB, #VRNA_CONSTRAINT_DB_DEFAULT, #VRNA_CONSTRAINT_DB_PIPE,
       #VRNA_CONSTRAINT_DB_DOT, #VRNA_CONSTRAINT_DB_X, #VRNA_CONSTRAINT_DB_ANG_BRACK,
       #VRNA_CONSTRAINT_DB_RND_BRACK, #VRNA_CONSTRAINT_DB_INTRAMOL,
       #VRNA_CONSTRAINT_DB_INTERMOL, #VRNA_CONSTRAINT_DB_GQUAD

 @param  fc            The fold compound
 @param  constraint    A string with either the filename of the constraint definitions
                       or a pseudo dot-bracket notation of the hard constraint. May be NULL.
 @param  options       The option flags
### Prototype
```c
void vrna_constraints_add(vrna_fold_compound_t *fc, const char *constraint, unsigned int options);
```
"""
function vrna_constraints_add(fc, constraint, options)
    ccall((:vrna_constraints_add, libRNA), Cvoid, (Ptr{vrna_fold_compound_t}, Ptr{Cchar}, Cuint), fc, constraint, options)
end

# DEPRECATED
const vrna_callback_hc_evaluate = Cvoid

"""
    vrna_message_constraint_options(option)

 @brief Print a help message for pseudo dot-bracket structure constraint characters to stdout.
 (constraint support is specified by option parameter)

 Currently available options are:\\n
 #VRNA_CONSTRAINT_DB_PIPE (paired with another base)\\n
 #VRNA_CONSTRAINT_DB_DOT (no constraint at all)\\n
 #VRNA_CONSTRAINT_DB_X (base must not pair)\\n
 #VRNA_CONSTRAINT_DB_ANG_BRACK (paired downstream/upstream)\\n
 #VRNA_CONSTRAINT_DB_RND_BRACK (base i pairs base j)\\n

 pass a collection of options as one value like this:
 @verbatim vrna_message_constraints(option_1 | option_2 | option_n) @endverbatim

 @ingroup  constraints

 @see  vrna_message_constraint_options_all(), vrna_constraints_add(), #VRNA_CONSTRAINT_DB,
       #VRNA_CONSTRAINT_DB_PIPE, #VRNA_CONSTRAINT_DB_DOT, #VRNA_CONSTRAINT_DB_X, #VRNA_CONSTRAINT_DB_ANG_BRACK,
       #VRNA_CONSTRAINT_DB_RND_BRACK, #VRNA_CONSTRAINT_DB_INTERMOL, #VRNA_CONSTRAINT_DB_INTRAMOL

 @param option Option switch that tells which constraint help will be printed
### Prototype
```c
void vrna_message_constraint_options(unsigned int option);
```
"""
function vrna_message_constraint_options(option)
    ccall((:vrna_message_constraint_options, libRNA), Cvoid, (Cuint,), option)
end

"""
    vrna_message_constraint_options_all()

 @brief Print structure constraint characters to stdout
 (full constraint support)

 @ingroup  constraints

 @see  vrna_message_constraint_options(), vrna_constraints_add(), #VRNA_CONSTRAINT_DB,
       #VRNA_CONSTRAINT_DB_PIPE, #VRNA_CONSTRAINT_DB_DOT, #VRNA_CONSTRAINT_DB_X, #VRNA_CONSTRAINT_DB_ANG_BRACK,
       #VRNA_CONSTRAINT_DB_RND_BRACK, #VRNA_CONSTRAINT_DB_INTERMOL, #VRNA_CONSTRAINT_DB_INTRAMOL
### Prototype
```c
void vrna_message_constraint_options_all(void);
```
"""
function vrna_message_constraint_options_all()
    ccall((:vrna_message_constraint_options_all, libRNA), Cvoid, ())
end

"""
    vrna_hc_init(fc)

 @brief  Initialize/Reset hard constraints to default values

 This function resets the hard constraints to their default values, i.e.
 all positions may be unpaired in all contexts, and base pairs are
 allowed in all contexts, if they resemble canonical pairs.
 Previously set hard constraints will be removed before initialization.

 @ingroup  hard_constraints

 @see  vrna_hc_add_bp(), vrna_hc_add_bp_nonspecific(), vrna_hc_add_up()

 @param  fc  The fold compound
### Prototype
```c
void vrna_hc_init(vrna_fold_compound_t *fc);
```
"""
function vrna_hc_init(fc)
    ccall((:vrna_hc_init, libRNA), Cvoid, (Ptr{vrna_fold_compound_t},), fc)
end

"""
    vrna_hc_init_window(fc)


### Prototype
```c
void vrna_hc_init_window(vrna_fold_compound_t *fc);
```
"""
function vrna_hc_init_window(fc)
    ccall((:vrna_hc_init_window, libRNA), Cvoid, (Ptr{vrna_fold_compound_t},), fc)
end

"""
    vrna_hc_prepare(fc, options)


### Prototype
```c
int vrna_hc_prepare(vrna_fold_compound_t *fc, unsigned int options);
```
"""
function vrna_hc_prepare(fc, options)
    ccall((:vrna_hc_prepare, libRNA), Cint, (Ptr{vrna_fold_compound_t}, Cuint), fc, options)
end

"""
    vrna_hc_update(fc, i, options)


### Prototype
```c
void vrna_hc_update(vrna_fold_compound_t *fc, unsigned int i, unsigned int options);
```
"""
function vrna_hc_update(fc, i, options)
    ccall((:vrna_hc_update, libRNA), Cvoid, (Ptr{vrna_fold_compound_t}, Cuint, Cuint), fc, i, options)
end

"""
    vrna_hc_add_up(fc, i, option)

 @brief  Make a certain nucleotide unpaired

 @ingroup  hard_constraints

 @see  vrna_hc_add_bp(), vrna_hc_add_bp_nonspecific(), vrna_hc_init(),
       #VRNA_CONSTRAINT_CONTEXT_EXT_LOOP, #VRNA_CONSTRAINT_CONTEXT_HP_LOOP,
       #VRNA_CONSTRAINT_CONTEXT_INT_LOOP, #VRNA_CONSTRAINT_CONTEXT_MB_LOOP,
       #VRNA_CONSTRAINT_CONTEXT_ALL_LOOPS

 @param  fc      The #vrna_fold_compound_t the hard constraints are associated with
 @param  i       The position that needs to stay unpaired (1-based)
 @param  option  The options flag indicating how/where to store the hard constraints
### Prototype
```c
void vrna_hc_add_up(vrna_fold_compound_t *fc, int i, unsigned char option);
```
"""
function vrna_hc_add_up(fc, i, option)
    ccall((:vrna_hc_add_up, libRNA), Cvoid, (Ptr{vrna_fold_compound_t}, Cint, Cuchar), fc, i, option)
end

"""
    vrna_hc_add_up_strand(fc, i, strand, option)


### Prototype
```c
int vrna_hc_add_up_strand(vrna_fold_compound_t *fc, unsigned int i, unsigned int strand, unsigned char option);
```
"""
function vrna_hc_add_up_strand(fc, i, strand, option)
    ccall((:vrna_hc_add_up_strand, libRNA), Cint, (Ptr{vrna_fold_compound_t}, Cuint, Cuint, Cuchar), fc, i, strand, option)
end

"""
    vrna_hc_add_up_batch(fc, constraints)

 @brief Apply a list of hard constraints for single nucleotides

 @ingroup  hard_constraints

 @param  fc          The #vrna_fold_compound_t the hard constraints are associated with
 @param  constraints The list off constraints to apply, last entry must have position
                     attribute set to 0
### Prototype
```c
int vrna_hc_add_up_batch(vrna_fold_compound_t *fc, vrna_hc_up_t *constraints);
```
"""
function vrna_hc_add_up_batch(fc, constraints)
    ccall((:vrna_hc_add_up_batch, libRNA), Cint, (Ptr{vrna_fold_compound_t}, Ptr{vrna_hc_up_t}), fc, constraints)
end

"""
    vrna_hc_add_up_strand_batch(fc, constraints)


### Prototype
```c
int vrna_hc_add_up_strand_batch(vrna_fold_compound_t *fc, vrna_hc_up_t *constraints);
```
"""
function vrna_hc_add_up_strand_batch(fc, constraints)
    ccall((:vrna_hc_add_up_strand_batch, libRNA), Cint, (Ptr{vrna_fold_compound_t}, Ptr{vrna_hc_up_t}), fc, constraints)
end

"""
    vrna_hc_add_bp(fc, i, j, option)

 @brief  Favorize/Enforce  a certain base pair (i,j)

 @ingroup  hard_constraints

 @see  vrna_hc_add_bp_nonspecific(), vrna_hc_add_up(), vrna_hc_init(),
       #VRNA_CONSTRAINT_CONTEXT_EXT_LOOP, #VRNA_CONSTRAINT_CONTEXT_HP_LOOP,
       #VRNA_CONSTRAINT_CONTEXT_INT_LOOP, #VRNA_CONSTRAINT_CONTEXT_INT_LOOP_ENC,
       #VRNA_CONSTRAINT_CONTEXT_MB_LOOP, #VRNA_CONSTRAINT_CONTEXT_MB_LOOP_ENC,
       #VRNA_CONSTRAINT_CONTEXT_ENFORCE, #VRNA_CONSTRAINT_CONTEXT_ALL_LOOPS

 @param  fc      The #vrna_fold_compound_t the hard constraints are associated with
 @param  i       The 5' located nucleotide position of the base pair (1-based)
 @param  j       The 3' located nucleotide position of the base pair (1-based)
 @param  option  The options flag indicating how/where to store the hard constraints
### Prototype
```c
int vrna_hc_add_bp(vrna_fold_compound_t *fc, int i, int j, unsigned char option);
```
"""
function vrna_hc_add_bp(fc, i, j, option)
    ccall((:vrna_hc_add_bp, libRNA), Cint, (Ptr{vrna_fold_compound_t}, Cint, Cint, Cuchar), fc, i, j, option)
end

"""
    vrna_hc_add_bp_strand(fc, i, strand_i, j, strand_j, option)


### Prototype
```c
int vrna_hc_add_bp_strand(vrna_fold_compound_t *fc, unsigned int i, unsigned int strand_i, unsigned int j, unsigned int strand_j, unsigned char option);
```
"""
function vrna_hc_add_bp_strand(fc, i, strand_i, j, strand_j, option)
    ccall((:vrna_hc_add_bp_strand, libRNA), Cint, (Ptr{vrna_fold_compound_t}, Cuint, Cuint, Cuint, Cuint, Cuchar), fc, i, strand_i, j, strand_j, option)
end

"""
    vrna_hc_add_bp_nonspecific(fc, i, d, option)

 @brief  Enforce a nucleotide to be paired (upstream/downstream)

 @ingroup  hard_constraints

 @see  vrna_hc_add_bp(), vrna_hc_add_up(), vrna_hc_init(),
       #VRNA_CONSTRAINT_CONTEXT_EXT_LOOP, #VRNA_CONSTRAINT_CONTEXT_HP_LOOP,
       #VRNA_CONSTRAINT_CONTEXT_INT_LOOP, #VRNA_CONSTRAINT_CONTEXT_INT_LOOP_ENC,
       #VRNA_CONSTRAINT_CONTEXT_MB_LOOP, #VRNA_CONSTRAINT_CONTEXT_MB_LOOP_ENC,
       #VRNA_CONSTRAINT_CONTEXT_ALL_LOOPS

 @param  fc      The #vrna_fold_compound_t the hard constraints are associated with
 @param  i       The position that needs to stay unpaired (1-based)
 @param  d       The direction of base pairing (@f\$ d < 0 @f\$: pairs upstream,
                 @f\$ d > 0 @f\$: pairs downstream, @f\$ d == 0 @f\$: no direction)
 @param  option  The options flag indicating in which loop type context the pairs may appear
### Prototype
```c
void vrna_hc_add_bp_nonspecific(vrna_fold_compound_t *fc, int i, int d, unsigned char option);
```
"""
function vrna_hc_add_bp_nonspecific(fc, i, d, option)
    ccall((:vrna_hc_add_bp_nonspecific, libRNA), Cvoid, (Ptr{vrna_fold_compound_t}, Cint, Cint, Cuchar), fc, i, d, option)
end

"""
    vrna_hc_free(hc)

 @brief  Free the memory allocated by a #vrna_hc_t data structure

 Use this function to free all memory that was allocated for a data structure
 of type #vrna_hc_t .

 @see get_hard_constraints(), #vrna_hc_t

 @ingroup  hard_constraints

### Prototype
```c
void vrna_hc_free(vrna_hc_t *hc);
```
"""
function vrna_hc_free(hc)
    ccall((:vrna_hc_free, libRNA), Cvoid, (Ptr{vrna_hc_t},), hc)
end

"""
    vrna_hc_add_f(fc, f)

 @brief  Add a function pointer pointer for the generic hard constraint
         feature
### Prototype
```c
void vrna_hc_add_f(vrna_fold_compound_t *fc, vrna_hc_eval_f f);
```
"""
function vrna_hc_add_f(fc, f)
    ccall((:vrna_hc_add_f, libRNA), Cvoid, (Ptr{vrna_fold_compound_t}, vrna_hc_eval_f), fc, f)
end

"""
    vrna_hc_add_data(fc, data, f)

 @brief Add an auxiliary data structure for the generic hard constraints callback function

 @ingroup generic_hc

 @see vrna_hc_add_f()

 @param  fc        The fold compound the generic hard constraint function should be bound to
 @param  data      A pointer to the data structure that holds required data for function 'f'
 @param  f         A pointer to a function that free's the memory occupied by @p data (Maybe @p NULL)
### Prototype
```c
void vrna_hc_add_data(vrna_fold_compound_t *fc, void *data, vrna_auxdata_free_f f);
```
"""
function vrna_hc_add_data(fc, data, f)
    ccall((:vrna_hc_add_data, libRNA), Cvoid, (Ptr{vrna_fold_compound_t}, Ptr{Cvoid}, vrna_auxdata_free_f), fc, data, f)
end

"""
    vrna_hc_add_from_db(fc, constraint, options)

 @brief Add hard constraints from pseudo dot-bracket notation

 This function allows one to apply hard constraints from a pseudo dot-bracket
 notation. The @p options parameter controls, which characters are recognized
 by the parser. Use the #VRNA_CONSTRAINT_DB_DEFAULT convenience macro, if you
 want to allow all known characters

 @ingroup  hard_constraints

 @see  #VRNA_CONSTRAINT_DB_PIPE, #VRNA_CONSTRAINT_DB_DOT, #VRNA_CONSTRAINT_DB_X,
       #VRNA_CONSTRAINT_DB_ANG_BRACK, #VRNA_CONSTRAINT_DB_RND_BRACK, #VRNA_CONSTRAINT_DB_INTRAMOL,
       #VRNA_CONSTRAINT_DB_INTERMOL, #VRNA_CONSTRAINT_DB_GQUAD

 @param  fc            The fold compound
 @param  constraint    A pseudo dot-bracket notation of the hard constraint.
 @param  options       The option flags
### Prototype
```c
int vrna_hc_add_from_db(vrna_fold_compound_t *fc, const char *constraint, unsigned int options);
```
"""
function vrna_hc_add_from_db(fc, constraint, options)
    ccall((:vrna_hc_add_from_db, libRNA), Cint, (Ptr{vrna_fold_compound_t}, Ptr{Cchar}, Cuint), fc, constraint, options)
end

"""
    print_tty_constraint(option)


### Prototype
```c
;
```
"""
function print_tty_constraint(option)
    ccall((:print_tty_constraint, libRNA), Cvoid, (Cuint,), option)
end

"""
    print_tty_constraint_full()


### Prototype
```c
;
```
"""
function print_tty_constraint_full()
    ccall((:print_tty_constraint_full, libRNA), Cvoid, ())
end

"""
    constrain_ptypes(constraint, length, ptype, BP, min_loop_size, idx_type)


### Prototype
```c
;
```
"""
function constrain_ptypes(constraint, length, ptype, BP, min_loop_size, idx_type)
    ccall((:constrain_ptypes, libRNA), Cvoid, (Ptr{Cchar}, Cuint, Ptr{Cchar}, Ptr{Cint}, Cint, Cuint), constraint, length, ptype, BP, min_loop_size, idx_type)
end

# DEPRECATED
const vrna_callback_sc_energy = Cvoid

# typedef int ( * vrna_sc_direct_f ) ( vrna_fold_compound_t * fc , int i , int j , int k , int l , void * data )
const vrna_sc_direct_f = Ptr{Cvoid}

# DEPRECATED
const vrna_callback_sc_exp_energy = Cvoid

# typedef FLT_OR_DBL ( * vrna_sc_exp_direct_f ) ( vrna_fold_compound_t * fc , int i , int j , int k , int l , void * data )
const vrna_sc_exp_direct_f = Ptr{Cvoid}

# DEPRECATED
const vrna_callback_sc_backtrack = Cvoid

"""
    vrna_sc_init(fc)

 @brief Initialize an empty soft constraints data structure within a #vrna_fold_compound_t

 This function adds a proper soft constraints data structure
 to the #vrna_fold_compound_t data structure.
 If soft constraints already exist within the fold compound, they are removed.

 \\note Accepts vrna_fold_compound_t of type #VRNA_FC_TYPE_SINGLE and #VRNA_FC_TYPE_COMPARATIVE

 @ingroup  soft_constraints

 @see  vrna_sc_set_bp(), vrna_sc_set_up(), vrna_sc_add_SHAPE_deigan(),
       vrna_sc_add_SHAPE_zarringhalam(), vrna_sc_remove(), vrna_sc_add_f(),
       vrna_sc_add_exp_f(), vrna_sc_add_pre(), vrna_sc_add_post()

 @param  fc  The #vrna_fold_compound_t where an empty soft constraint feature is to be added to
### Prototype
```c
void vrna_sc_init(vrna_fold_compound_t *fc);
```
"""
function vrna_sc_init(fc)
    ccall((:vrna_sc_init, libRNA), Cvoid, (Ptr{vrna_fold_compound_t},), fc)
end

"""
    vrna_sc_prepare(fc, options)


### Prototype
```c
void vrna_sc_prepare(vrna_fold_compound_t *fc, unsigned int options);
```
"""
function vrna_sc_prepare(fc, options)
    ccall((:vrna_sc_prepare, libRNA), Cvoid, (Ptr{vrna_fold_compound_t}, Cuint), fc, options)
end

"""
    vrna_sc_update(fc, i, options)


### Prototype
```c
int vrna_sc_update(vrna_fold_compound_t *fc, unsigned int i, unsigned int options);
```
"""
function vrna_sc_update(fc, i, options)
    ccall((:vrna_sc_update, libRNA), Cint, (Ptr{vrna_fold_compound_t}, Cuint, Cuint), fc, i, options)
end

"""
    vrna_sc_set_bp(fc, constraints, options)

 @brief  Set soft constraints for paired nucleotides

 @note     This function replaces any pre-exisitng soft constraints with the ones supplied
           in @p constraints.

 @ingroup  soft_constraints

 @see      vrna_sc_add_bp(), vrna_sc_set_up(), vrna_sc_add_up()

 @param  fc          The #vrna_fold_compound_t the soft constraints are associated with
 @param  constraints A two-dimensional array of pseudo free energies in @f\$ kcal / mol @f\$
 @param  options     The options flag indicating how/where to store the soft constraints
 @return             Non-zero on successful application of the constraint, 0 otherwise.
### Prototype
```c
int vrna_sc_set_bp(vrna_fold_compound_t *fc, const FLT_OR_DBL **constraints, unsigned int options);
```
"""
function vrna_sc_set_bp(fc, constraints, options)
    ccall((:vrna_sc_set_bp, libRNA), Cint, (Ptr{vrna_fold_compound_t}, Ptr{Ptr{FLT_OR_DBL}}, Cuint), fc, constraints, options)
end

"""
    vrna_sc_add_bp(fc, i, j, energy, options)

 @brief  Add soft constraints for paired nucleotides

 @ingroup  soft_constraints

 @see      vrna_sc_set_bp(), vrna_sc_set_up(), vrna_sc_add_up()

 @param  fc          The #vrna_fold_compound_t the soft constraints are associated with
 @param  i           The 5' position of the base pair the soft constraint is added for
 @param  j           The 3' position of the base pair the soft constraint is added for
 @param  energy      The free energy (soft-constraint) in @f\$ kcal / mol @f\$
 @param  options     The options flag indicating how/where to store the soft constraints
 @return             Non-zero on successful application of the constraint, 0 otherwise.
### Prototype
```c
int vrna_sc_add_bp(vrna_fold_compound_t *fc, int i, int j, FLT_OR_DBL energy, unsigned int options);
```
"""
function vrna_sc_add_bp(fc, i, j, energy, options)
    ccall((:vrna_sc_add_bp, libRNA), Cint, (Ptr{vrna_fold_compound_t}, Cint, Cint, FLT_OR_DBL, Cuint), fc, i, j, energy, options)
end

"""
    vrna_sc_set_up(fc, constraints, options)

 @brief  Set soft constraints for unpaired nucleotides

 @note     This function replaces any pre-exisitng soft constraints with the ones supplied
           in @p constraints.

 @ingroup  soft_constraints

 @see      vrna_sc_add_up(), vrna_sc_set_bp(), vrna_sc_add_bp()

 @param  fc          The #vrna_fold_compound_t the soft constraints are associated with
 @param  constraints A vector of pseudo free energies in @f\$ kcal / mol @f\$
 @param  options     The options flag indicating how/where to store the soft constraints
 @return             Non-zero on successful application of the constraint, 0 otherwise.
### Prototype
```c
int vrna_sc_set_up(vrna_fold_compound_t *fc, const FLT_OR_DBL *constraints, unsigned int options);
```
"""
function vrna_sc_set_up(fc, constraints, options)
    ccall((:vrna_sc_set_up, libRNA), Cint, (Ptr{vrna_fold_compound_t}, Ptr{FLT_OR_DBL}, Cuint), fc, constraints, options)
end

"""
    vrna_sc_add_up(fc, i, energy, options)

 @brief  Add soft constraints for unpaired nucleotides

 @ingroup  soft_constraints

 @see      vrna_sc_set_up(), vrna_sc_add_bp(), vrna_sc_set_bp()

 @param  fc          The #vrna_fold_compound_t the soft constraints are associated with
 @param  i           The nucleotide position the soft constraint is added for
 @param  energy      The free energy (soft-constraint) in @f\$ kcal / mol @f\$
 @param  options     The options flag indicating how/where to store the soft constraints
 @return             Non-zero on successful application of the constraint, 0 otherwise.
### Prototype
```c
int vrna_sc_add_up(vrna_fold_compound_t *fc, int i, FLT_OR_DBL energy, unsigned int options);
```
"""
function vrna_sc_add_up(fc, i, energy, options)
    ccall((:vrna_sc_add_up, libRNA), Cint, (Ptr{vrna_fold_compound_t}, Cint, FLT_OR_DBL, Cuint), fc, i, energy, options)
end

"""
    vrna_sc_set_stack(fc, constraints, options)


### Prototype
```c
int vrna_sc_set_stack(vrna_fold_compound_t *fc, const FLT_OR_DBL *constraints, unsigned int options);
```
"""
function vrna_sc_set_stack(fc, constraints, options)
    ccall((:vrna_sc_set_stack, libRNA), Cint, (Ptr{vrna_fold_compound_t}, Ptr{FLT_OR_DBL}, Cuint), fc, constraints, options)
end

"""
    vrna_sc_set_stack_comparative(fc, constraints, options)


### Prototype
```c
int vrna_sc_set_stack_comparative(vrna_fold_compound_t *fc, const FLT_OR_DBL **constraints, unsigned int options);
```
"""
function vrna_sc_set_stack_comparative(fc, constraints, options)
    ccall((:vrna_sc_set_stack_comparative, libRNA), Cint, (Ptr{vrna_fold_compound_t}, Ptr{Ptr{FLT_OR_DBL}}, Cuint), fc, constraints, options)
end

"""
    vrna_sc_add_stack(fc, i, energy, options)


### Prototype
```c
int vrna_sc_add_stack(vrna_fold_compound_t *fc, int i, FLT_OR_DBL energy, unsigned int options);
```
"""
function vrna_sc_add_stack(fc, i, energy, options)
    ccall((:vrna_sc_add_stack, libRNA), Cint, (Ptr{vrna_fold_compound_t}, Cint, FLT_OR_DBL, Cuint), fc, i, energy, options)
end

"""
    vrna_sc_add_stack_comparative(fc, i, energies, options)


### Prototype
```c
int vrna_sc_add_stack_comparative(vrna_fold_compound_t *fc, int i, const FLT_OR_DBL *energies, unsigned int options);
```
"""
function vrna_sc_add_stack_comparative(fc, i, energies, options)
    ccall((:vrna_sc_add_stack_comparative, libRNA), Cint, (Ptr{vrna_fold_compound_t}, Cint, Ptr{FLT_OR_DBL}, Cuint), fc, i, energies, options)
end

"""
    vrna_sc_remove(fc)

 @brief  Remove soft constraints from #vrna_fold_compound_t

 @note Accepts vrna_fold_compound_t of type #VRNA_FC_TYPE_SINGLE and #VRNA_FC_TYPE_COMPARATIVE

 @ingroup  soft_constraints

 @param  fc  The #vrna_fold_compound_t possibly containing soft constraints
### Prototype
```c
void vrna_sc_remove(vrna_fold_compound_t *fc);
```
"""
function vrna_sc_remove(fc)
    ccall((:vrna_sc_remove, libRNA), Cvoid, (Ptr{vrna_fold_compound_t},), fc)
end

"""
    vrna_sc_free(sc)

 @brief  Free memory occupied by a #vrna_sc_t data structure

 @ingroup  soft_constraints

 @param  sc  The data structure to free from memory
### Prototype
```c
void vrna_sc_free(vrna_sc_t *sc);
```
"""
function vrna_sc_free(sc)
    ccall((:vrna_sc_free, libRNA), Cvoid, (Ptr{vrna_sc_t},), sc)
end

"""
    vrna_sc_add_data(fc, data, free_data)

 @brief Add an auxiliary data structure for the generic soft constraints callback function

 @ingroup soft_constraints

 @see vrna_sc_add_f(), vrna_sc_add_exp_f(), vrna_sc_add_bt()

 @param  fc        The fold compound the generic soft constraint function should be bound to
 @param  data      A pointer to the data structure that holds required data for function 'f'
 @param  free_data A pointer to a function that free's the memory occupied by @p data (Maybe NULL)
 @return           Non-zero on successful binding the data (and free-function), 0 otherwise
### Prototype
```c
int vrna_sc_add_data(vrna_fold_compound_t *fc, void *data, vrna_auxdata_free_f free_data);
```
"""
function vrna_sc_add_data(fc, data, free_data)
    ccall((:vrna_sc_add_data, libRNA), Cint, (Ptr{vrna_fold_compound_t}, Ptr{Cvoid}, vrna_auxdata_free_f), fc, data, free_data)
end

"""
    vrna_sc_add_data_comparative(fc, data, free_data)


### Prototype
```c
int vrna_sc_add_data_comparative(vrna_fold_compound_t *fc, void **data, vrna_auxdata_free_f *free_data);
```
"""
function vrna_sc_add_data_comparative(fc, data, free_data)
    ccall((:vrna_sc_add_data_comparative, libRNA), Cint, (Ptr{vrna_fold_compound_t}, Ptr{Ptr{Cvoid}}, Ptr{vrna_auxdata_free_f}), fc, data, free_data)
end

"""
    vrna_sc_add_f(fc, f)

 @brief  Bind a function pointer for generic soft constraint feature (MFE version)

 This function allows one to easily bind a function pointer and corresponding data structure
 to the soft constraint part #vrna_sc_t of the #vrna_fold_compound_t.
 The function for evaluating the generic soft constraint feature has to return
 a pseudo free energy @f\$ \\hat{E} @f\$ in @f\$ dacal/mol @f\$, where @f\$ 1 dacal/mol = 10 cal/mol @f\$.

 @ingroup soft_constraints

 @see vrna_sc_add_data(), vrna_sc_add_bt(), vrna_sc_add_exp_f()

 @param  fc    The fold compound the generic soft constraint function should be bound to
 @param  f     A pointer to the function that evaluates the generic soft constraint feature
 @return       Non-zero on successful binding the callback function, 0 otherwise
### Prototype
```c
int vrna_sc_add_f(vrna_fold_compound_t *fc, vrna_sc_f f);
```
"""
function vrna_sc_add_f(fc, f)
    ccall((:vrna_sc_add_f, libRNA), Cint, (Ptr{vrna_fold_compound_t}, vrna_sc_f), fc, f)
end

"""
    vrna_sc_multi_cb_add(fc, cb, cb_exp, data, free_data, decomp_type)


### Prototype
```c
size_t vrna_sc_multi_cb_add(vrna_fold_compound_t *fc, vrna_sc_direct_f cb, vrna_sc_exp_direct_f cb_exp, void *data, vrna_auxdata_free_f free_data, unsigned int decomp_type);
```
"""
function vrna_sc_multi_cb_add(fc, cb, cb_exp, data, free_data, decomp_type)
    ccall((:vrna_sc_multi_cb_add, libRNA), Cint, (Ptr{vrna_fold_compound_t}, vrna_sc_direct_f, vrna_sc_exp_direct_f, Ptr{Cvoid}, vrna_auxdata_free_f, Cuint), fc, cb, cb_exp, data, free_data, decomp_type)
end

"""
    vrna_sc_add_f_comparative(fc, f)


### Prototype
```c
int vrna_sc_add_f_comparative(vrna_fold_compound_t *fc, vrna_sc_f *f);
```
"""
function vrna_sc_add_f_comparative(fc, f)
    ccall((:vrna_sc_add_f_comparative, libRNA), Cint, (Ptr{vrna_fold_compound_t}, Ptr{vrna_sc_f}), fc, f)
end

"""
    vrna_sc_add_bt(fc, f)

 @brief  Bind a backtracking function pointer for generic soft constraint feature

 This function allows one to easily bind a function pointer to the soft constraint part
 #vrna_sc_t of the #vrna_fold_compound_t.
 The provided function should be used for backtracking purposes in loop regions
 that were altered via the generic soft constraint feature. It has to return
 an array of #vrna_basepair_t data structures, were the last element in the list is indicated
 by a value of -1 in it's i position.

 @ingroup soft_constraints

 @see vrna_sc_add_data(), vrna_sc_add_f(), vrna_sc_add_exp_f()

 @param  fc    The fold compound the generic soft constraint function should be bound to
 @param  f     A pointer to the function that returns additional base pairs
 @return       Non-zero on successful binding the callback function, 0 otherwise
### Prototype
```c
int vrna_sc_add_bt(vrna_fold_compound_t *fc, vrna_sc_bt_f f);
```
"""
function vrna_sc_add_bt(fc, f)
    ccall((:vrna_sc_add_bt, libRNA), Cint, (Ptr{vrna_fold_compound_t}, vrna_sc_bt_f), fc, f)
end

"""
    vrna_sc_add_exp_f(fc, exp_f)

 @brief  Bind a function pointer for generic soft constraint feature (PF version)

 This function allows one to easily bind a function pointer and corresponding data structure
 to the soft constraint part #vrna_sc_t of the #vrna_fold_compound_t.
 The function for evaluating the generic soft constraint feature has to return
 a pseudo free energy @f\$ \\hat{E} @f\$ as Boltzmann factor, i.e. @f\$ exp(- \\hat{E} / kT) @f\$.
 The required unit for @f\$ E @f\$ is @f\$ cal/mol @f\$.

 @ingroup soft_constraints

 @see vrna_sc_add_bt(), vrna_sc_add_f(), vrna_sc_add_data()

 @param  fc    The fold compound the generic soft constraint function should be bound to
 @param  exp_f A pointer to the function that evaluates the generic soft constraint feature
 @return       Non-zero on successful binding the callback function, 0 otherwise
### Prototype
```c
int vrna_sc_add_exp_f(vrna_fold_compound_t *fc, vrna_sc_exp_f exp_f);
```
"""
function vrna_sc_add_exp_f(fc, exp_f)
    ccall((:vrna_sc_add_exp_f, libRNA), Cint, (Ptr{vrna_fold_compound_t}, vrna_sc_exp_f), fc, exp_f)
end

"""
    vrna_sc_add_exp_f_comparative(fc, exp_f)


### Prototype
```c
int vrna_sc_add_exp_f_comparative(vrna_fold_compound_t *fc, vrna_sc_exp_f *exp_f);
```
"""
function vrna_sc_add_exp_f_comparative(fc, exp_f)
    ccall((:vrna_sc_add_exp_f_comparative, libRNA), Cint, (Ptr{vrna_fold_compound_t}, Ptr{vrna_sc_exp_f}), fc, exp_f)
end

"""
    vrna_gr_set_aux_f(fc, cb)


### Prototype
```c
int vrna_gr_set_aux_f(vrna_fold_compound_t *fc, vrna_grammar_rule_f cb);
```
"""
function vrna_gr_set_aux_f(fc, cb)
    ccall((:vrna_gr_set_aux_f, libRNA), Cint, (Ptr{vrna_fold_compound_t}, vrna_grammar_rule_f), fc, cb)
end

"""
    vrna_gr_set_aux_exp_f(fc, cb)


### Prototype
```c
int vrna_gr_set_aux_exp_f(vrna_fold_compound_t *fc, vrna_grammar_rule_f_exp cb);
```
"""
function vrna_gr_set_aux_exp_f(fc, cb)
    ccall((:vrna_gr_set_aux_exp_f, libRNA), Cint, (Ptr{vrna_fold_compound_t}, vrna_grammar_rule_f_exp), fc, cb)
end

"""
    vrna_gr_set_aux_c(fc, cb)


### Prototype
```c
int vrna_gr_set_aux_c(vrna_fold_compound_t *fc, vrna_grammar_rule_f cb);
```
"""
function vrna_gr_set_aux_c(fc, cb)
    ccall((:vrna_gr_set_aux_c, libRNA), Cint, (Ptr{vrna_fold_compound_t}, vrna_grammar_rule_f), fc, cb)
end

"""
    vrna_gr_set_aux_exp_c(fc, cb)


### Prototype
```c
int vrna_gr_set_aux_exp_c(vrna_fold_compound_t *fc, vrna_grammar_rule_f_exp cb);
```
"""
function vrna_gr_set_aux_exp_c(fc, cb)
    ccall((:vrna_gr_set_aux_exp_c, libRNA), Cint, (Ptr{vrna_fold_compound_t}, vrna_grammar_rule_f_exp), fc, cb)
end

"""
    vrna_gr_set_aux_m(fc, cb)


### Prototype
```c
int vrna_gr_set_aux_m(vrna_fold_compound_t *fc, vrna_grammar_rule_f cb);
```
"""
function vrna_gr_set_aux_m(fc, cb)
    ccall((:vrna_gr_set_aux_m, libRNA), Cint, (Ptr{vrna_fold_compound_t}, vrna_grammar_rule_f), fc, cb)
end

"""
    vrna_gr_set_aux_exp_m(fc, cb)


### Prototype
```c
int vrna_gr_set_aux_exp_m(vrna_fold_compound_t *fc, vrna_grammar_rule_f_exp cb);
```
"""
function vrna_gr_set_aux_exp_m(fc, cb)
    ccall((:vrna_gr_set_aux_exp_m, libRNA), Cint, (Ptr{vrna_fold_compound_t}, vrna_grammar_rule_f_exp), fc, cb)
end

"""
    vrna_gr_set_aux_m1(fc, cb)


### Prototype
```c
int vrna_gr_set_aux_m1(vrna_fold_compound_t *fc, vrna_grammar_rule_f cb);
```
"""
function vrna_gr_set_aux_m1(fc, cb)
    ccall((:vrna_gr_set_aux_m1, libRNA), Cint, (Ptr{vrna_fold_compound_t}, vrna_grammar_rule_f), fc, cb)
end

"""
    vrna_gr_set_aux_exp_m1(fc, cb)


### Prototype
```c
int vrna_gr_set_aux_exp_m1(vrna_fold_compound_t *fc, vrna_grammar_rule_f_exp cb);
```
"""
function vrna_gr_set_aux_exp_m1(fc, cb)
    ccall((:vrna_gr_set_aux_exp_m1, libRNA), Cint, (Ptr{vrna_fold_compound_t}, vrna_grammar_rule_f_exp), fc, cb)
end

"""
    vrna_gr_set_aux(fc, cb)


### Prototype
```c
int vrna_gr_set_aux(vrna_fold_compound_t *fc, vrna_grammar_rule_f_aux cb);
```
"""
function vrna_gr_set_aux(fc, cb)
    ccall((:vrna_gr_set_aux, libRNA), Cint, (Ptr{vrna_fold_compound_t}, vrna_grammar_rule_f_aux), fc, cb)
end

"""
    vrna_gr_set_aux_exp(fc, cb)


### Prototype
```c
int vrna_gr_set_aux_exp(vrna_fold_compound_t *fc, vrna_grammar_rule_f_aux_exp cb);
```
"""
function vrna_gr_set_aux_exp(fc, cb)
    ccall((:vrna_gr_set_aux_exp, libRNA), Cint, (Ptr{vrna_fold_compound_t}, vrna_grammar_rule_f_aux_exp), fc, cb)
end

"""
    vrna_gr_set_data(fc, data, free_data)


### Prototype
```c
int vrna_gr_set_data(vrna_fold_compound_t *fc, void *data, vrna_grammar_data_free_f free_data);
```
"""
function vrna_gr_set_data(fc, data, free_data)
    ccall((:vrna_gr_set_data, libRNA), Cint, (Ptr{vrna_fold_compound_t}, Ptr{Cvoid}, vrna_grammar_data_free_f), fc, data, free_data)
end

"""
    vrna_gr_set_cond(fc, cb)


### Prototype
```c
int vrna_gr_set_cond(vrna_fold_compound_t *fc, vrna_grammar_cond_f cb);
```
"""
function vrna_gr_set_cond(fc, cb)
    ccall((:vrna_gr_set_cond, libRNA), Cint, (Ptr{vrna_fold_compound_t}, vrna_grammar_cond_f), fc, cb)
end

"""
    vrna_gr_reset(fc)


### Prototype
```c
int vrna_gr_reset(vrna_fold_compound_t *fc);
```
"""
function vrna_gr_reset(fc)
    ccall((:vrna_gr_reset, libRNA), Cint, (Ptr{vrna_fold_compound_t},), fc)
end

struct vrna_unstructured_domain_motif_s
    start::Cint
    number::Cint
end

const vrna_ud_motif_t = vrna_unstructured_domain_motif_s

"""
    vrna_hx_s

 @brief  Data structure representing an entry of a helix list
"""
struct vrna_hx_s
    start::Cuint
    _end::Cuint
    length::Cuint
    up5::Cuint
    up3::Cuint
end

"""
 @brief Convenience typedef for data structure #vrna_hx_s
 @ingroup  struct_utils_helix_list
"""
const vrna_hx_t = vrna_hx_s

"""
 @brief Convenience typedef for data structure #vrna_elem_prob_s
 @ingroup  struct_utils_plist
"""
const vrna_ep_t = vrna_elem_prob_s

"""
    vrna_db_pack(struc)

 @brief Pack secondary secondary structure, 5:1 compression using base 3 encoding

 Returns a binary string encoding of the secondary structure using
 a 5:1 compression scheme. The string is NULL terminated and can
 therefore be used with standard string functions such as strcmp().
 Useful for programs that need to keep many structures in memory.

 @see  vrna_db_unpack()

 @param struc    The secondary structure in dot-bracket notation
 @return         The binary encoded structure
### Prototype
```c
char * vrna_db_pack(const char *struc);
```
"""
function vrna_db_pack(struc)
    ccall((:vrna_db_pack, libRNA), Ptr{Cchar}, (Ptr{Cchar},), struc)
end

"""
    vrna_db_unpack(packed)

 @brief Unpack secondary structure previously packed with vrna_db_pack()

 Translate a compressed binary string produced by vrna_db_pack() back into
 the familiar dot-bracket notation.

 @see  vrna_db_pack()

 @param packed   The binary encoded packed secondary structure
 @return         The unpacked secondary structure in dot-bracket notation
### Prototype
```c
char * vrna_db_unpack(const char *packed);
```
"""
function vrna_db_unpack(packed)
    ccall((:vrna_db_unpack, libRNA), Ptr{Cchar}, (Ptr{Cchar},), packed)
end

"""
    vrna_db_flatten(structure, options)

 @brief Substitute pairs of brackets in a string with parenthesis

 This function can be used to replace brackets of unusual types,
 such as angular brackets @p <> , to dot-bracket format.
 The @p options parameter is used tpo specify which types of brackets
 will be replaced by round parenthesis @p () .

 @see vrna_db_flatten_to(),
      #VRNA_BRACKETS_RND, #VRNA_BRACKETS_ANG, #VRNA_BRACKETS_CLY, #VRNA_BRACKETS_SQR,
      #VRNA_BRACKETS_DEFAULT

 @param  structure   The structure string where brackets are flattened in-place
 @param  options     A bitmask to specify which types of brackets should be flattened out
### Prototype
```c
void vrna_db_flatten(char *structure, unsigned int options);
```
"""
function vrna_db_flatten(structure, options)
    ccall((:vrna_db_flatten, libRNA), Cvoid, (Ptr{Cchar}, Cuint), structure, options)
end

"""
    vrna_db_flatten_to(string, target, options)

 @brief Substitute pairs of brackets in a string with another type of pair characters

 This function can be used to replace brackets in a structure annotation string,
 such as square brackets @p [] , to another type of pair characters,
 e.g. angular brackets @p <> .

 The @p target array must contain a character for the 'pair open' annotation at
 position 0, and one for 'pair close' at position 1. T@p options parameter is used
 to specify which types of brackets will be replaced by the new pairs.

 @see vrna_db_flatten(),
      #VRNA_BRACKETS_RND, #VRNA_BRACKETS_ANG, #VRNA_BRACKETS_CLY, #VRNA_BRACKETS_SQR,
      #VRNA_BRACKETS_DEFAULT

 @param  string      The structure string where brackets are flattened in-place
 @param  target      The new pair characters the string will be flattened to
 @param  options     A bitmask to specify which types of brackets should be flattened out
### Prototype
```c
void vrna_db_flatten_to(char *string, const char target[3], unsigned int options);
```
"""
function vrna_db_flatten_to(string, target, options)
    ccall((:vrna_db_flatten_to, libRNA), Cvoid, (Ptr{Cchar}, Ptr{Cchar}, Cuint), string, target, options)
end

"""
    vrna_db_from_ptable(pt)

 @brief Convert a pair table into dot-parenthesis notation

 This function also converts pair table formatted structures that contain
 pseudoknots. Non-nested base pairs result in additional pairs of
 parenthesis and brackets within the resulting dot-parenthesis string.
 The following pairs are awailable: (), []. {}. <>, as well as pairs of
 matching upper-/lower-case characters from the alphabet A-Z.

 @note In cases where the level of non-nested base pairs exceeds the
       maximum number of 30 different base pair indicators (4 parenthesis/brackets,
       26 matching characters), a warning is printed and the remaining base pairs
       are left out from the conversion.

 @param pt The pair table to be copied
 @return   A char pointer to the dot-bracket string
### Prototype
```c
char * vrna_db_from_ptable(const short *pt);
```
"""
function vrna_db_from_ptable(pt)
    ccall((:vrna_db_from_ptable, libRNA), Ptr{Cchar}, (Ptr{Cshort},), pt)
end

"""
    vrna_db_from_plist(pairs, n)

 @brief  Convert a list of base pairs into dot-bracket notation

 @see vrna_plist()

 @param  pairs   A #vrna_ep_t containing the pairs to be included in
                 the dot-bracket string
 @param  n       The length of the structure (number of nucleotides)
 @return         The dot-bracket string containing the provided base pairs
### Prototype
```c
char * vrna_db_from_plist(vrna_ep_t *pairs, unsigned int n);
```
"""
function vrna_db_from_plist(pairs, n)
    ccall((:vrna_db_from_plist, libRNA), Ptr{Cchar}, (Ptr{vrna_ep_t}, Cuint), pairs, n)
end

"""
    vrna_db_to_element_string(structure)

 @brief  Convert a secondary structure in dot-bracket notation to a nucleotide annotation of loop contexts

 @param  structure   The secondary structure in dot-bracket notation
 @return             A string annotating each nucleotide according to it's structural context
### Prototype
```c
char * vrna_db_to_element_string(const char *structure);
```
"""
function vrna_db_to_element_string(structure)
    ccall((:vrna_db_to_element_string, libRNA), Ptr{Cchar}, (Ptr{Cchar},), structure)
end

"""
    vrna_db_pk_remove(structure, options)

 @brief  Remove pseudo-knots from an input structure

 This function removes pseudo-knots from an input structure
 by determining the minimum number of base pairs that need
 to be removed to make the structure pseudo-knot free.

 To accomplish that, we use a dynamic programming algorithm
 similar to the Nussinov maxmimum matching approach.

 The input structure must be in a dot-bracket string like form
 where crossing base pairs are denoted by the use of additional
 types of matching brackets, e.g. @p <>, @p {}, @p [], @p {}.
 Furthermore, crossing pairs may be annotated by matching
 uppercase/lowercase letters from the alphabet @p A-Z. For the latter,
 the uppercase letter must be the 5' and the lowercase letter
 the 3' nucleotide of the base pair. The actual type of brackets
 to be recognized by this function must be specifed through the
 @p options parameter.

 @note Brackets in the input structure string that are not covered
       by the @p options bitmask will be silently ignored!

 @see vrna_pt_pk_remove(), vrna_db_flatten(),
      #VRNA_BRACKETS_RND, #VRNA_BRACKETS_ANG, #VRNA_BRACKETS_CLY, #VRNA_BRACKETS_SQR,
      #VRNA_BRACKETS_ALPHA, #VRNA_BRACKETS_DEFAULT, #VRNA_BRACKETS_ANY

 @param  structure   Input structure in dot-bracket format that may include pseudo-knots
 @param  options     A bitmask to specify which types of brackets should be processed
 @return             The input structure devoid of pseudo-knots in dot-bracket notation
### Prototype
```c
char * vrna_db_pk_remove(const char *structure, unsigned int options);
```
"""
function vrna_db_pk_remove(structure, options)
    ccall((:vrna_db_pk_remove, libRNA), Ptr{Cchar}, (Ptr{Cchar}, Cuint), structure, options)
end

"""
    vrna_ptable(structure)

 @brief Create a pair table from a dot-bracket notation of a secondary structure

 Returns a newly allocated table, such that table[i]=j if (i.j) pair
 or 0 if i is unpaired, table[0] contains the length of the structure.

 @see  vrna_ptable_from_string(), vrna_db_from_ptable()

 @param  structure The secondary structure in dot-bracket notation
 @return           A pointer to the created pair_table
### Prototype
```c
short * vrna_ptable(const char *structure);
```
"""
function vrna_ptable(structure)
    ccall((:vrna_ptable, libRNA), Ptr{Cshort}, (Ptr{Cchar},), structure)
end

"""
    vrna_ptable_from_string(structure, options)

 @brief  Create a pair table for a secondary structure string

 This function takes an input string of a secondary structure annotation
 in @ref dot-bracket-notation or @ref dot-bracket-ext-notation, and converts
 it into a pair table representation.

 @note   This function also extracts crossing base pairs, i.e. pseudo-knots
         if more than a single matching bracket type is allowed through the
         bitmask @p options.

 @see vrna_ptable(), vrna_db_from_ptable(), vrna_db_flatten_to(), vrna_pt_pk_remove()
      #VRNA_BRACKETS_RND, #VRNA_BRACKETS_ANG, #VRNA_BRACKETS_CLY, #VRNA_BRACKETS_SQR,
      VRNA_BRACKETS_ALPHA, #VRNA_BRACKETS_DEFAULT, #VRNA_BRACKETS_ANY

 @param  structure Secondary structure in @ref dot-bracket-ext-notation
 @param  options   A bitmask to specify which brackets are recognized during conversion to pair table
 @return           A pointer to a new pair table of the provided secondary structure
### Prototype
```c
short * vrna_ptable_from_string(const char *structure, unsigned int options);
```
"""
function vrna_ptable_from_string(structure, options)
    ccall((:vrna_ptable_from_string, libRNA), Ptr{Cshort}, (Ptr{Cchar}, Cuint), structure, options)
end

"""
    vrna_pt_pk_get(structure)

 @brief Create a pair table of a secondary structure (pseudo-knot version)

 Returns a newly allocated table, such that table[i]=j if (i.j) pair
 or 0 if i is unpaired, table[0] contains the length of the structure.

 In contrast to vrna_ptable() this function also recognizes the base pairs
 denoted by '[' and ']' brackets. Thus, this function behaves like
 @code{.c}
 vrna_ptable_from_string(structure, #VRNA_BRACKETS_RND | VRNA_BRACKETS_SQR)
 @endcode

 @see    vrna_ptable_from_string()

 @param  structure The secondary structure in (extended) dot-bracket notation
 @return           A pointer to the created pair_table
### Prototype
```c
short * vrna_pt_pk_get(const char *structure);
```
"""
function vrna_pt_pk_get(structure)
    ccall((:vrna_pt_pk_get, libRNA), Ptr{Cshort}, (Ptr{Cchar},), structure)
end

"""
    vrna_ptable_copy(pt)

 @brief Get an exact copy of a pair table

 @param pt The pair table to be copied
 @return   A pointer to the copy of 'pt'
### Prototype
```c
short * vrna_ptable_copy(const short *pt);
```
"""
function vrna_ptable_copy(pt)
    ccall((:vrna_ptable_copy, libRNA), Ptr{Cshort}, (Ptr{Cshort},), pt)
end

"""
    vrna_pt_ali_get(structure)

@brief Create a pair table of a secondary structure (snoop align version)

### Prototype
```c
short * vrna_pt_ali_get(const char *structure);
```
"""
function vrna_pt_ali_get(structure)
    ccall((:vrna_pt_ali_get, libRNA), Ptr{Cshort}, (Ptr{Cchar},), structure)
end

"""
    vrna_pt_snoop_get(structure)

@brief Create a pair table of a secondary structure (snoop version)

 returns a newly allocated table, such that:  table[i]=j if (i.j) pair or
 0 if i is unpaired, table[0] contains the length of the structure.
 The special pseudoknotted H/ACA-mRNA structure is taken into account.
### Prototype
```c
short * vrna_pt_snoop_get(const char *structure);
```
"""
function vrna_pt_snoop_get(structure)
    ccall((:vrna_pt_snoop_get, libRNA), Ptr{Cshort}, (Ptr{Cchar},), structure)
end

"""
    vrna_pt_pk_remove(ptable, options)

 @brief  Remove pseudo-knots from a pair table

 This function removes pseudo-knots from an input structure
 by determining the minimum number of base pairs that need
 to be removed to make the structure pseudo-knot free.

 To accomplish that, we use a dynamic programming algorithm
 similar to the Nussinov maxmimum matching approach.

 @see    vrna_db_pk_remove()

 @param  ptable  Input structure that may include pseudo-knots
 @param  options
 @return         The input structure devoid of pseudo-knots
### Prototype
```c
short * vrna_pt_pk_remove(const short *ptable, unsigned int options);
```
"""
function vrna_pt_pk_remove(ptable, options)
    ccall((:vrna_pt_pk_remove, libRNA), Ptr{Cshort}, (Ptr{Cshort}, Cuint), ptable, options)
end

"""
    vrna_plist(struc, pr)

 @brief Create a #vrna_ep_t from a dot-bracket string

 The dot-bracket string is parsed and for each base pair an
 entry in the plist is created. The probability of each pair in
 the list is set by a function parameter.

 The end of the plist is marked by sequence positions i as well as j
 equal to 0. This condition should be used to stop looping over its
 entries

 @param struc  The secondary structure in dot-bracket notation
 @param pr     The probability for each base pair used in the plist
 @return       The plist array
### Prototype
```c
vrna_ep_t *vrna_plist(const char *struc, float pr);
```
"""
function vrna_plist(struc, pr)
    ccall((:vrna_plist, libRNA), Ptr{vrna_ep_t}, (Ptr{Cchar}, Cfloat), struc, pr)
end

"""
    vrna_plist_from_probs(fc, cut_off)

 @brief Create a #vrna_ep_t from base pair probability matrix

 The probability matrix provided via the #vrna_fold_compound_t is parsed
 and all pair probabilities above the given threshold are used to create
 an entry in the plist

 The end of the plist is marked by sequence positions i as well as j
 equal to 0. This condition should be used to stop looping over its
 entries

 @ingroup              part_func_global
 @param[in]  fc        The fold compound
 @param[in]  cut_off   The cutoff value
 @return               A pointer to the plist that is to be created
### Prototype
```c
vrna_ep_t *vrna_plist_from_probs(vrna_fold_compound_t *fc, double cut_off);
```
"""
function vrna_plist_from_probs(fc, cut_off)
    ccall((:vrna_plist_from_probs, libRNA), Ptr{vrna_ep_t}, (Ptr{vrna_fold_compound_t}, Cdouble), fc, cut_off)
end

"""
    vrna_db_from_WUSS(wuss)

 @brief  Convert a WUSS annotation string to dot-bracket format

 @note This function flattens all brackets, and treats pseudo-knots annotated
       by matching pairs of upper/lowercase letters as unpaired nucleotides

 @param  wuss  The input string in WUSS notation
 @return       A dot-bracket notation of the input secondary structure
### Prototype
```c
char * vrna_db_from_WUSS(const char *wuss);
```
"""
function vrna_db_from_WUSS(wuss)
    ccall((:vrna_db_from_WUSS, libRNA), Ptr{Cchar}, (Ptr{Cchar},), wuss)
end

"""
    vrna_abstract_shapes(structure, level)

 @brief  Convert a secondary structure in dot-bracket notation to its abstract shapes representation

 This function converts a secondary structure into its abstract shapes representation as
 presented by Giegerich et al. 2004 @cite giegerich:2004.

 @see vrna_abstract_shapes_pt()

 @param  structure A secondary structure in dot-bracket notation
 @param  level     The abstraction level (integer in the range of 0 to 5)
 @return           The secondary structure in abstract shapes notation
### Prototype
```c
char * vrna_abstract_shapes(const char *structure, unsigned int level);
```
"""
function vrna_abstract_shapes(structure, level)
    ccall((:vrna_abstract_shapes, libRNA), Ptr{Cchar}, (Ptr{Cchar}, Cuint), structure, level)
end

"""
    vrna_abstract_shapes_pt(pt, level)

 @brief  Convert a secondary structure to its abstract shapes representation

 This function converts a secondary structure into its abstract shapes representation as
 presented by Giegerich et al. 2004 @cite giegerich:2004. This function is equivalent to
 vrna_db_to_shapes(), but requires a pair table input instead of a dot-bracket structure.

 @note   The length of the structure must be present at @p pt[0]!

 @see vrna_abstract_shapes()

 @param  pt      A secondary structure in pair table format
 @param  level   The abstraction level (integer in the range of 0 to 5)
 @return         The secondary structure in abstract shapes notation
### Prototype
```c
char * vrna_abstract_shapes_pt(const short *pt, unsigned int level);
```
"""
function vrna_abstract_shapes_pt(pt, level)
    ccall((:vrna_abstract_shapes_pt, libRNA), Ptr{Cchar}, (Ptr{Cshort}, Cuint), pt, level)
end

"""
    vrna_hx_from_ptable(pt)

 @brief  Convert a pair table representation of a secondary structure into a helix list

 @param  pt  The secondary structure in pair table representation
 @return     The secondary structure represented as a helix list
### Prototype
```c
vrna_hx_t * vrna_hx_from_ptable(short *pt);
```
"""
function vrna_hx_from_ptable(pt)
    ccall((:vrna_hx_from_ptable, libRNA), Ptr{vrna_hx_t}, (Ptr{Cshort},), pt)
end

"""
    vrna_hx_merge(list, maxdist)

 @brief  Create a merged helix list from another helix list
### Prototype
```c
vrna_hx_t * vrna_hx_merge(const vrna_hx_t *list, int maxdist);
```
"""
function vrna_hx_merge(list, maxdist)
    ccall((:vrna_hx_merge, libRNA), Ptr{vrna_hx_t}, (Ptr{vrna_hx_t}, Cint), list, maxdist)
end

"""
    vrna_loopidx_from_ptable(pt)

 @brief Get a loop index representation of a structure
### Prototype
```c
int * vrna_loopidx_from_ptable(const short *pt);
```
"""
function vrna_loopidx_from_ptable(pt)
    ccall((:vrna_loopidx_from_ptable, libRNA), Ptr{Cint}, (Ptr{Cshort},), pt)
end

"""
    vrna_bp_distance_pt(pt1, pt2)

 @brief Compute the "base pair" distance between two pair tables pt1 and pt2 of secondary structures.

 The pair tables should have the same length.
 dist = number of base pairs in one structure but not in the other
 same as edit distance with open-pair close-pair as move-set

 @see vrna_bp_distance()

 @param pt1   First structure in dot-bracket notation
 @param pt2   Second structure in dot-bracket notation
 @return       The base pair distance between pt1 and pt2
### Prototype
```c
int vrna_bp_distance_pt(const short *pt1, const short *pt2);
```
"""
function vrna_bp_distance_pt(pt1, pt2)
    ccall((:vrna_bp_distance_pt, libRNA), Cint, (Ptr{Cshort}, Ptr{Cshort}), pt1, pt2)
end

"""
    vrna_bp_distance(str1, str2)

 @brief Compute the "base pair" distance between two secondary structures s1 and s2.

 This is a wrapper around @b vrna_bp_distance_pt().
 The sequences should have the same length.
 dist = number of base pairs in one structure but not in the other
 same as edit distance with open-pair close-pair as move-set

 @see vrna_bp_distance_pt()

 @param str1   First structure in dot-bracket notation
 @param str2   Second structure in dot-bracket notation
 @return       The base pair distance between str1 and str2
### Prototype
```c
int vrna_bp_distance(const char *str1, const char *str2);
```
"""
function vrna_bp_distance(str1, str2)
    ccall((:vrna_bp_distance, libRNA), Cint, (Ptr{Cchar}, Ptr{Cchar}), str1, str2)
end

"""
    vrna_dist_mountain(str1, str2, p)


### Prototype
```c
double vrna_dist_mountain(const char *str1, const char *str2, unsigned int p);
```
"""
function vrna_dist_mountain(str1, str2, p)
    ccall((:vrna_dist_mountain, libRNA), Cdouble, (Ptr{Cchar}, Ptr{Cchar}, Cuint), str1, str2, p)
end

"""
    vrna_refBPcnt_matrix(reference_pt, turn)

 @brief Make a reference base pair count matrix

 Get an upper triangular matrix containing the number of basepairs of a reference
 structure for each interval [i,j] with i<j. Access it via iindx!!!
### Prototype
```c
unsigned int * vrna_refBPcnt_matrix(const short *reference_pt, unsigned int turn);
```
"""
function vrna_refBPcnt_matrix(reference_pt, turn)
    ccall((:vrna_refBPcnt_matrix, libRNA), Ptr{Cuint}, (Ptr{Cshort}, Cuint), reference_pt, turn)
end

"""
    vrna_refBPdist_matrix(pt1, pt2, turn)

 @brief Make a reference base pair distance matrix

 Get an upper triangular matrix containing the base pair distance of two
 reference structures for each interval [i,j] with i<j. Access it via iindx!!!

### Prototype
```c
unsigned int * vrna_refBPdist_matrix(const short *pt1, const short *pt2, unsigned int turn);
```
"""
function vrna_refBPdist_matrix(pt1, pt2, turn)
    ccall((:vrna_refBPdist_matrix, libRNA), Ptr{Cuint}, (Ptr{Cshort}, Ptr{Cshort}, Cuint), pt1, pt2, turn)
end

"""
    vrna_db_from_probs(pr, length)

 @brief Create a dot-bracket like structure string from base pair probability matrix
### Prototype
```c
char * vrna_db_from_probs(const FLT_OR_DBL *pr, unsigned int length);
```
"""
function vrna_db_from_probs(pr, length)
    ccall((:vrna_db_from_probs, libRNA), Ptr{Cchar}, (Ptr{FLT_OR_DBL}, Cuint), pr, length)
end

"""
    vrna_bpp_symbol(x)

 @brief Get a pseudo dot bracket notation for a given probability information
### Prototype
```c
char vrna_bpp_symbol(const float *x);
```
"""
function vrna_bpp_symbol(x)
    ccall((:vrna_bpp_symbol, libRNA), Cchar, (Ptr{Cfloat},), x)
end

"""
    vrna_db_from_bp_stack(bp, length)

 @brief Create a dot-backet/parenthesis structure from backtracking stack

 This function is capable to create dot-bracket structures from suboptimal
 structure prediction sensu M. Zuker

 @param bp     Base pair stack containing the traced base pairs
 @param length The length of the structure
 @return       The secondary structure in dot-bracket notation as
               provided in the input
### Prototype
```c
char * vrna_db_from_bp_stack(vrna_bp_stack_t *bp, unsigned int length);
```
"""
function vrna_db_from_bp_stack(bp, length)
    ccall((:vrna_db_from_bp_stack, libRNA), Ptr{Cchar}, (Ptr{vrna_bp_stack_t}, Cuint), bp, length)
end

"""
    vrna_letter_structure(structure, bp, length)


### Prototype
```c
void vrna_letter_structure(char *structure, vrna_bp_stack_t *bp, unsigned int length);
```
"""
function vrna_letter_structure(structure, bp, length)
    ccall((:vrna_letter_structure, libRNA), Cvoid, (Ptr{Cchar}, Ptr{vrna_bp_stack_t}, Cuint), structure, bp, length)
end

"""
    vrna_db_to_tree_string(structure, type)

 @brief  Convert a Dot-Bracket structure string into tree string representation

 This function allows one to convert a secondary structure in dot-bracket notation
 into one of the various tree representations for secondary structures. The resulting
 tree is then represented as a string of parenthesis and node symbols, similar to
 to the Newick format.

 Currently we support conversion into the following formats, denoted by the value
 of parameter @p type:
 * #VRNA_STRUCTURE_TREE_HIT            - @copybrief #VRNA_STRUCTURE_TREE_HIT
                                         (See also Fontana et al. 1993 @cite fontana:1993b)
 * #VRNA_STRUCTURE_TREE_SHAPIRO_SHORT  - @copybrief #VRNA_STRUCTURE_TREE_SHAPIRO_SHORT
                                         (same as Shapiro 1988 @cite shapiro:1988, but with root node @p R and without @p S nodes for the stems)
 * #VRNA_STRUCTURE_TREE_SHAPIRO        - @copybrief #VRNA_STRUCTURE_TREE_SHAPIRO
                                         (See also Shapiro 1988 @cite shapiro:1988)
 * #VRNA_STRUCTURE_TREE_SHAPIRO_EXT    - @copybrief #VRNA_STRUCTURE_TREE_SHAPIRO_EXT
                                         (same as Shapiro 1988 @cite shapiro:1988, but external nodes denoted as @p E )
 * #VRNA_STRUCTURE_TREE_SHAPIRO_WEIGHT - @copybrief #VRNA_STRUCTURE_TREE_SHAPIRO_WEIGHT
                                         (same as #VRNA_STRUCTURE_TREE_SHAPIRO_EXT but with additional weights
                                         for number of unpaired nucleotides in loop, and number of pairs in stems)
 * #VRNA_STRUCTURE_TREE_EXPANDED       - @copybrief #VRNA_STRUCTURE_TREE_EXPANDED

 @see  @ref sec_structure_representations_tree

 @param  structure   The null-terminated dot-bracket structure string
 @param  type        A switch to determine the type of tree string representation
 @return             A tree representation of the input @p structure
### Prototype
```c
char * vrna_db_to_tree_string(const char *structure, unsigned int type);
```
"""
function vrna_db_to_tree_string(structure, type)
    ccall((:vrna_db_to_tree_string, libRNA), Ptr{Cchar}, (Ptr{Cchar}, Cuint), structure, type)
end

"""
    vrna_tree_string_unweight(structure)

 @brief  Remove weights from a linear string tree representation of a secondary structure

 This function strips the weights of a linear string tree representation such as @p HIT,
 or Coarse Grained Tree sensu Shapiro @cite shapiro:1988

 @see vrna_db_to_tree_string()

 @param  structure   A linear string tree representation of a secondary structure with weights
 @return             A linear string tree representation of a secondary structure without weights
### Prototype
```c
char * vrna_tree_string_unweight(const char *structure);
```
"""
function vrna_tree_string_unweight(structure)
    ccall((:vrna_tree_string_unweight, libRNA), Ptr{Cchar}, (Ptr{Cchar},), structure)
end

"""
    vrna_tree_string_to_db(tree)

 @brief  Convert a linear tree string representation of a secondary structure back to Dot-Bracket notation

 @warning  This function only accepts <em>Expanded</em> and <em>HIT</em> tree representations!

 @see vrna_db_to_tree_string(), #VRNA_STRUCTURE_TREE_EXPANDED, #VRNA_STRUCTURE_TREE_HIT,
      @ref sec_structure_representations_tree

 @param  tree  A linear tree string representation of a secondary structure
 @return       A dot-bracket notation of the secondary structure provided in @p tree
### Prototype
```c
char * vrna_tree_string_to_db(const char *tree);
```
"""
function vrna_tree_string_to_db(tree)
    ccall((:vrna_tree_string_to_db, libRNA), Ptr{Cchar}, (Ptr{Cchar},), tree)
end

"""
    assign_plist_from_db(pl, struc, pr)


### Prototype
```c
;
```
"""
function assign_plist_from_db(pl, struc, pr)
    ccall((:assign_plist_from_db, libRNA), Cvoid, (Ptr{Ptr{vrna_ep_t}}, Ptr{Cchar}, Cfloat), pl, struc, pr)
end

"""
    pack_structure(struc)


### Prototype
```c
;
```
"""
function pack_structure(struc)
    ccall((:pack_structure, libRNA), Ptr{Cchar}, (Ptr{Cchar},), struc)
end

"""
    unpack_structure(packed)


### Prototype
```c
;
```
"""
function unpack_structure(packed)
    ccall((:unpack_structure, libRNA), Ptr{Cchar}, (Ptr{Cchar},), packed)
end

"""
    make_pair_table(structure)


### Prototype
```c
;
```
"""
function make_pair_table(structure)
    ccall((:make_pair_table, libRNA), Ptr{Cshort}, (Ptr{Cchar},), structure)
end

"""
    make_pair_table_pk(structure)


### Prototype
```c
;
```
"""
function make_pair_table_pk(structure)
    ccall((:make_pair_table_pk, libRNA), Ptr{Cshort}, (Ptr{Cchar},), structure)
end

"""
    copy_pair_table(pt)


### Prototype
```c
;
```
"""
function copy_pair_table(pt)
    ccall((:copy_pair_table, libRNA), Ptr{Cshort}, (Ptr{Cshort},), pt)
end

"""
    alimake_pair_table(structure)


### Prototype
```c
;
```
"""
function alimake_pair_table(structure)
    ccall((:alimake_pair_table, libRNA), Ptr{Cshort}, (Ptr{Cchar},), structure)
end

"""
    make_pair_table_snoop(structure)


### Prototype
```c
;
```
"""
function make_pair_table_snoop(structure)
    ccall((:make_pair_table_snoop, libRNA), Ptr{Cshort}, (Ptr{Cchar},), structure)
end

"""
    make_loop_index_pt(pt)


### Prototype
```c
;
```
"""
function make_loop_index_pt(pt)
    ccall((:make_loop_index_pt, libRNA), Ptr{Cint}, (Ptr{Cshort},), pt)
end

"""
    bp_distance(str1, str2)


### Prototype
```c
;
```
"""
function bp_distance(str1, str2)
    ccall((:bp_distance, libRNA), Cint, (Ptr{Cchar}, Ptr{Cchar}), str1, str2)
end

"""
    make_referenceBP_array(reference_pt, turn)


### Prototype
```c
;
```
"""
function make_referenceBP_array(reference_pt, turn)
    ccall((:make_referenceBP_array, libRNA), Ptr{Cuint}, (Ptr{Cshort}, Cuint), reference_pt, turn)
end

"""
    compute_BPdifferences(pt1, pt2, turn)


### Prototype
```c
;
```
"""
function compute_BPdifferences(pt1, pt2, turn)
    ccall((:compute_BPdifferences, libRNA), Ptr{Cuint}, (Ptr{Cshort}, Ptr{Cshort}, Cuint), pt1, pt2, turn)
end

"""
    assign_plist_from_pr(pl, probs, length, cutoff)


### Prototype
```c
;
```
"""
function assign_plist_from_pr(pl, probs, length, cutoff)
    ccall((:assign_plist_from_pr, libRNA), Cvoid, (Ptr{Ptr{vrna_ep_t}}, Ptr{FLT_OR_DBL}, Cint, Cdouble), pl, probs, length, cutoff)
end

"""
    parenthesis_structure(structure, bp, length)


### Prototype
```c
;
```
"""
function parenthesis_structure(structure, bp, length)
    ccall((:parenthesis_structure, libRNA), Cvoid, (Ptr{Cchar}, Ptr{vrna_bp_stack_t}, Cint), structure, bp, length)
end

"""
    parenthesis_zuker(structure, bp, length)


### Prototype
```c
;
```
"""
function parenthesis_zuker(structure, bp, length)
    ccall((:parenthesis_zuker, libRNA), Cvoid, (Ptr{Cchar}, Ptr{vrna_bp_stack_t}, Cint), structure, bp, length)
end

"""
    letter_structure(structure, bp, length)


### Prototype
```c
;
```
"""
function letter_structure(structure, bp, length)
    ccall((:letter_structure, libRNA), Cvoid, (Ptr{Cchar}, Ptr{vrna_bp_stack_t}, Cint), structure, bp, length)
end

"""
    bppm_to_structure(structure, pr, length)


### Prototype
```c
;
```
"""
function bppm_to_structure(structure, pr, length)
    ccall((:bppm_to_structure, libRNA), Cvoid, (Ptr{Cchar}, Ptr{FLT_OR_DBL}, Cuint), structure, pr, length)
end

"""
    bppm_symbol(x)


### Prototype
```c
;
```
"""
function bppm_symbol(x)
    ccall((:bppm_symbol, libRNA), Cchar, (Ptr{Cfloat},), x)
end

# DEPRECATED
const vrna_callback_ud_energy = Cvoid

# DEPRECATED
const vrna_callback_ud_exp_energy = Cvoid

# DEPRECATED
const vrna_callback_ud_production = Cvoid

# DEPRECATED
const vrna_callback_ud_exp_production = Cvoid

# DEPRECATED
const vrna_callback_ud_probs_add = Cvoid

# DEPRECATED
const vrna_callback_ud_probs_get = Cvoid

"""
    vrna_ud_motifs_centroid(fc, structure)

 @brief Detect unstructured domains in centroid structure

 Given a centroid structure and a set of unstructured domains compute
 the list of unstructured domain motifs present in the centroid.
 Since we do not explicitly annotate unstructured domain motifs in
 dot-bracket strings, this function can be used to check for the
 presence and location of unstructured domain motifs under the
 assumption that the dot-bracket string is the centroid structure
 of the equiibrium ensemble.

 @see vrna_centroid()

 @ingroup domains_up

 @param  fc        The fold_compound data structure with pre-computed equilibrium probabilities and model settings
 @param  structure The centroid structure in dot-bracket notation
 @return           A list of unstructured domain motifs (possibly NULL). The last element terminates the list with
                   @p start=0, @p number=-1
### Prototype
```c
vrna_ud_motif_t * vrna_ud_motifs_centroid(vrna_fold_compound_t *fc, const char *structure);
```
"""
function vrna_ud_motifs_centroid(fc, structure)
    ccall((:vrna_ud_motifs_centroid, libRNA), Ptr{vrna_ud_motif_t}, (Ptr{vrna_fold_compound_t}, Ptr{Cchar}), fc, structure)
end

"""
    vrna_ud_motifs_MEA(fc, structure, probability_list)

 @brief Detect unstructured domains in MEA structure

 Given an MEA structure and a set of unstructured domains compute
 the list of unstructured domain motifs present in the MEA structure.
 Since we do not explicitly annotate unstructured domain motifs in
 dot-bracket strings, this function can be used to check for the
 presence and location of unstructured domain motifs under the
 assumption that the dot-bracket string is the MEA structure
 of the equiibrium ensemble.

 @see MEA()

 @ingroup domains_up

 @param  fc                The fold_compound data structure with pre-computed equilibrium probabilities and model settings
 @param  structure         The MEA structure in dot-bracket notation
 @param  probability_list  The list of probabilities to extract the MEA structure from
 @return                   A list of unstructured domain motifs (possibly NULL). The last element terminates the list
                           with @p start=0, @p number=-1
### Prototype
```c
vrna_ud_motif_t * vrna_ud_motifs_MEA(vrna_fold_compound_t *fc, const char *structure, vrna_ep_t *probability_list);
```
"""
function vrna_ud_motifs_MEA(fc, structure, probability_list)
    ccall((:vrna_ud_motifs_MEA, libRNA), Ptr{vrna_ud_motif_t}, (Ptr{vrna_fold_compound_t}, Ptr{Cchar}, Ptr{vrna_ep_t}), fc, structure, probability_list)
end

"""
    vrna_ud_motifs_MFE(fc, structure)

 @brief Detect unstructured domains in MFE structure

 Given an MFE structure and a set of unstructured domains compute
 the list of unstructured domain motifs present in the MFE structure.
 Since we do not explicitly annotate unstructured domain motifs in
 dot-bracket strings, this function can be used to check for the
 presence and location of unstructured domain motifs under the
 assumption that the dot-bracket string is the MFE structure
 of the equiibrium ensemble.

 @see vrna_mfe()

 @ingroup domains_up

 @param  fc        The fold_compound data structure with model settings
 @param  structure The MFE structure in dot-bracket notation
 @return           A list of unstructured domain motifs (possibly NULL). The last element terminates the list with @p start=0, @p number=-1
### Prototype
```c
vrna_ud_motif_t * vrna_ud_motifs_MFE(vrna_fold_compound_t *fc, const char *structure);
```
"""
function vrna_ud_motifs_MFE(fc, structure)
    ccall((:vrna_ud_motifs_MFE, libRNA), Ptr{vrna_ud_motif_t}, (Ptr{vrna_fold_compound_t}, Ptr{Cchar}), fc, structure)
end

"""
    vrna_ud_add_motif(fc, motif, motif_en, motif_name, loop_type)

 @brief  Add an unstructured domain motif, e.g. for ligand binding

 This function adds a ligand binding motif and the associated binding free energy
 to the #vrna_ud_t attribute of a #vrna_fold_compound_t. The motif data
 will then be used in subsequent secondary structure predictions. Multiple calls
 to this function with different motifs append all additional data to a list of
 ligands, which all will be evaluated. Ligand motif data can be removed from the
 #vrna_fold_compound_t again using the vrna_ud_remove() function. The loop
 type parameter allows one to limit the ligand binding to particular loop type,
 such as the exterior loop, hairpin loops, interior loops, or multibranch loops.

 @see  #VRNA_UNSTRUCTURED_DOMAIN_EXT_LOOP, #VRNA_UNSTRUCTURED_DOMAIN_HP_LOOP,
       #VRNA_UNSTRUCTURED_DOMAIN_INT_LOOP, #VRNA_UNSTRUCTURED_DOMAIN_MB_LOOP,
       #VRNA_UNSTRUCTURED_DOMAIN_ALL_LOOPS, vrna_ud_remove()

 @ingroup domains_up

 @param  fc          The #vrna_fold_compound_t data structure the ligand motif should be bound to
 @param  motif       The sequence motif the ligand binds to
 @param  motif_en    The binding free energy of the ligand in kcal/mol
 @param  motif_name  The name/id of the motif (may be @p NULL)
 @param  loop_type   The loop type the ligand binds to

### Prototype
```c
void vrna_ud_add_motif(vrna_fold_compound_t *fc, const char *motif, double motif_en, const char *motif_name, unsigned int loop_type);
```
"""
function vrna_ud_add_motif(fc, motif, motif_en, motif_name, loop_type)
    ccall((:vrna_ud_add_motif, libRNA), Cvoid, (Ptr{vrna_fold_compound_t}, Ptr{Cchar}, Cdouble, Ptr{Cchar}, Cuint), fc, motif, motif_en, motif_name, loop_type)
end

"""
    vrna_ud_get_motif_size_at(fc, i, loop_type)

 @brief  Get a list of unique motif sizes that start at a certain position within the sequence

### Prototype
```c
int *vrna_ud_get_motif_size_at(vrna_fold_compound_t *fc, int i, unsigned int loop_type);
```
"""
function vrna_ud_get_motif_size_at(fc, i, loop_type)
    ccall((:vrna_ud_get_motif_size_at, libRNA), Ptr{Cint}, (Ptr{vrna_fold_compound_t}, Cint, Cuint), fc, i, loop_type)
end

"""
    vrna_ud_get_motifs_at(fc, i, loop_type)


### Prototype
```c
int * vrna_ud_get_motifs_at(vrna_fold_compound_t *fc, int i, unsigned int loop_type);
```
"""
function vrna_ud_get_motifs_at(fc, i, loop_type)
    ccall((:vrna_ud_get_motifs_at, libRNA), Ptr{Cint}, (Ptr{vrna_fold_compound_t}, Cint, Cuint), fc, i, loop_type)
end

"""
    vrna_ud_detect_motifs(fc, structure)


### Prototype
```c
vrna_ud_motif_t * vrna_ud_detect_motifs(vrna_fold_compound_t *fc, const char *structure);
```
"""
function vrna_ud_detect_motifs(fc, structure)
    ccall((:vrna_ud_detect_motifs, libRNA), Ptr{vrna_ud_motif_t}, (Ptr{vrna_fold_compound_t}, Ptr{Cchar}), fc, structure)
end

"""
    vrna_ud_remove(fc)

 @brief Remove ligand binding to unpaired stretches

 This function removes all ligand motifs that were bound to a #vrna_fold_compound_t using
 the vrna_ud_add_motif() function.

 @ingroup domains_up

 @param fc The #vrna_fold_compound_t data structure the ligand motif data should be removed from
### Prototype
```c
void vrna_ud_remove(vrna_fold_compound_t *fc);
```
"""
function vrna_ud_remove(fc)
    ccall((:vrna_ud_remove, libRNA), Cvoid, (Ptr{vrna_fold_compound_t},), fc)
end

"""
    vrna_ud_set_data(fc, data, free_cb)

 @brief  Attach an auxiliary data structure

 This function binds an arbitrary, auxiliary data structure for user-implemented ligand binding.
 The optional callback @p free_cb will be passed the bound data structure whenever the #vrna_fold_compound_t
 is removed from memory to avoid memory leaks.

 @see  vrna_ud_set_prod_rule_cb(), vrna_ud_set_exp_prod_rule_cb(),
       vrna_ud_remove()

 @ingroup domains_up

 @param  fc      The #vrna_fold_compound_t data structure the auxiliary data structure should be bound to
 @param  data    A pointer to the auxiliary data structure
 @param  free_cb A pointer to a callback function that free's memory occupied by @p data
### Prototype
```c
void vrna_ud_set_data(vrna_fold_compound_t *fc, void *data, vrna_auxdata_free_f free_cb);
```
"""
function vrna_ud_set_data(fc, data, free_cb)
    ccall((:vrna_ud_set_data, libRNA), Cvoid, (Ptr{vrna_fold_compound_t}, Ptr{Cvoid}, vrna_auxdata_free_f), fc, data, free_cb)
end

"""
    vrna_ud_set_prod_rule_cb(fc, pre_cb, e_cb)

 @brief Attach production rule callbacks for free energies computations

 Use this function to bind a user-implemented grammar extension for unstructured
 domains.

 The callback @p e_cb needs to evaluate the free energy contribution @f\$f(i,j)@f\$ of
 the unpaired segment @f\$[i,j]@f\$. It will be executed in each of the regular secondary
 structure production rules. Whenever the callback is passed the #VRNA_UNSTRUCTURED_DOMAIN_MOTIF
 flag via its @p loop_type parameter the contribution of any ligand that consecutively
 binds from position @f\$i@f\$ to @f\$j@f\$ (the white box) is requested. Otherwise, the callback
 usually performs a lookup in the precomputed @p B matrices. Which @p B matrix is
 addressed will be indicated by the flags #VRNA_UNSTRUCTURED_DOMAIN_EXT_LOOP, #VRNA_UNSTRUCTURED_DOMAIN_HP_LOOP
 #VRNA_UNSTRUCTURED_DOMAIN_INT_LOOP, and #VRNA_UNSTRUCTURED_DOMAIN_MB_LOOP. As their names already imply,
 they specify exterior loops (@p F production rule), hairpin loops and interior loops
 (@p C production rule), and multibranch loops (@p M and @p M1 production rule).

 @image html   ligands_up_callback.svg
 @image latex  ligands_up_callback.eps

 The @p pre_cb callback will be executed as a pre-processing step right before the
 regular secondary structure rules. Usually one would use this callback to fill the
 dynamic programming matrices @p U and preparations of the auxiliary data structure
 #vrna_unstructured_domain_s.data

 @image html   B_prod_rule.svg
 @image latex  B_prod_rule.eps

 @ingroup domains_up

 @param  fc      The #vrna_fold_compound_t data structure the callback will be bound to
 @param  pre_cb  A pointer to a callback function for the @p B production rule
 @param  e_cb    A pointer to a callback function for free energy evaluation
### Prototype
```c
void vrna_ud_set_prod_rule_cb(vrna_fold_compound_t *fc, vrna_ud_production_f pre_cb, vrna_ud_f e_cb);
```
"""
function vrna_ud_set_prod_rule_cb(fc, pre_cb, e_cb)
    ccall((:vrna_ud_set_prod_rule_cb, libRNA), Cvoid, (Ptr{vrna_fold_compound_t}, vrna_ud_production_f, vrna_ud_f), fc, pre_cb, e_cb)
end

"""
    vrna_ud_set_exp_prod_rule_cb(fc, pre_cb, exp_e_cb)

 @brief Attach production rule for partition function

 This function is the partition function companion of vrna_ud_set_prod_rule_cb().

 Use it to bind callbacks to (i) fill the @p U production rule dynamic programming
 matrices and/or prepare the #vrna_unstructured_domain_s.data, and (ii) provide a callback
 to retrieve partition functions for subsegments @f\$ [i,j] @f\$.

 @image html   B_prod_rule.svg
 @image latex  B_prod_rule.eps

 @image html   ligands_up_callback.svg
 @image latex  ligands_up_callback.eps

 @ingroup domains_up

 @see vrna_ud_set_prod_rule_cb()

 @param  fc        The #vrna_fold_compound_t data structure the callback will be bound to
 @param  pre_cb    A pointer to a callback function for the @p B production rule
 @param  exp_e_cb  A pointer to a callback function that retrieves the partition function
                   for a segment @f\$[i,j]@f\$ that may be bound by one or more ligands.
### Prototype
```c
void vrna_ud_set_exp_prod_rule_cb(vrna_fold_compound_t *fc, vrna_ud_exp_production_f pre_cb, vrna_ud_exp_f exp_e_cb);
```
"""
function vrna_ud_set_exp_prod_rule_cb(fc, pre_cb, exp_e_cb)
    ccall((:vrna_ud_set_exp_prod_rule_cb, libRNA), Cvoid, (Ptr{vrna_fold_compound_t}, vrna_ud_exp_production_f, vrna_ud_exp_f), fc, pre_cb, exp_e_cb)
end

"""
    vrna_ud_set_prob_cb(fc, setter, getter)


### Prototype
```c
void vrna_ud_set_prob_cb(vrna_fold_compound_t *fc, vrna_ud_add_probs_f setter, vrna_ud_get_probs_f getter);
```
"""
function vrna_ud_set_prob_cb(fc, setter, getter)
    ccall((:vrna_ud_set_prob_cb, libRNA), Cvoid, (Ptr{vrna_fold_compound_t}, vrna_ud_add_probs_f, vrna_ud_get_probs_f), fc, setter, getter)
end

"""
    pu_contrib

 @brief contributions to p_u
"""
struct pu_contrib
    H::Ptr{Ptr{Cdouble}}
    I::Ptr{Ptr{Cdouble}}
    M::Ptr{Ptr{Cdouble}}
    E::Ptr{Ptr{Cdouble}}
    length::Cint
    w::Cint
end

"""
    interact

 @brief  interaction data structure for RNAup
"""
struct interact
    Pi::Ptr{Cdouble}
    Gi::Ptr{Cdouble}
    Gikjl::Cdouble
    Gikjl_wo::Cdouble
    i::Cint
    k::Cint
    j::Cint
    l::Cint
    length::Cint
end

"""
    pu_out

 @brief  Collection of all free_energy of beeing unpaired values for output
"""
struct pu_out
    len::Cint
    u_vals::Cint
    contribs::Cint
    header::Ptr{Ptr{Cchar}}
    u_values::Ptr{Ptr{Cdouble}}
end

"""
    constrain

 @brief  constraints for cofolding
"""
struct constrain
    indx::Ptr{Cint}
    ptype::Ptr{Cchar}
end

"""
    duplexT

 @brief  Data structure for RNAduplex
"""
struct duplexT
    i::Cint
    j::Cint
    _end::Cint
    structure::Ptr{Cchar}
    energy::Cdouble
    energy_backtrack::Cdouble
    opening_backtrack_x::Cdouble
    opening_backtrack_y::Cdouble
    offset::Cint
    dG1::Cdouble
    dG2::Cdouble
    ddG::Cdouble
    tb::Cint
    te::Cint
    qb::Cint
    qe::Cint
end

"""
    node

 @brief  Data structure for RNAsnoop (fold energy list)
"""
struct node
    k::Cint
    energy::Cint
    next::Ptr{node}
end

"""
 @brief  Data structure for RNAsnoop (fold energy list)
"""
const folden = node

"""
    snoopT

 @brief  Data structure for RNAsnoop
"""
struct snoopT
    i::Cint
    j::Cint
    u::Cint
    structure::Ptr{Cchar}
    energy::Cfloat
    Duplex_El::Cfloat
    Duplex_Er::Cfloat
    Loop_E::Cfloat
    Loop_D::Cfloat
    pscd::Cfloat
    psct::Cfloat
    pscg::Cfloat
    Duplex_Ol::Cfloat
    Duplex_Or::Cfloat
    Duplex_Ot::Cfloat
    fullStemEnergy::Cfloat
end

"""
    dupVar

 @brief  Data structure used in RNApkplex
"""
struct dupVar
    i::Cint
    j::Cint
    _end::Cint
    pk_helix::Ptr{Cchar}
    structure::Ptr{Cchar}
    energy::Cdouble
    offset::Cint
    dG1::Cdouble
    dG2::Cdouble
    ddG::Cdouble
    tb::Cint
    te::Cint
    qb::Cint
    qe::Cint
    inactive::Cint
    processed::Cint
end

"""
    vrna_pairing_probs(fc, structure)

 @name Base pair probabilities and derived computations
 @{
### Prototype
```c
int vrna_pairing_probs(vrna_fold_compound_t *fc, char *structure);
```
"""
function vrna_pairing_probs(fc, structure)
    ccall((:vrna_pairing_probs, libRNA), Cint, (Ptr{vrna_fold_compound_t}, Ptr{Cchar}), fc, structure)
end

"""
    vrna_mean_bp_distance_pr(length, pr)

 @brief Get the mean base pair distance in the thermodynamic ensemble from a probability matrix

 @f[
 <d> = \\sum_{a,b} p_a p_b d(S_a,S_b)
 @f]

 this can be computed from the pair probs @f\$ p_{ij} @f\$ as

 @f[
 <d> = \\sum_{ij} p_{ij}(1-p_{ij})
 @f]

 @param length The length of the sequence
 @param pr     The matrix containing the base pair probabilities
 @return       The mean pair distance of the structure ensemble
### Prototype
```c
double vrna_mean_bp_distance_pr(int length, FLT_OR_DBL *pr);
```
"""
function vrna_mean_bp_distance_pr(length, pr)
    ccall((:vrna_mean_bp_distance_pr, libRNA), Cdouble, (Cint, Ptr{FLT_OR_DBL}), length, pr)
end

"""
    vrna_mean_bp_distance(fc)

 @brief Get the mean base pair distance in the thermodynamic ensemble

 @f[
 <d> = \\sum_{a,b} p_a p_b d(S_a,S_b)
 @f]

 this can be computed from the pair probs @f\$p_{ij}@f\$ as

 @f[
 <d> = \\sum_{ij} p_{ij}(1-p_{ij})
 @f]

 @param fc     The fold compound data structure
 @return       The mean pair distance of the structure ensemble
### Prototype
```c
double vrna_mean_bp_distance(vrna_fold_compound_t *fc);
```
"""
function vrna_mean_bp_distance(fc)
    ccall((:vrna_mean_bp_distance, libRNA), Cdouble, (Ptr{vrna_fold_compound_t},), fc)
end

"""
    vrna_ensemble_defect_pt(fc, pt)

 @brief  Compute the Ensemble Defect for a given target structure provided as a @b vrna_ptable

 Given a target structure @f\$s@f\$, compute the average dissimilarity of a randomly
 drawn structure from the ensemble, i.e.:

 @f[
   ED(s) = 1 - \\frac{1}{n} \\sum_{ij, (i,j) \\in s} p_{ij} - \\frac{1}{n} \\sum_{i}(1 - s_i)q_i
 @f]

 with sequence length @f\$n@f\$, the probability @f\$p_{ij}@f\$ of a base pair @f\$(i,j)@f\$,
 the probability @f\$q_i = 1 - \\sum_j p_{ij}@f\$ of nucleotide @f\$i@f\$ being unpaired, and
 the indicator variable @f\$s_i = 1@f\$ if @f\$\\exists (i,j) \\in s@f\$, and @f\$s_i = 0@f\$ otherwise.

 @pre  The #vrna_fold_compound_t input parameter @p fc must contain a valid base pair
       probability matrix. This means that partition function and base pair probabilities
       must have been computed using @p fc before execution of this function!

 @see vrna_pf(), vrna_pairing_probs(), vrna_ensemble_defect()

 @param  fc          A fold_compound with pre-computed base pair probabilities
 @param  pt          A pair table representing a target structure
 @return             The ensemble defect with respect to the target structure, or -1. upon failure, e.g. pre-conditions are not met
### Prototype
```c
double vrna_ensemble_defect_pt(vrna_fold_compound_t *fc, const short *pt);
```
"""
function vrna_ensemble_defect_pt(fc, pt)
    ccall((:vrna_ensemble_defect_pt, libRNA), Cdouble, (Ptr{vrna_fold_compound_t}, Ptr{Cshort}), fc, pt)
end

"""
    vrna_ensemble_defect(fc, structure)

 @brief  Compute the Ensemble Defect for a given target structure

 This is a wrapper around @b vrna_ensemble_defect_pt().
 Given a target structure @f\$s@f\$, compute the average dissimilarity of a randomly
 drawn structure from the ensemble, i.e.:

 @f[
   ED(s) = 1 - \\frac{1}{n} \\sum_{ij, (i,j) \\in s} p_{ij} - \\frac{1}{n} \\sum_{i}(1 - s_i)q_i
 @f]

 with sequence length @f\$n@f\$, the probability @f\$p_{ij}@f\$ of a base pair @f\$(i,j)@f\$,
 the probability @f\$q_i = 1 - \\sum_j p_{ij}@f\$ of nucleotide @f\$i@f\$ being unpaired, and
 the indicator variable @f\$s_i = 1@f\$ if @f\$\\exists (i,j) \\in s@f\$, and @f\$s_i = 0@f\$ otherwise.

 @pre  The #vrna_fold_compound_t input parameter @p fc must contain a valid base pair
       probability matrix. This means that partition function and base pair probabilities
       must have been computed using @p fc before execution of this function!

 @see vrna_pf(), vrna_pairing_probs(), vrna_ensemble_defect_pt()

 @param  fc          A fold_compound with pre-computed base pair probabilities
 @param  structure   A target structure in dot-bracket notation
 @return             The ensemble defect with respect to the target structure, or -1. upon failure, e.g. pre-conditions are not met
### Prototype
```c
double vrna_ensemble_defect(vrna_fold_compound_t *fc, const char *structure);
```
"""
function vrna_ensemble_defect(fc, structure)
    ccall((:vrna_ensemble_defect, libRNA), Cdouble, (Ptr{vrna_fold_compound_t}, Ptr{Cchar}), fc, structure)
end

"""
    vrna_positional_entropy(fc)

 @brief  Compute a vector of positional entropies

 This function computes the positional entropies from base pair probabilities
 as

 @f[
 S(i) = - \\sum_j p_{ij} \\log(p_{ij}) - q_i \\log(q_i)
 @f]

 with unpaired probabilities @f\$ q_i = 1 - \\sum_j p_{ij} @f\$.

 Low entropy regions have little
 structural flexibility and the reliability of the predicted structure is
 high. High entropy implies many structural alternatives. While these
 alternatives may be functionally important, they make structure prediction
 more difficult and thus less reliable.

 @pre  This function requires pre-computed base pair probabilities! Thus,
       vrna_pf() must be called beforehand.

 @param  fc          A fold_compound with pre-computed base pair probabilities
 @return             A 1-based vector of positional entropies @f\$ S(i) @f\$. (position 0 contains the sequence length)
### Prototype
```c
double * vrna_positional_entropy(vrna_fold_compound_t *fc);
```
"""
function vrna_positional_entropy(fc)
    ccall((:vrna_positional_entropy, libRNA), Ptr{Cdouble}, (Ptr{vrna_fold_compound_t},), fc)
end

"""
    vrna_stack_prob(fc, cutoff)

 @brief  Compute stacking probabilities

 For each possible base pair @f\$(i,j)@f\$, compute the probability of a stack
 @f\$(i,j)@f\$, @f\$(i+1, j-1)@f\$.

 @param  fc      The fold compound data structure with precomputed base pair probabilities
 @param  cutoff  A cutoff value that limits the output to stacks with @f\$ p > \\textrm{cutoff} @f\$.
 @return         A list of stacks with enclosing base pair @f\$(i,j)@f\$ and probabiltiy @f\$ p @f\$
### Prototype
```c
vrna_ep_t * vrna_stack_prob(vrna_fold_compound_t *fc, double cutoff);
```
"""
function vrna_stack_prob(fc, cutoff)
    ccall((:vrna_stack_prob, libRNA), Ptr{vrna_ep_t}, (Ptr{vrna_fold_compound_t}, Cdouble), fc, cutoff)
end

"""
    vrna_pf_dimer_probs(FAB, FA, FB, prAB, prA, prB, Alength, exp_params)

 @brief Compute Boltzmann probabilities of dimerization without homodimers

 Given the pair probabilities and free energies (in the null model) for a
 dimer AB and the two constituent monomers A and B, compute the conditional pair
 probabilities given that a dimer AB actually forms.
 Null model pair probabilities are given as a list as produced by
 vrna_plist_from_probs(), the dimer probabilities 'prAB' are modified in place.

 @param FAB        free energy of dimer AB
 @param FA         free energy of monomer A
 @param FB         free energy of monomer B
 @param prAB       pair probabilities for dimer
 @param prA        pair probabilities monomer
 @param prB        pair probabilities monomer
 @param Alength    Length of molecule A
 @param exp_params The precomputed Boltzmann factors
### Prototype
```c
void vrna_pf_dimer_probs(double FAB, double FA, double FB, vrna_ep_t *prAB, const vrna_ep_t *prA, const vrna_ep_t *prB, int Alength, const vrna_exp_param_t *exp_params);
```
"""
function vrna_pf_dimer_probs(FAB, FA, FB, prAB, prA, prB, Alength, exp_params)
    ccall((:vrna_pf_dimer_probs, libRNA), Cvoid, (Cdouble, Cdouble, Cdouble, Ptr{vrna_ep_t}, Ptr{vrna_ep_t}, Ptr{vrna_ep_t}, Cint, Ptr{vrna_exp_param_t}), FAB, FA, FB, prAB, prA, prB, Alength, exp_params)
end

"""
    vrna_pr_structure(fc, structure)

 @brief Compute the equilibrium probability of a particular secondary structure

 The probability @f\$p(s)@f\$ of a particular secondary structure @f\$s@f\$ can
 be computed as

 @f[
   p(s) = \\frac{exp(-\\beta E(s)}{Z}
 @f]

 from the structures free energy @f\$E(s)@f\$ and the partition function

 @f[
   Z = \\sum_s exp(-\\beta E(s)),\\quad\\mathrm{with}\\quad\\beta = \\frac{1}{RT}
 @f]

 where @f\$R@f\$ is the gas constant and @f\$T@f\$ the thermodynamic temperature.

 @pre  The fold compound @p fc must have went through a call to vrna_pf() to
       fill the dynamic programming matrices with the corresponding partition
       function.

 @param  fc          The fold compound data structure with precomputed partition function
 @param  structure   The secondary structure to compute the probability for in dot-bracket notation
 @return             The probability of the input structure (range @f\$[0:1]@f\$)
### Prototype
```c
double vrna_pr_structure(vrna_fold_compound_t *fc, const char *structure);
```
"""
function vrna_pr_structure(fc, structure)
    ccall((:vrna_pr_structure, libRNA), Cdouble, (Ptr{vrna_fold_compound_t}, Ptr{Cchar}), fc, structure)
end

"""
    vrna_pr_energy(fc, e)


### Prototype
```c
double vrna_pr_energy(vrna_fold_compound_t *fc, double e);
```
"""
function vrna_pr_energy(fc, e)
    ccall((:vrna_pr_energy, libRNA), Cdouble, (Ptr{vrna_fold_compound_t}, Cdouble), fc, e)
end

mutable struct vrna_cstr_s end

const vrna_cstr_t = Ptr{vrna_cstr_s}

"""
    vrna_cstr(size, output)

 @brief  Create a dynamic char * stream data structure

 @see  vrna_cstr_free(), vrna_cstr_close(), vrna_cstr_fflush(), vrna_cstr_discard(), vrna_cstr_printf()

 @param  size    The initial size of the buffer in characters
 @param  output  An optional output file stream handle that is used to write the collected data to (defaults to @em stdout if @em NULL)
### Prototype
```c
vrna_cstr_t vrna_cstr(size_t size, FILE *output);
```
"""
function vrna_cstr(size, output)
    ccall((:vrna_cstr, libRNA), vrna_cstr_t, (Csize_t, Ptr{Libc.FILE}), size, output)
end

"""
    vrna_cstr_discard(buf)

 @brief  Discard the current content of the dynamic char * stream data structure

 @see  vrna_cstr_free(), vrna_cstr_close(), vrna_cstr_fflush(), vrna_cstr_printf()

 @param  buf   The dynamic char * stream data structure to free
### Prototype
```c
void vrna_cstr_discard(struct vrna_cstr_s *buf);
```
"""
function vrna_cstr_discard(buf)
    ccall((:vrna_cstr_discard, libRNA), Cvoid, (Ptr{vrna_cstr_s},), buf)
end

"""
    vrna_cstr_free(buf)

 @brief  Free the memory occupied by a dynamic char * stream data structure

 This function first flushes any remaining character data within the stream
 and then free's the memory occupied by the data structure.

 @see vrna_cstr_close(), vrna_cstr_fflush(), vrna_cstr()

 @param  buf   The dynamic char * stream data structure to free
### Prototype
```c
void vrna_cstr_free(vrna_cstr_t buf);
```
"""
function vrna_cstr_free(buf)
    ccall((:vrna_cstr_free, libRNA), Cvoid, (vrna_cstr_t,), buf)
end

"""
    vrna_cstr_close(buf)

 @brief  Free the memory occupied by a dynamic char * stream and close the output stream

 This function first flushes any remaining character data within the stream
 then closes the attached output file stream (if any), and finally free's the
 memory occupied by the data structure.

 @see vrna_cstr_free(), vrna_cstr_fflush(), vrna_cstr()

 @param  buf   The dynamic char * stream data structure to free
### Prototype
```c
void vrna_cstr_close(vrna_cstr_t buf);
```
"""
function vrna_cstr_close(buf)
    ccall((:vrna_cstr_close, libRNA), Cvoid, (vrna_cstr_t,), buf)
end

"""
    vrna_cstr_fflush(buf)

 @brief  Flush the dynamic char * output stream

 This function flushes the collected char * stream, either by writing
 to the attached file handle, or simply by writing to @em stdout if
 no file handle has been attached upon construction using vrna_cstr().

 @post The stream buffer is empty after execution of this function

 @see  vrna_cstr(), vrna_cstr_close(), vrna_cstr_free()

 @param  buf   The dynamic char * stream data structure to flush
### Prototype
```c
void vrna_cstr_fflush(struct vrna_cstr_s *buf);
```
"""
function vrna_cstr_fflush(buf)
    ccall((:vrna_cstr_fflush, libRNA), Cvoid, (Ptr{vrna_cstr_s},), buf)
end

"""
    vrna_cstr_string(buf)


### Prototype
```c
const char * vrna_cstr_string(vrna_cstr_t buf);
```
"""
function vrna_cstr_string(buf)
    ccall((:vrna_cstr_string, libRNA), Ptr{Cchar}, (vrna_cstr_t,), buf)
end

"""
    vrna_cstr_print_fasta_header(buf, head)


### Prototype
```c
void vrna_cstr_print_fasta_header(vrna_cstr_t buf, const char *head);
```
"""
function vrna_cstr_print_fasta_header(buf, head)
    ccall((:vrna_cstr_print_fasta_header, libRNA), Cvoid, (vrna_cstr_t, Ptr{Cchar}), buf, head)
end

"""
    vrna_cstr_print_eval_sd_corr(buf)


### Prototype
```c
void vrna_cstr_print_eval_sd_corr(struct vrna_cstr_s *buf);
```
"""
function vrna_cstr_print_eval_sd_corr(buf)
    ccall((:vrna_cstr_print_eval_sd_corr, libRNA), Cvoid, (Ptr{vrna_cstr_s},), buf)
end

"""
    vrna_cstr_print_eval_ext_loop(buf, energy)


### Prototype
```c
void vrna_cstr_print_eval_ext_loop(struct vrna_cstr_s *buf, int energy);
```
"""
function vrna_cstr_print_eval_ext_loop(buf, energy)
    ccall((:vrna_cstr_print_eval_ext_loop, libRNA), Cvoid, (Ptr{vrna_cstr_s}, Cint), buf, energy)
end

"""
    vrna_cstr_print_eval_hp_loop(buf, i, j, si, sj, energy)


### Prototype
```c
void vrna_cstr_print_eval_hp_loop(struct vrna_cstr_s *buf, int i, int j, char si, char sj, int energy);
```
"""
function vrna_cstr_print_eval_hp_loop(buf, i, j, si, sj, energy)
    ccall((:vrna_cstr_print_eval_hp_loop, libRNA), Cvoid, (Ptr{vrna_cstr_s}, Cint, Cint, Cchar, Cchar, Cint), buf, i, j, si, sj, energy)
end

"""
    vrna_cstr_print_eval_hp_loop_revert(buf, i, j, si, sj, energy)


### Prototype
```c
void vrna_cstr_print_eval_hp_loop_revert(struct vrna_cstr_s *buf, int i, int j, char si, char sj, int energy);
```
"""
function vrna_cstr_print_eval_hp_loop_revert(buf, i, j, si, sj, energy)
    ccall((:vrna_cstr_print_eval_hp_loop_revert, libRNA), Cvoid, (Ptr{vrna_cstr_s}, Cint, Cint, Cchar, Cchar, Cint), buf, i, j, si, sj, energy)
end

"""
    vrna_cstr_print_eval_int_loop(buf, i, j, si, sj, k, l, sk, sl, energy)


### Prototype
```c
void vrna_cstr_print_eval_int_loop(struct vrna_cstr_s *buf, int i, int j, char si, char sj, int k, int l, char sk, char sl, int energy);
```
"""
function vrna_cstr_print_eval_int_loop(buf, i, j, si, sj, k, l, sk, sl, energy)
    ccall((:vrna_cstr_print_eval_int_loop, libRNA), Cvoid, (Ptr{vrna_cstr_s}, Cint, Cint, Cchar, Cchar, Cint, Cint, Cchar, Cchar, Cint), buf, i, j, si, sj, k, l, sk, sl, energy)
end

"""
    vrna_cstr_print_eval_int_loop_revert(buf, i, j, si, sj, k, l, sk, sl, energy)


### Prototype
```c
void vrna_cstr_print_eval_int_loop_revert(struct vrna_cstr_s *buf, int i, int j, char si, char sj, int k, int l, char sk, char sl, int energy);
```
"""
function vrna_cstr_print_eval_int_loop_revert(buf, i, j, si, sj, k, l, sk, sl, energy)
    ccall((:vrna_cstr_print_eval_int_loop_revert, libRNA), Cvoid, (Ptr{vrna_cstr_s}, Cint, Cint, Cchar, Cchar, Cint, Cint, Cchar, Cchar, Cint), buf, i, j, si, sj, k, l, sk, sl, energy)
end

"""
    vrna_cstr_print_eval_mb_loop(buf, i, j, si, sj, energy)


### Prototype
```c
void vrna_cstr_print_eval_mb_loop(struct vrna_cstr_s *buf, int i, int j, char si, char sj, int energy);
```
"""
function vrna_cstr_print_eval_mb_loop(buf, i, j, si, sj, energy)
    ccall((:vrna_cstr_print_eval_mb_loop, libRNA), Cvoid, (Ptr{vrna_cstr_s}, Cint, Cint, Cchar, Cchar, Cint), buf, i, j, si, sj, energy)
end

"""
    vrna_cstr_print_eval_mb_loop_revert(buf, i, j, si, sj, energy)


### Prototype
```c
void vrna_cstr_print_eval_mb_loop_revert(struct vrna_cstr_s *buf, int i, int j, char si, char sj, int energy);
```
"""
function vrna_cstr_print_eval_mb_loop_revert(buf, i, j, si, sj, energy)
    ccall((:vrna_cstr_print_eval_mb_loop_revert, libRNA), Cvoid, (Ptr{vrna_cstr_s}, Cint, Cint, Cchar, Cchar, Cint), buf, i, j, si, sj, energy)
end

"""
    vrna_cstr_print_eval_gquad(buf, i, L, l, energy)


### Prototype
```c
void vrna_cstr_print_eval_gquad(struct vrna_cstr_s *buf, int i, int L, int l[3], int energy);
```
"""
function vrna_cstr_print_eval_gquad(buf, i, L, l, energy)
    ccall((:vrna_cstr_print_eval_gquad, libRNA), Cvoid, (Ptr{vrna_cstr_s}, Cint, Cint, Ptr{Cint}, Cint), buf, i, L, l, energy)
end

"""
    vrna_move_s

@brief   An atomic representation of the transition / move from one structure to its neighbor

 An atomic transition / move may be one of the following:
 - a <strong>base pair insertion</strong>,
 - a <strong>base pair removal</strong>, or
 - a <strong>base pair shift</strong> where an existing base pair changes one of its
   pairing partner.

 These moves are encoded by two integer values that represent the affected 5' and 3'
 nucleotide positions. Furthermore, we use the following convention on the signedness
 of these encodings:
 - both values are positive for <em>insertion moves</em>
 - both values are negative for <em>base pair removals</em>
 - both values have different signedness for <em>shift moves</em>, where the positive
   value indicates the nucleotide that stays constant, and the others absolute value
   is the new pairing partner

 @note   A value of 0 in either field is used as list-end indicator and doesn't represent
         any valid move.
"""
struct vrna_move_s
    pos_5::Cint
    pos_3::Cint
    next::Ptr{Cvoid} # next::Ptr{vrna_move_t}
end

function Base.getproperty(x::vrna_move_s, f::Symbol)
    f === :next && return Ptr{vrna_move_t}(getfield(x, f))
    return getfield(x, f)
end

"""
 @brief  A single move that transforms a secondary structure into one of its neighbors
"""
const vrna_move_t = vrna_move_s

"""
    vrna_move_init(pos_5, pos_3)

 @brief  Create an atomic move

 @see #vrna_move_s

 @param  pos_5   The 5' position of the move (positive for insertions, negative for removal, any value for shift moves)
 @param  pos_3   The 3' position of the move (positive for insertions, negative for removal, any value for shift moves)
 @return         An atomic move as specified by @p pos_5 and @p pos_3
### Prototype
```c
vrna_move_t vrna_move_init(int pos_5, int pos_3);
```
"""
function vrna_move_init(pos_5, pos_3)
    ccall((:vrna_move_init, libRNA), vrna_move_t, (Cint, Cint), pos_5, pos_3)
end

"""
    vrna_move_list_free(moves)

delete all moves in a zero terminated list.
### Prototype
```c
void vrna_move_list_free(vrna_move_t *moves);
```
"""
function vrna_move_list_free(moves)
    ccall((:vrna_move_list_free, libRNA), Cvoid, (Ptr{vrna_move_t},), moves)
end

"""
    vrna_move_apply(pt, m)

@brief Apply a particular move / transition to a secondary structure, i.e. transform a structure

@param[in,out] pt The pair table representation of the secondary structure
@param[in]     m  The move to apply
### Prototype
```c
void vrna_move_apply(short *pt, const vrna_move_t *m);
```
"""
function vrna_move_apply(pt, m)
    ccall((:vrna_move_apply, libRNA), Cvoid, (Ptr{Cshort}, Ptr{vrna_move_t}), pt, m)
end

"""
    vrna_move_apply_db(structure, pt, m)


### Prototype
```c
void vrna_move_apply_db(char *structure, const short *pt, const vrna_move_t *m);
```
"""
function vrna_move_apply_db(structure, pt, m)
    ccall((:vrna_move_apply_db, libRNA), Cvoid, (Ptr{Cchar}, Ptr{Cshort}, Ptr{vrna_move_t}), structure, pt, m)
end

"""
    vrna_move_is_removal(m)

 @brief  Test whether a move is a base pair removal

 @param  m   The move to test against
 @return     Non-zero if the move is a base pair removal, 0 otherwise
### Prototype
```c
int vrna_move_is_removal(const vrna_move_t *m);
```
"""
function vrna_move_is_removal(m)
    ccall((:vrna_move_is_removal, libRNA), Cint, (Ptr{vrna_move_t},), m)
end

"""
    vrna_move_is_insertion(m)

 @brief  Test whether a move is a base pair insertion

 @param  m   The move to test against
 @return     Non-zero if the move is a base pair insertion, 0 otherwise
### Prototype
```c
int vrna_move_is_insertion(const vrna_move_t *m);
```
"""
function vrna_move_is_insertion(m)
    ccall((:vrna_move_is_insertion, libRNA), Cint, (Ptr{vrna_move_t},), m)
end

"""
    vrna_move_is_shift(m)

 @brief  Test whether a move is a base pair shift

 @param  m   The move to test against
 @return     Non-zero if the move is a base pair shift, 0 otherwise
### Prototype
```c
int vrna_move_is_shift(const vrna_move_t *m);
```
"""
function vrna_move_is_shift(m)
    ccall((:vrna_move_is_shift, libRNA), Cint, (Ptr{vrna_move_t},), m)
end

"""
    vrna_move_compare(m, b, pt)

 @brief  Compare two moves

 The function compares two moves @p m and @p b and returns
 whether move @p m is lexicographically smaller (-1), larger (1)
 or equal to move @p b.

 If any of the moves @p m or @p b is a shift move, this
 comparison only makes sense in a structure context. Thus,
 the third argument with the current structure must be provided.

 @note    This function returns 0 (equality) upon any error, e.g. missing input

 @warning Currently, shift moves are not supported!

 @param    m   The first move of the comparison
 @param    b   The second move of the comparison
 @param    pt  The pair table of the current structure that is compatible with both moves (maybe NULL if moves are guaranteed to be no shifts)
 @return       -1 if @p m < @p b, 1 if @p m > @p b, 0 otherwise
### Prototype
```c
int vrna_move_compare(const vrna_move_t *m, const vrna_move_t *b, const short *pt);
```
"""
function vrna_move_compare(m, b, pt)
    ccall((:vrna_move_compare, libRNA), Cint, (Ptr{vrna_move_t}, Ptr{vrna_move_t}, Ptr{Cshort}), m, b, pt)
end

"""
    vrna_eval_structure(fc, structure)

 @brief Calculate the free energy of an already folded RNA

 This function allows for energy evaluation of a given pair of structure
 and sequence (alignment).
 Model details, energy parameters, and possibly soft constraints are used as provided
 via the parameter 'fc'. The #vrna_fold_compound_t does not need to contain any DP matrices,
 but requires all most basic init values as one would get from a call like this:
 @code{.c}
fc = vrna_fold_compound(sequence, NULL, VRNA_OPTION_EVAL_ONLY);
 @endcode

 @note Accepts vrna_fold_compound_t of type #VRNA_FC_TYPE_SINGLE and #VRNA_FC_TYPE_COMPARATIVE

 @see  vrna_eval_structure_pt(), vrna_eval_structure_verbose(), vrna_eval_structure_pt_verbose(),
       vrna_fold_compound(), vrna_fold_compound_comparative(), vrna_eval_covar_structure()

 @param fc               A vrna_fold_compound_t containing the energy parameters and model details
 @param structure        Secondary structure in dot-bracket notation
 @return                 The free energy of the input structure given the input sequence in kcal/mol
### Prototype
```c
float vrna_eval_structure(vrna_fold_compound_t *fc, const char *structure);
```
"""
function vrna_eval_structure(fc, structure)
    ccall((:vrna_eval_structure, libRNA), Cfloat, (Ptr{vrna_fold_compound_t}, Ptr{Cchar}), fc, structure)
end

"""
    vrna_eval_covar_structure(fc, structure)

 @brief Calculate the pseudo energy derived by the covariance scores of a set of aligned sequences

 Consensus structure prediction is driven by covariance scores of base pairs in rows of the
 provided alignment. This function allows one to retrieve the total amount of this covariance pseudo
 energy scores.
 The #vrna_fold_compound_t does not need to contain any DP matrices, but requires all most basic
 init values as one would get from a call like this:
 @code{.c}
fc = vrna_fold_compound_comparative(alignment, NULL, VRNA_OPTION_EVAL_ONLY);
 @endcode

 @note Accepts vrna_fold_compound_t of type #VRNA_FC_TYPE_COMPARATIVE only!

 @see  vrna_fold_compound_comparative(), vrna_eval_structure()

 @param fc               A vrna_fold_compound_t containing the energy parameters and model details
 @param structure        Secondary (consensus) structure in dot-bracket notation
 @return                 The covariance pseudo energy score of the input structure given the input sequence alignment in kcal/mol
### Prototype
```c
float vrna_eval_covar_structure(vrna_fold_compound_t *fc, const char *structure);
```
"""
function vrna_eval_covar_structure(fc, structure)
    ccall((:vrna_eval_covar_structure, libRNA), Cfloat, (Ptr{vrna_fold_compound_t}, Ptr{Cchar}), fc, structure)
end

"""
    vrna_eval_structure_verbose(fc, structure, file)

 @brief Calculate the free energy of an already folded RNA and print contributions on a per-loop base.

 This function is a simplyfied version of vrna_eval_structure_v() that uses the @em default
 verbosity level.

 @see vrna_eval_structure_pt(), vrna_eval_structure_verbose(), vrna_eval_structure_pt_verbose(),

 @param fc               A vrna_fold_compound_t containing the energy parameters and model details
 @param structure        Secondary structure in dot-bracket notation
 @param file             A file handle where this function should print to (may be NULL).
 @return                 The free energy of the input structure given the input sequence in kcal/mol
### Prototype
```c
float vrna_eval_structure_verbose(vrna_fold_compound_t *fc, const char *structure, FILE *file);
```
"""
function vrna_eval_structure_verbose(fc, structure, file)
    ccall((:vrna_eval_structure_verbose, libRNA), Cfloat, (Ptr{vrna_fold_compound_t}, Ptr{Cchar}, Ptr{Libc.FILE}), fc, structure, file)
end

"""
    vrna_eval_structure_v(fc, structure, verbosity_level, file)

 @brief Calculate the free energy of an already folded RNA and print contributions on a per-loop base.

 This function allows for detailed energy evaluation of a given sequence/structure pair.
 In contrast to vrna_eval_structure() this function prints detailed energy contributions
 based on individual loops to a file handle. If NULL is passed as file handle, this function
 defaults to print to stdout. Any positive @p verbosity_level activates potential warning message
 of the energy evaluting functions, while values @f\$ \\ge 1 @f\$ allow for detailed control of what
 data is printed. A negative parameter @p verbosity_level turns off printing all together.

 Model details, energy parameters, and possibly soft constraints are used as provided
 via the parameter 'fc'. The fold_compound does not need to contain any DP matrices,
 but all the most basic init values as one would get from a call like this:
 @code{.c}
fc = vrna_fold_compound(sequence, NULL, VRNA_OPTION_EVAL_ONLY);
 @endcode

 @see vrna_eval_structure_pt(), vrna_eval_structure_verbose(), vrna_eval_structure_pt_verbose(),

 @param fc               A vrna_fold_compound_t containing the energy parameters and model details
 @param structure        Secondary structure in dot-bracket notation
 @param verbosity_level  The level of verbosity of this function
 @param file             A file handle where this function should print to (may be NULL).
 @return                 The free energy of the input structure given the input sequence in kcal/mol
### Prototype
```c
float vrna_eval_structure_v(vrna_fold_compound_t *fc, const char *structure, int verbosity_level, FILE *file);
```
"""
function vrna_eval_structure_v(fc, structure, verbosity_level, file)
    ccall((:vrna_eval_structure_v, libRNA), Cfloat, (Ptr{vrna_fold_compound_t}, Ptr{Cchar}, Cint, Ptr{Libc.FILE}), fc, structure, verbosity_level, file)
end

"""
    vrna_eval_structure_cstr(fc, structure, verbosity_level, output_stream)


### Prototype
```c
float vrna_eval_structure_cstr(vrna_fold_compound_t *fc, const char *structure, int verbosity_level, vrna_cstr_t output_stream);
```
"""
function vrna_eval_structure_cstr(fc, structure, verbosity_level, output_stream)
    ccall((:vrna_eval_structure_cstr, libRNA), Cfloat, (Ptr{vrna_fold_compound_t}, Ptr{Cchar}, Cint, vrna_cstr_t), fc, structure, verbosity_level, output_stream)
end

"""
    vrna_eval_structure_pt(fc, pt)

 @brief Calculate the free energy of an already folded RNA

 This function allows for energy evaluation of a given sequence/structure pair where
 the structure is provided in pair_table format as obtained from vrna_ptable().
 Model details, energy parameters, and possibly soft constraints are used as provided
 via the parameter 'fc'. The fold_compound does not need to contain any DP matrices,
 but all the most basic init values as one would get from a call like this:
 @code{.c}
fc = vrna_fold_compound(sequence, NULL, VRNA_OPTION_EVAL_ONLY);
 @endcode

 @see vrna_ptable(), vrna_eval_structure(), vrna_eval_structure_pt_verbose()

 @param fc               A vrna_fold_compound_t containing the energy parameters and model details
 @param pt               Secondary structure as pair_table
 @return                 The free energy of the input structure given the input sequence in 10cal/mol
### Prototype
```c
int vrna_eval_structure_pt(vrna_fold_compound_t *fc, const short *pt);
```
"""
function vrna_eval_structure_pt(fc, pt)
    ccall((:vrna_eval_structure_pt, libRNA), Cint, (Ptr{vrna_fold_compound_t}, Ptr{Cshort}), fc, pt)
end

"""
    vrna_eval_structure_pt_verbose(fc, pt, file)

 @brief Calculate the free energy of an already folded RNA

 This function is a simplyfied version of vrna_eval_structure_simple_v() that uses the @em default
 verbosity level.

 @see vrna_eval_structure_pt_v(), vrna_ptable(), vrna_eval_structure_pt(), vrna_eval_structure_verbose()

 @param fc               A vrna_fold_compound_t containing the energy parameters and model details
 @param pt               Secondary structure as pair_table
 @param file             A file handle where this function should print to (may be NULL).
 @return                 The free energy of the input structure given the input sequence in 10cal/mol
### Prototype
```c
int vrna_eval_structure_pt_verbose(vrna_fold_compound_t *fc, const short *pt, FILE *file);
```
"""
function vrna_eval_structure_pt_verbose(fc, pt, file)
    ccall((:vrna_eval_structure_pt_verbose, libRNA), Cint, (Ptr{vrna_fold_compound_t}, Ptr{Cshort}, Ptr{Libc.FILE}), fc, pt, file)
end

"""
    vrna_eval_structure_pt_v(fc, pt, verbosity_level, file)

 @brief Calculate the free energy of an already folded RNA

 This function allows for energy evaluation of a given sequence/structure pair where
 the structure is provided in pair_table format as obtained from vrna_ptable().
 Model details, energy parameters, and possibly soft constraints are used as provided
 via the parameter 'fc'. The fold_compound does not need to contain any DP matrices,
 but all the most basic init values as one would get from a call like this:
 @code{.c}
fc = vrna_fold_compound(sequence, NULL, VRNA_OPTION_EVAL_ONLY);
 @endcode
 In contrast to vrna_eval_structure_pt() this function prints detailed energy contributions
 based on individual loops to a file handle. If NULL is passed as file handle, this function
 defaults to print to stdout. Any positive @p verbosity_level activates potential warning message
 of the energy evaluting functions, while values @f\$ \\ge 1 @f\$ allow for detailed control of what
 data is printed. A negative parameter @p verbosity_level turns off printing all together.

 @see vrna_ptable(), vrna_eval_structure_pt(), vrna_eval_structure_verbose()

 @param fc               A vrna_fold_compound_t containing the energy parameters and model details
 @param pt               Secondary structure as pair_table
 @param verbosity_level  The level of verbosity of this function
 @param file             A file handle where this function should print to (may be NULL).
 @return                 The free energy of the input structure given the input sequence in 10cal/mol
### Prototype
```c
int vrna_eval_structure_pt_v(vrna_fold_compound_t *fc, const short *pt, int verbosity_level, FILE *file);
```
"""
function vrna_eval_structure_pt_v(fc, pt, verbosity_level, file)
    ccall((:vrna_eval_structure_pt_v, libRNA), Cint, (Ptr{vrna_fold_compound_t}, Ptr{Cshort}, Cint, Ptr{Libc.FILE}), fc, pt, verbosity_level, file)
end

"""
    vrna_eval_structure_simple(string, structure)

 @brief Calculate the free energy of an already folded RNA

 This function allows for energy evaluation of a given sequence/structure pair.
 In contrast to vrna_eval_structure() this function assumes default model details
 and default energy parameters in order to evaluate the free energy of the secondary
 structure. Therefore, it serves as a simple interface function for energy evaluation
 for situations where no changes on the energy model are required.

 @see vrna_eval_structure(), vrna_eval_structure_pt(), vrna_eval_structure_verbose(), vrna_eval_structure_pt_verbose(),

 @param string           RNA sequence in uppercase letters
 @param structure        Secondary structure in dot-bracket notation
 @return                 The free energy of the input structure given the input sequence in kcal/mol
### Prototype
```c
float vrna_eval_structure_simple(const char *string, const char *structure);
```
"""
function vrna_eval_structure_simple(string, structure)
    ccall((:vrna_eval_structure_simple, libRNA), Cfloat, (Ptr{Cchar}, Ptr{Cchar}), string, structure)
end

"""
    vrna_eval_circ_structure(string, structure)

 @brief  Evaluate the free energy of a sequence/structure pair where the sequence is circular

 @see  vrna_eval_structure_simple(), vrna_eval_gquad_structure(), vrna_eval_circ_consensus_structure(),
       vrna_eval_circ_structure_v(), vrna_eval_structure()

 @param  string    RNA sequence in uppercase letters
 @param  structure Secondary structure in dot-bracket notation
 @return           The free energy of the structure given the circular input sequence in kcal/mol
### Prototype
```c
float vrna_eval_circ_structure(const char *string, const char *structure);
```
"""
function vrna_eval_circ_structure(string, structure)
    ccall((:vrna_eval_circ_structure, libRNA), Cfloat, (Ptr{Cchar}, Ptr{Cchar}), string, structure)
end

"""
    vrna_eval_gquad_structure(string, structure)

 @brief  Evaluate the free energy of a sequence/structure pair where the structure may contain G-Quadruplexes

 G-Quadruplexes are annotated as plus signs ('+') for each G involved in the motif. Linker sequences must
 be denoted by dots ('.') as they are considered unpaired. Below is an example of a 2-layer G-quadruplex:
 @code{.unparsed}
 GGAAGGAAAGGAGG
 ++..++...++.++
 @endcode

 @see  vrna_eval_structure_simple(), vrna_eval_circ_structure(), vrna_eval_gquad_consensus_structure(),
       vrna_eval_gquad_structure_v(), vrna_eval_structure()

 @param  string    RNA sequence in uppercase letters
 @param  structure Secondary structure in dot-bracket notation
 @return           The free energy of the structure including contributions of G-quadruplexes in kcal/mol
### Prototype
```c
float vrna_eval_gquad_structure(const char *string, const char *structure);
```
"""
function vrna_eval_gquad_structure(string, structure)
    ccall((:vrna_eval_gquad_structure, libRNA), Cfloat, (Ptr{Cchar}, Ptr{Cchar}), string, structure)
end

"""
    vrna_eval_circ_gquad_structure(string, structure)

 @brief  Evaluate the free energy of a sequence/structure pair where the sequence is circular and
         the structure may contain G-Quadruplexes

 G-Quadruplexes are annotated as plus signs ('+') for each G involved in the motif. Linker sequences must
 be denoted by dots ('.') as they are considered unpaired. Below is an example of a 2-layer G-quadruplex:
 @code{.unparsed}
 GGAAGGAAAGGAGG
 ++..++...++.++
 @endcode

 @see  vrna_eval_structure_simple(), vrna_eval_circ_gquad_consensus_structure(),
       vrna_eval_circ_gquad_structure_v(), vrna_eval_structure()

 @param  string    RNA sequence in uppercase letters
 @param  structure Secondary structure in dot-bracket notation
 @return           The free energy of the structure including contributions of G-quadruplexes in kcal/mol
### Prototype
```c
float vrna_eval_circ_gquad_structure(const char *string, const char *structure);
```
"""
function vrna_eval_circ_gquad_structure(string, structure)
    ccall((:vrna_eval_circ_gquad_structure, libRNA), Cfloat, (Ptr{Cchar}, Ptr{Cchar}), string, structure)
end

"""
    vrna_eval_structure_simple_verbose(string, structure, file)

 @brief Calculate the free energy of an already folded RNA and print contributions per loop.

 This function is a simplyfied version of vrna_eval_structure_simple_v() that uses the @em default
 verbosity level.

 @see  vrna_eval_structure_simple_v(), vrna_eval_structure_verbose(), vrna_eval_structure_pt(),
       vrna_eval_structure_verbose(), vrna_eval_structure_pt_verbose()

 @param string           RNA sequence in uppercase letters
 @param structure        Secondary structure in dot-bracket notation
 @param file             A file handle where this function should print to (may be NULL).
 @return                 The free energy of the input structure given the input sequence in kcal/mol
### Prototype
```c
float vrna_eval_structure_simple_verbose(const char *string, const char *structure, FILE *file);
```
"""
function vrna_eval_structure_simple_verbose(string, structure, file)
    ccall((:vrna_eval_structure_simple_verbose, libRNA), Cfloat, (Ptr{Cchar}, Ptr{Cchar}, Ptr{Libc.FILE}), string, structure, file)
end

"""
    vrna_eval_structure_simple_v(string, structure, verbosity_level, file)

 @brief Calculate the free energy of an already folded RNA and print contributions per loop.

 This function allows for detailed energy evaluation of a given sequence/structure pair.
 In contrast to vrna_eval_structure() this function prints detailed energy contributions
 based on individual loops to a file handle. If NULL is passed as file handle, this function
 defaults to print to stdout. Any positive @p verbosity_level activates potential warning message
 of the energy evaluting functions, while values @f\$ \\ge 1 @f\$ allow for detailed control of what
 data is printed. A negative parameter @p verbosity_level turns off printing all together.

 In contrast to vrna_eval_structure_verbose() this function assumes default model details
 and default energy parameters in order to evaluate the free energy of the secondary
 structure. Threefore, it serves as a simple interface function for energy evaluation
 for situations where no changes on the energy model are required.

 @see vrna_eval_structure_verbose(), vrna_eval_structure_pt(), vrna_eval_structure_pt_verbose(),

 @param string           RNA sequence in uppercase letters
 @param structure        Secondary structure in dot-bracket notation
 @param verbosity_level  The level of verbosity of this function
 @param file             A file handle where this function should print to (may be NULL).
 @return                 The free energy of the input structure given the input sequence in kcal/mol
### Prototype
```c
float vrna_eval_structure_simple_v(const char *string, const char *structure, int verbosity_level, FILE *file);
```
"""
function vrna_eval_structure_simple_v(string, structure, verbosity_level, file)
    ccall((:vrna_eval_structure_simple_v, libRNA), Cfloat, (Ptr{Cchar}, Ptr{Cchar}, Cint, Ptr{Libc.FILE}), string, structure, verbosity_level, file)
end

"""
    vrna_eval_circ_structure_v(string, structure, verbosity_level, file)

 @brief  Evaluate free energy of a sequence/structure pair, assume sequence to be circular and
         print contributions per loop

 This function is the same as vrna_eval_structure_simple_v() but assumes the input sequence
 to be circularized.

 @see  vrna_eval_structure_simple_v(), vrna_eval_circ_structure(), vrna_eval_structure_verbose()

 @param string           RNA sequence in uppercase letters
 @param structure        Secondary structure in dot-bracket notation
 @param verbosity_level  The level of verbosity of this function
 @param file             A file handle where this function should print to (may be NULL).
 @return                 The free energy of the input structure given the input sequence in kcal/mol
### Prototype
```c
float vrna_eval_circ_structure_v(const char *string, const char *structure, int verbosity_level, FILE *file);
```
"""
function vrna_eval_circ_structure_v(string, structure, verbosity_level, file)
    ccall((:vrna_eval_circ_structure_v, libRNA), Cfloat, (Ptr{Cchar}, Ptr{Cchar}, Cint, Ptr{Libc.FILE}), string, structure, verbosity_level, file)
end

"""
    vrna_eval_gquad_structure_v(string, structure, verbosity_level, file)

 @brief  Evaluate free energy of a sequence/structure pair, allow for G-Quadruplexes in the structure
         and print contributions per loop

 This function is the same as vrna_eval_structure_simple_v() but allows for annotated G-Quadruplexes
 in the dot-bracket structure input.

 G-Quadruplexes are annotated as plus signs ('+') for each G involved in the motif. Linker sequences must
 be denoted by dots ('.') as they are considered unpaired. Below is an example of a 2-layer G-quadruplex:
 @code{.unparsed}
 GGAAGGAAAGGAGG
 ++..++...++.++
 @endcode

 @see  vrna_eval_structure_simple_v(), vrna_eval_gquad_structure(), vrna_eval_structure_verbose()

 @param string           RNA sequence in uppercase letters
 @param structure        Secondary structure in dot-bracket notation
 @param verbosity_level  The level of verbosity of this function
 @param file             A file handle where this function should print to (may be NULL).
 @return                 The free energy of the input structure given the input sequence in kcal/mol
### Prototype
```c
float vrna_eval_gquad_structure_v(const char *string, const char *structure, int verbosity_level, FILE *file);
```
"""
function vrna_eval_gquad_structure_v(string, structure, verbosity_level, file)
    ccall((:vrna_eval_gquad_structure_v, libRNA), Cfloat, (Ptr{Cchar}, Ptr{Cchar}, Cint, Ptr{Libc.FILE}), string, structure, verbosity_level, file)
end

"""
    vrna_eval_circ_gquad_structure_v(string, structure, verbosity_level, file)

 @brief  Evaluate free energy of a sequence/structure pair, assume sequence to be circular, allow
         for G-Quadruplexes in the structure, and print contributions per loop

 This function is the same as vrna_eval_structure_simple_v() but assumes the input sequence to
 be circular and allows for annotated G-Quadruplexes in the dot-bracket structure input.

 G-Quadruplexes are annotated as plus signs ('+') for each G involved in the motif. Linker sequences must
 be denoted by dots ('.') as they are considered unpaired. Below is an example of a 2-layer G-quadruplex:
 @code{.unparsed}
 GGAAGGAAAGGAGG
 ++..++...++.++
 @endcode

 @param string           RNA sequence in uppercase letters
 @param structure        Secondary structure in dot-bracket notation
 @param verbosity_level  The level of verbosity of this function
 @param file             A file handle where this function should print to (may be NULL).
 @return                 The free energy of the input structure given the input sequence in kcal/mol
### Prototype
```c
float vrna_eval_circ_gquad_structure_v(const char *string, const char *structure, int verbosity_level, FILE *file);
```
"""
function vrna_eval_circ_gquad_structure_v(string, structure, verbosity_level, file)
    ccall((:vrna_eval_circ_gquad_structure_v, libRNA), Cfloat, (Ptr{Cchar}, Ptr{Cchar}, Cint, Ptr{Libc.FILE}), string, structure, verbosity_level, file)
end

"""
    vrna_eval_consensus_structure_simple(alignment, structure)

 @brief Calculate the free energy of an already folded RNA sequence alignment

 This function allows for energy evaluation for a given multiple sequence alignment
 and consensus structure pair.
 In contrast to vrna_eval_structure() this function assumes default model details
 and default energy parameters in order to evaluate the free energy of the secondary
 structure. Therefore, it serves as a simple interface function for energy evaluation
 for situations where no changes on the energy model are required.

 @note The free energy returned from this function already includes the covariation
       pseudo energies that is used fir comparative structure prediction within this
       library.

 @see  vrna_eval_covar_structure(), vrna_eval_structure(), vrna_eval_structure_pt(),
       vrna_eval_structure_verbose(), vrna_eval_structure_pt_verbose()

 @param alignment        RNA sequence alignment in uppercase letters and hyphen ('-') to denote gaps
 @param structure        Consensus Secondary structure in dot-bracket notation
 @return                 The free energy of the consensus structure given the input alignment in kcal/mol
### Prototype
```c
float vrna_eval_consensus_structure_simple(const char **alignment, const char *structure);
```
"""
function vrna_eval_consensus_structure_simple(alignment, structure)
    ccall((:vrna_eval_consensus_structure_simple, libRNA), Cfloat, (Ptr{Ptr{Cchar}}, Ptr{Cchar}), alignment, structure)
end

"""
    vrna_eval_circ_consensus_structure(alignment, structure)

 @brief  Evaluate the free energy of a multiple sequence alignment/consensus structure pair
         where the sequences are circular

 @note The free energy returned from this function already includes the covariation
       pseudo energies that is used fir comparative structure prediction within this
       library.

 @see  vrna_eval_covar_structure(), vrna_eval_consensus_structure_simple(), vrna_eval_gquad_consensus_structure(),
       vrna_eval_circ_structure(), vrna_eval_circ_consensus_structure_v(), vrna_eval_structure()

 @param  alignment RNA sequence alignment in uppercase letters
 @param  structure Consensus secondary structure in dot-bracket notation
 @return           The free energy of the consensus structure given the circular input sequence in kcal/mol
### Prototype
```c
float vrna_eval_circ_consensus_structure(const char **alignment, const char *structure);
```
"""
function vrna_eval_circ_consensus_structure(alignment, structure)
    ccall((:vrna_eval_circ_consensus_structure, libRNA), Cfloat, (Ptr{Ptr{Cchar}}, Ptr{Cchar}), alignment, structure)
end

"""
    vrna_eval_gquad_consensus_structure(alignment, structure)

 @brief  Evaluate the free energy of a multiple sequence alignment/consensus structure pair
         where the structure may contain G-Quadruplexes

 G-Quadruplexes are annotated as plus signs ('+') for each G involved in the motif. Linker sequences must
 be denoted by dots ('.') as they are considered unpaired. Below is an example of a 2-layer G-quadruplex:
 @code{.unparsed}
 GGAAGGAAAGGAGG
 ++..++...++.++
 @endcode

 @note The free energy returned from this function already includes the covariation
       pseudo energies that is used fir comparative structure prediction within this
       library.

 @see  vrna_eval_covar_structure(), vrna_eval_consensus_structure_simple(), vrna_eval_circ_consensus_structure(),
       vrna_eval_gquad_structure(), vrna_eval_gquad_consensus_structure_v(), vrna_eval_structure()

 @param  alignment RNA sequence alignment in uppercase letters
 @param  structure Consensus secondary structure in dot-bracket notation
 @return           The free energy of the consensus structure including contributions of G-quadruplexes in kcal/mol
### Prototype
```c
float vrna_eval_gquad_consensus_structure(const char **alignment, const char *structure);
```
"""
function vrna_eval_gquad_consensus_structure(alignment, structure)
    ccall((:vrna_eval_gquad_consensus_structure, libRNA), Cfloat, (Ptr{Ptr{Cchar}}, Ptr{Cchar}), alignment, structure)
end

"""
    vrna_eval_circ_gquad_consensus_structure(alignment, structure)

 @brief  Evaluate the free energy of a multiple sequence alignment/consensus structure pair
         where the sequence is circular and the structure may contain G-Quadruplexes

 G-Quadruplexes are annotated as plus signs ('+') for each G involved in the motif. Linker sequences must
 be denoted by dots ('.') as they are considered unpaired. Below is an example of a 2-layer G-quadruplex:
 @code{.unparsed}
 GGAAGGAAAGGAGG
 ++..++...++.++
 @endcode

 @note The free energy returned from this function already includes the covariation
       pseudo energies that is used fir comparative structure prediction within this
       library.

 @see  vrna_eval_covar_structure(), vrna_eval_consensus_structure_simple(), vrna_eval_circ_consensus_structure(),
       vrna_eval_gquad_structure(), vrna_eval_circ_gquad_consensus_structure_v(), vrna_eval_structure()

 @param  alignment RNA sequence alignment in uppercase letters
 @param  structure Consensus secondary structure in dot-bracket notation
 @return           The free energy of the consensus structure including contributions of G-quadruplexes in kcal/mol
### Prototype
```c
float vrna_eval_circ_gquad_consensus_structure(const char **alignment, const char *structure);
```
"""
function vrna_eval_circ_gquad_consensus_structure(alignment, structure)
    ccall((:vrna_eval_circ_gquad_consensus_structure, libRNA), Cfloat, (Ptr{Ptr{Cchar}}, Ptr{Cchar}), alignment, structure)
end

"""
    vrna_eval_consensus_structure_simple_verbose(alignment, structure, file)

 @brief  Evaluate the free energy of a consensus structure for an RNA sequence alignment and print
         contributions per loop.

 This function is a simplyfied version of vrna_eval_consensus_structure_simple_v() that uses the
 @em default verbosity level.

 @note The free energy returned from this function already includes the covariation
       pseudo energies that is used fir comparative structure prediction within this
       library.

 @see  vrna_eval_consensus_structure_simple_v(), vrna_eval_structure_verbose(), vrna_eval_structure_pt(),
       vrna_eval_structure_pt_verbose()

 @param alignment        RNA sequence alignment in uppercase letters. Gaps are denoted by hyphens ('-')
 @param structure        Consensus secondary structure in dot-bracket notation
 @param file             A file handle where this function should print to (may be NULL).
 @return                 The free energy of the conensus structure given the aligned input sequences in kcal/mol
### Prototype
```c
float vrna_eval_consensus_structure_simple_verbose(const char **alignment, const char *structure, FILE *file);
```
"""
function vrna_eval_consensus_structure_simple_verbose(alignment, structure, file)
    ccall((:vrna_eval_consensus_structure_simple_verbose, libRNA), Cfloat, (Ptr{Ptr{Cchar}}, Ptr{Cchar}, Ptr{Libc.FILE}), alignment, structure, file)
end

"""
    vrna_eval_consensus_structure_simple_v(alignment, structure, verbosity_level, file)

 @brief  Evaluate the free energy of a consensus structure for an RNA sequence alignment and print
         contributions per loop.

 This function allows for detailed energy evaluation of a given sequence alignment/consensus
 structure pair. In contrast to vrna_eval_consensus_structure_simple() this function prints
 detailed energy contributions based on individual loops to a file handle. If NULL is passed
 as file handle, this function defaults to print to stdout. Any positive @p verbosity_level
 activates potential warning message of the energy evaluting functions, while values @f\$ \\ge 1 @f\$
 allow for detailed control of what data is printed. A negative parameter @p verbosity_level
 turns off printing all together.

 @note The free energy returned from this function already includes the covariation
       pseudo energies that is used fir comparative structure prediction within this
       library.

 @see vrna_eval_consensus_structure(), vrna_eval_structure()

 @param alignment        RNA sequence alignment in uppercase letters. Gaps are denoted by hyphens ('-')
 @param structure        Consensus secondary structure in dot-bracket notation
 @param verbosity_level  The level of verbosity of this function
 @param file             A file handle where this function should print to (may be NULL).
 @return                 The free energy of the consensus structure given the sequence alignment in kcal/mol
### Prototype
```c
float vrna_eval_consensus_structure_simple_v(const char **alignment, const char *structure, int verbosity_level, FILE *file);
```
"""
function vrna_eval_consensus_structure_simple_v(alignment, structure, verbosity_level, file)
    ccall((:vrna_eval_consensus_structure_simple_v, libRNA), Cfloat, (Ptr{Ptr{Cchar}}, Ptr{Cchar}, Cint, Ptr{Libc.FILE}), alignment, structure, verbosity_level, file)
end

"""
    vrna_eval_circ_consensus_structure_v(alignment, structure, verbosity_level, file)

 @brief  Evaluate the free energy of a consensus structure for an alignment of circular RNA sequences
         and print contributions per loop.

 This function is identical with vrna_eval_consensus_structure_simple_v() but assumed the
 aligned sequences to be circular.

 @note The free energy returned from this function already includes the covariation
       pseudo energies that is used fir comparative structure prediction within this
       library.

 @see vrna_eval_consensus_structure_simple_v(), vrna_eval_circ_consensus_structure(), vrna_eval_structure()

 @param alignment        RNA sequence alignment in uppercase letters. Gaps are denoted by hyphens ('-')
 @param structure        Consensus secondary structure in dot-bracket notation
 @param verbosity_level  The level of verbosity of this function
 @param file             A file handle where this function should print to (may be NULL).
 @return                 The free energy of the consensus structure given the sequence alignment in kcal/mol
### Prototype
```c
float vrna_eval_circ_consensus_structure_v(const char **alignment, const char *structure, int verbosity_level, FILE *file);
```
"""
function vrna_eval_circ_consensus_structure_v(alignment, structure, verbosity_level, file)
    ccall((:vrna_eval_circ_consensus_structure_v, libRNA), Cfloat, (Ptr{Ptr{Cchar}}, Ptr{Cchar}, Cint, Ptr{Libc.FILE}), alignment, structure, verbosity_level, file)
end

"""
    vrna_eval_gquad_consensus_structure_v(alignment, structure, verbosity_level, file)

 @brief  Evaluate the free energy of a consensus structure for an RNA sequence alignment, allow for
         annotated G-Quadruplexes in the structure and print contributions per loop.

 This function is identical with vrna_eval_consensus_structure_simple_v() but allows for annotated
 G-Quadruplexes in the consensus structure.

 G-Quadruplexes are annotated as plus signs ('+') for each G involved in the motif. Linker sequences must
 be denoted by dots ('.') as they are considered unpaired. Below is an example of a 2-layer G-quadruplex:
 @code{.unparsed}
 GGAAGGAAAGGAGG
 ++..++...++.++
 @endcode

 @note The free energy returned from this function already includes the covariation
       pseudo energies that is used fir comparative structure prediction within this
       library.

 @see vrna_eval_consensus_structure_simple_v(), vrna_eval_gquad_consensus_structure(), vrna_eval_structure()

 @param alignment        RNA sequence alignment in uppercase letters. Gaps are denoted by hyphens ('-')
 @param structure        Consensus secondary structure in dot-bracket notation
 @param verbosity_level  The level of verbosity of this function
 @param file             A file handle where this function should print to (may be NULL).
 @return                 The free energy of the consensus structure given the sequence alignment in kcal/mol
### Prototype
```c
float vrna_eval_gquad_consensus_structure_v(const char **alignment, const char *structure, int verbosity_level, FILE *file);
```
"""
function vrna_eval_gquad_consensus_structure_v(alignment, structure, verbosity_level, file)
    ccall((:vrna_eval_gquad_consensus_structure_v, libRNA), Cfloat, (Ptr{Ptr{Cchar}}, Ptr{Cchar}, Cint, Ptr{Libc.FILE}), alignment, structure, verbosity_level, file)
end

"""
    vrna_eval_circ_gquad_consensus_structure_v(alignment, structure, verbosity_level, file)

 @brief  Evaluate the free energy of a consensus structure for an alignment of circular RNA sequences,
         allow for annotated G-Quadruplexes in the structure and print contributions per loop.

 This function is identical with vrna_eval_consensus_structure_simple_v() but assumes the sequences in
 the alignment to be circular and allows for annotated G-Quadruplexes in the consensus structure.

 G-Quadruplexes are annotated as plus signs ('+') for each G involved in the motif. Linker sequences must
 be denoted by dots ('.') as they are considered unpaired. Below is an example of a 2-layer G-quadruplex:
 @code{.unparsed}
 GGAAGGAAAGGAGG
 ++..++...++.++
 @endcode

 @note The free energy returned from this function already includes the covariation
       pseudo energies that is used fir comparative structure prediction within this
       library.

 @see vrna_eval_consensus_structure_simple_v(), vrna_eval_circ_gquad_consensus_structure(), vrna_eval_structure()

 @param alignment        RNA sequence alignment in uppercase letters. Gaps are denoted by hyphens ('-')
 @param structure        Consensus secondary structure in dot-bracket notation
 @param verbosity_level  The level of verbosity of this function
 @param file             A file handle where this function should print to (may be NULL).
 @return                 The free energy of the consensus structure given the sequence alignment in kcal/mol
### Prototype
```c
float vrna_eval_circ_gquad_consensus_structure_v(const char **alignment, const char *structure, int verbosity_level, FILE *file);
```
"""
function vrna_eval_circ_gquad_consensus_structure_v(alignment, structure, verbosity_level, file)
    ccall((:vrna_eval_circ_gquad_consensus_structure_v, libRNA), Cfloat, (Ptr{Ptr{Cchar}}, Ptr{Cchar}, Cint, Ptr{Libc.FILE}), alignment, structure, verbosity_level, file)
end

"""
    vrna_eval_structure_pt_simple(string, pt)

 @brief Calculate the free energy of an already folded RNA

 In contrast to vrna_eval_structure_pt() this function assumes default model details
 and default energy parameters in order to evaluate the free energy of the secondary
 structure. Threefore, it serves as a simple interface function for energy evaluation
 for situations where no changes on the energy model are required.

 @see vrna_ptable(), vrna_eval_structure_simple(), vrna_eval_structure_pt()

 @param string           RNA sequence in uppercase letters
 @param pt               Secondary structure as pair_table
 @return                 The free energy of the input structure given the input sequence in 10cal/mol
### Prototype
```c
int vrna_eval_structure_pt_simple(const char *string, const short *pt);
```
"""
function vrna_eval_structure_pt_simple(string, pt)
    ccall((:vrna_eval_structure_pt_simple, libRNA), Cint, (Ptr{Cchar}, Ptr{Cshort}), string, pt)
end

"""
    vrna_eval_structure_pt_simple_verbose(string, pt, file)

 @brief Calculate the free energy of an already folded RNA

 This function is a simplyfied version of vrna_eval_structure_pt_simple_v() that uses the @em default
 verbosity level.

 @see vrna_eval_structure_pt_simple_v(), vrna_ptable(), vrna_eval_structure_pt_verbose(), vrna_eval_structure_simple()

 @param string           RNA sequence in uppercase letters
 @param pt               Secondary structure as pair_table
 @param file             A file handle where this function should print to (may be NULL).
 @return                 The free energy of the input structure given the input sequence in 10cal/mol
### Prototype
```c
int vrna_eval_structure_pt_simple_verbose(const char *string, const short *pt, FILE *file);
```
"""
function vrna_eval_structure_pt_simple_verbose(string, pt, file)
    ccall((:vrna_eval_structure_pt_simple_verbose, libRNA), Cint, (Ptr{Cchar}, Ptr{Cshort}, Ptr{Libc.FILE}), string, pt, file)
end

"""
    vrna_eval_structure_pt_simple_v(string, pt, verbosity_level, file)

 @brief Calculate the free energy of an already folded RNA

 This function allows for energy evaluation of a given sequence/structure pair where
 the structure is provided in pair_table format as obtained from vrna_ptable().
 Model details, energy parameters, and possibly soft constraints are used as provided
 via the parameter 'fc'. The fold_compound does not need to contain any DP matrices,
 but all the most basic init values as one would get from a call like this:
 @code{.c}
fc = vrna_fold_compound(sequence, NULL, VRNA_OPTION_EVAL_ONLY);
 @endcode
 In contrast to vrna_eval_structure_pt_verbose() this function assumes default model details
 and default energy parameters in order to evaluate the free energy of the secondary
 structure. Threefore, it serves as a simple interface function for energy evaluation
 for situations where no changes on the energy model are required.

 @see vrna_ptable(), vrna_eval_structure_pt_v(), vrna_eval_structure_simple()

 @param string           RNA sequence in uppercase letters
 @param pt               Secondary structure as pair_table
 @param verbosity_level  The level of verbosity of this function
 @param file             A file handle where this function should print to (may be NULL).
 @return                 The free energy of the input structure given the input sequence in 10cal/mol
### Prototype
```c
int vrna_eval_structure_pt_simple_v(const char *string, const short *pt, int verbosity_level, FILE *file);
```
"""
function vrna_eval_structure_pt_simple_v(string, pt, verbosity_level, file)
    ccall((:vrna_eval_structure_pt_simple_v, libRNA), Cint, (Ptr{Cchar}, Ptr{Cshort}, Cint, Ptr{Libc.FILE}), string, pt, verbosity_level, file)
end

"""
    vrna_eval_consensus_structure_pt_simple(alignment, pt)

 @brief  Evaluate the Free Energy of a Consensus Secondary Structure given a Sequence Alignment

 @note The free energy returned from this function already includes the covariation
       pseudo energies that is used fir comparative structure prediction within this
       library.

 @see  vrna_eval_consensus_structure_simple(), vrna_eval_structure_pt(), vrna_eval_structure(),
       vrna_eval_covar_structure()

 @param  alignment   RNA sequence alignment in uppercase letters. Gaps are denoted by hyphens ('-')
 @param  pt          Secondary structure in pair table format
 @return             Free energy of the consensus structure in 10cal/mol
### Prototype
```c
int vrna_eval_consensus_structure_pt_simple(const char **alignment, const short *pt);
```
"""
function vrna_eval_consensus_structure_pt_simple(alignment, pt)
    ccall((:vrna_eval_consensus_structure_pt_simple, libRNA), Cint, (Ptr{Ptr{Cchar}}, Ptr{Cshort}), alignment, pt)
end

"""
    vrna_eval_consensus_structure_pt_simple_verbose(alignment, pt, file)


### Prototype
```c
int vrna_eval_consensus_structure_pt_simple_verbose(const char **alignment, const short *pt, FILE *file);
```
"""
function vrna_eval_consensus_structure_pt_simple_verbose(alignment, pt, file)
    ccall((:vrna_eval_consensus_structure_pt_simple_verbose, libRNA), Cint, (Ptr{Ptr{Cchar}}, Ptr{Cshort}, Ptr{Libc.FILE}), alignment, pt, file)
end

"""
    vrna_eval_consensus_structure_pt_simple_v(alignment, pt, verbosity_level, file)


### Prototype
```c
int vrna_eval_consensus_structure_pt_simple_v(const char **alignment, const short *pt, int verbosity_level, FILE *file);
```
"""
function vrna_eval_consensus_structure_pt_simple_v(alignment, pt, verbosity_level, file)
    ccall((:vrna_eval_consensus_structure_pt_simple_v, libRNA), Cint, (Ptr{Ptr{Cchar}}, Ptr{Cshort}, Cint, Ptr{Libc.FILE}), alignment, pt, verbosity_level, file)
end

"""
    vrna_eval_loop_pt(fc, i, pt)

@brief Calculate energy of a loop

 @param fc         A vrna_fold_compound_t containing the energy parameters and model details
 @param i          position of covering base pair
 @param pt         the pair table of the secondary structure
 @returns          free energy of the loop in 10cal/mol
### Prototype
```c
int vrna_eval_loop_pt(vrna_fold_compound_t *fc, int i, const short *pt);
```
"""
function vrna_eval_loop_pt(fc, i, pt)
    ccall((:vrna_eval_loop_pt, libRNA), Cint, (Ptr{vrna_fold_compound_t}, Cint, Ptr{Cshort}), fc, i, pt)
end

"""
    vrna_eval_loop_pt_v(fc, i, pt, verbosity_level)

@brief Calculate energy of a loop

 @param fc         A vrna_fold_compound_t containing the energy parameters and model details
 @param i          position of covering base pair
 @param pt         the pair table of the secondary structure
 @param verbosity_level  The level of verbosity of this function
 @returns          free energy of the loop in 10cal/mol
### Prototype
```c
int vrna_eval_loop_pt_v(vrna_fold_compound_t *fc, int i, const short *pt, int verbosity_level);
```
"""
function vrna_eval_loop_pt_v(fc, i, pt, verbosity_level)
    ccall((:vrna_eval_loop_pt_v, libRNA), Cint, (Ptr{vrna_fold_compound_t}, Cint, Ptr{Cshort}, Cint), fc, i, pt, verbosity_level)
end

"""
    vrna_eval_move(fc, structure, m1, m2)

@brief Calculate energy of a move (closing or opening of a base pair)

 If the parameters m1 and m2 are negative, it is deletion (opening)
 of a base pair, otherwise it is insertion (opening).

 @see              vrna_eval_move_pt()

 @param fc         A vrna_fold_compound_t containing the energy parameters and model details
 @param structure  secondary structure in dot-bracket notation
 @param m1         first coordinate of base pair
 @param m2         second coordinate of base pair
 @returns          energy change of the move in kcal/mol (#INF / 100. upon any error)
### Prototype
```c
float vrna_eval_move(vrna_fold_compound_t *fc, const char *structure, int m1, int m2);
```
"""
function vrna_eval_move(fc, structure, m1, m2)
    ccall((:vrna_eval_move, libRNA), Cfloat, (Ptr{vrna_fold_compound_t}, Ptr{Cchar}, Cint, Cint), fc, structure, m1, m2)
end

"""
    vrna_eval_move_pt(fc, pt, m1, m2)


@brief Calculate energy of a move (closing or opening of a base pair)

 If the parameters m1 and m2 are negative, it is deletion (opening)
 of a base pair, otherwise it is insertion (opening).

 @see              vrna_eval_move()

 @param fc         A vrna_fold_compound_t containing the energy parameters and model details
 @param pt         the pair table of the secondary structure
 @param m1         first coordinate of base pair
 @param m2         second coordinate of base pair
 @returns          energy change of the move in 10cal/mol
### Prototype
```c
int vrna_eval_move_pt(vrna_fold_compound_t *fc, short *pt, int m1, int m2);
```
"""
function vrna_eval_move_pt(fc, pt, m1, m2)
    ccall((:vrna_eval_move_pt, libRNA), Cint, (Ptr{vrna_fold_compound_t}, Ptr{Cshort}, Cint, Cint), fc, pt, m1, m2)
end

"""
    vrna_eval_move_pt_simple(string, pt, m1, m2)


### Prototype
```c
int vrna_eval_move_pt_simple(const char *string, short *pt, int m1, int m2);
```
"""
function vrna_eval_move_pt_simple(string, pt, m1, m2)
    ccall((:vrna_eval_move_pt_simple, libRNA), Cint, (Ptr{Cchar}, Ptr{Cshort}, Cint, Cint), string, pt, m1, m2)
end

"""
    vrna_eval_move_shift_pt(fc, m, structure)


### Prototype
```c
int vrna_eval_move_shift_pt(vrna_fold_compound_t *fc, vrna_move_t *m, short *structure);
```
"""
function vrna_eval_move_shift_pt(fc, m, structure)
    ccall((:vrna_eval_move_shift_pt, libRNA), Cint, (Ptr{vrna_fold_compound_t}, Ptr{vrna_move_t}, Ptr{Cshort}), fc, m, structure)
end

"""
    energy_of_structure(string, structure, verbosity_level)


### Prototype
```c
;
```
"""
function energy_of_structure(string, structure, verbosity_level)
    ccall((:energy_of_structure, libRNA), Cfloat, (Ptr{Cchar}, Ptr{Cchar}, Cint), string, structure, verbosity_level)
end

"""
    energy_of_struct_par(string, structure, parameters, verbosity_level)


### Prototype
```c
;
```
"""
function energy_of_struct_par(string, structure, parameters, verbosity_level)
    ccall((:energy_of_struct_par, libRNA), Cfloat, (Ptr{Cchar}, Ptr{Cchar}, Ptr{vrna_param_t}, Cint), string, structure, parameters, verbosity_level)
end

"""
    energy_of_circ_structure(string, structure, verbosity_level)


### Prototype
```c
;
```
"""
function energy_of_circ_structure(string, structure, verbosity_level)
    ccall((:energy_of_circ_structure, libRNA), Cfloat, (Ptr{Cchar}, Ptr{Cchar}, Cint), string, structure, verbosity_level)
end

"""
    energy_of_circ_struct_par(string, structure, parameters, verbosity_level)


### Prototype
```c
;
```
"""
function energy_of_circ_struct_par(string, structure, parameters, verbosity_level)
    ccall((:energy_of_circ_struct_par, libRNA), Cfloat, (Ptr{Cchar}, Ptr{Cchar}, Ptr{vrna_param_t}, Cint), string, structure, parameters, verbosity_level)
end

"""
    energy_of_gquad_structure(string, structure, verbosity_level)


### Prototype
```c
;
```
"""
function energy_of_gquad_structure(string, structure, verbosity_level)
    ccall((:energy_of_gquad_structure, libRNA), Cfloat, (Ptr{Cchar}, Ptr{Cchar}, Cint), string, structure, verbosity_level)
end

"""
    energy_of_gquad_struct_par(string, structure, parameters, verbosity_level)


### Prototype
```c
;
```
"""
function energy_of_gquad_struct_par(string, structure, parameters, verbosity_level)
    ccall((:energy_of_gquad_struct_par, libRNA), Cfloat, (Ptr{Cchar}, Ptr{Cchar}, Ptr{vrna_param_t}, Cint), string, structure, parameters, verbosity_level)
end

"""
    energy_of_structure_pt(string, ptable, s, s1, verbosity_level)


### Prototype
```c
;
```
"""
function energy_of_structure_pt(string, ptable, s, s1, verbosity_level)
    ccall((:energy_of_structure_pt, libRNA), Cint, (Ptr{Cchar}, Ptr{Cshort}, Ptr{Cshort}, Ptr{Cshort}, Cint), string, ptable, s, s1, verbosity_level)
end

"""
    energy_of_struct_pt_par(string, ptable, s, s1, parameters, verbosity_level)


### Prototype
```c
;
```
"""
function energy_of_struct_pt_par(string, ptable, s, s1, parameters, verbosity_level)
    ccall((:energy_of_struct_pt_par, libRNA), Cint, (Ptr{Cchar}, Ptr{Cshort}, Ptr{Cshort}, Ptr{Cshort}, Ptr{vrna_param_t}, Cint), string, ptable, s, s1, parameters, verbosity_level)
end

"""
    energy_of_move(string, structure, m1, m2)


### Prototype
```c
;
```
"""
function energy_of_move(string, structure, m1, m2)
    ccall((:energy_of_move, libRNA), Cfloat, (Ptr{Cchar}, Ptr{Cchar}, Cint, Cint), string, structure, m1, m2)
end

"""
    energy_of_move_pt(pt, s, s1, m1, m2)


### Prototype
```c
;
```
"""
function energy_of_move_pt(pt, s, s1, m1, m2)
    ccall((:energy_of_move_pt, libRNA), Cint, (Ptr{Cshort}, Ptr{Cshort}, Ptr{Cshort}, Cint, Cint), pt, s, s1, m1, m2)
end

"""
    loop_energy(ptable, s, s1, i)


### Prototype
```c
;
```
"""
function loop_energy(ptable, s, s1, i)
    ccall((:loop_energy, libRNA), Cint, (Ptr{Cshort}, Ptr{Cshort}, Ptr{Cshort}, Cint), ptable, s, s1, i)
end

"""
    energy_of_struct(string, structure)


### Prototype
```c
;
```
"""
function energy_of_struct(string, structure)
    ccall((:energy_of_struct, libRNA), Cfloat, (Ptr{Cchar}, Ptr{Cchar}), string, structure)
end

"""
    energy_of_struct_pt(string, ptable, s, s1)


### Prototype
```c
;
```
"""
function energy_of_struct_pt(string, ptable, s, s1)
    ccall((:energy_of_struct_pt, libRNA), Cint, (Ptr{Cchar}, Ptr{Cshort}, Ptr{Cshort}, Ptr{Cshort}), string, ptable, s, s1)
end

"""
    energy_of_circ_struct(string, structure)


### Prototype
```c
;
```
"""
function energy_of_circ_struct(string, structure)
    ccall((:energy_of_circ_struct, libRNA), Cfloat, (Ptr{Cchar}, Ptr{Cchar}), string, structure)
end

# DEPRECATED
const vrna_callback_free_auxdata = Cvoid

# DEPRECATED
const vrna_callback_recursion_status = Cvoid

"""
    vrna_fold_compound(sequence, md_p, options)

 @brief  Retrieve a #vrna_fold_compound_t data structure for single sequences and hybridizing sequences

 This function provides an easy interface to obtain a prefilled #vrna_fold_compound_t by passing a single
 sequence, or two contatenated sequences as input. For the latter, sequences need to be seperated by
 an '&' character like this: @verbatim char *sequence = "GGGG&CCCC"; @endverbatim

 The optional parameter @p md_p can be used to specify the model details for successive computations
 based on the content of the generated #vrna_fold_compound_t. Passing NULL will instruct the function
 to use default model details.
 The third parameter @p options may be used to specify dynamic programming (DP) matrix requirements.

 #### Options ####
 * #VRNA_OPTION_DEFAULT  - @copybrief #VRNA_OPTION_DEFAULT
 * #VRNA_OPTION_MFE      - @copybrief #VRNA_OPTION_MFE
 * #VRNA_OPTION_PF       - @copybrief #VRNA_OPTION_PF
 * #VRNA_OPTION_WINDOW   - @copybrief #VRNA_OPTION_WINDOW

 The above options may be OR-ed together.

 If you just need the folding compound serving as a container for your data, you can simply pass
 #VRNA_OPTION_DEFAULT to the @p option parameter. This creates a #vrna_fold_compound_t without DP
 matrices, thus saving memory. Subsequent calls of any structure prediction function will then take
 care of allocating the memory required for the DP matrices.
 If you only intend to evaluate structures instead of actually predicting them, you may use the
 #VRNA_OPTION_EVAL_ONLY macro. This will seriously speedup the creation of the #vrna_fold_compound_t.

 @note The sequence string must be uppercase, and should contain only RNA (resp. DNA) alphabet depending
       on what energy parameter set is used

 @see  vrna_fold_compound_free(), vrna_fold_compound_comparative(), #vrna_md_t

 @param    sequence    A single sequence, or two concatenated sequences seperated by an '&' character
 @param    md_p        An optional set of model details
 @param    options     The options for DP matrices memory allocation
 @return               A prefilled vrna_fold_compound_t ready to be used for computations (may be @p NULL on error)
### Prototype
```c
vrna_fold_compound_t * vrna_fold_compound(const char *sequence, const vrna_md_t *md_p, unsigned int options);
```
"""
function vrna_fold_compound(sequence, md_p, options)
    ccall((:vrna_fold_compound, libRNA), Ptr{vrna_fold_compound_t}, (Ptr{Cchar}, Ptr{vrna_md_t}, Cuint), sequence, md_p, options)
end

"""
    vrna_fold_compound_comparative(sequences, md_p, options)

 @brief  Retrieve a #vrna_fold_compound_t data structure for sequence alignments

 This function provides an easy interface to obtain a prefilled #vrna_fold_compound_t by passing an
 alignment of sequences.

 The optional parameter @p md_p can be used to specify the model details for successive computations
 based on the content of the generated #vrna_fold_compound_t. Passing NULL will instruct the function
 to use default model details.
 The third parameter @p options may be used to specify dynamic programming (DP) matrix requirements.

 #### Options ####
 * #VRNA_OPTION_DEFAULT  - @copybrief #VRNA_OPTION_DEFAULT
 * #VRNA_OPTION_MFE      - @copybrief #VRNA_OPTION_MFE
 * #VRNA_OPTION_PF       - @copybrief #VRNA_OPTION_PF
 * #VRNA_OPTION_WINDOW   - @copybrief #VRNA_OPTION_WINDOW

 The above options may be OR-ed together.

 If you just need the folding compound serving as a container for your data, you can simply pass
 #VRNA_OPTION_DEFAULT to the @p option parameter. This creates a #vrna_fold_compound_t without DP
 matrices, thus saving memory. Subsequent calls of any structure prediction function will then take
 care of allocating the memory required for the DP matrices.
 If you only intend to evaluate structures instead of actually predicting them, you may use the
 #VRNA_OPTION_EVAL_ONLY macro. This will seriously speedup the creation of the #vrna_fold_compound_t.

 @note The sequence strings must be uppercase, and should contain only RNA (resp. DNA) alphabet including
       gap characters depending on what energy parameter set is used.

 @see  vrna_fold_compound_free(), vrna_fold_compound(), #vrna_md_t, #VRNA_OPTION_MFE, #VRNA_OPTION_PF,
       #VRNA_OPTION_EVAL_ONLY, read_clustal()

 @param    sequences   A sequence alignment including 'gap' characters
 @param    md_p        An optional set of model details
 @param    options     The options for DP matrices memory allocation
 @return               A prefilled vrna_fold_compound_t ready to be used for computations (may be @p NULL on error)
### Prototype
```c
vrna_fold_compound_t * vrna_fold_compound_comparative(const char **sequences, vrna_md_t *md_p, unsigned int options);
```
"""
function vrna_fold_compound_comparative(sequences, md_p, options)
    ccall((:vrna_fold_compound_comparative, libRNA), Ptr{vrna_fold_compound_t}, (Ptr{Ptr{Cchar}}, Ptr{vrna_md_t}, Cuint), sequences, md_p, options)
end

"""
    vrna_fold_compound_comparative2(sequences, names, orientation, start, genome_size, md_p, options)


### Prototype
```c
vrna_fold_compound_t * vrna_fold_compound_comparative2(const char **sequences, const char **names, const unsigned char *orientation, const unsigned long long *start, const unsigned long long *genome_size, vrna_md_t *md_p, unsigned int options);
```
"""
function vrna_fold_compound_comparative2(sequences, names, orientation, start, genome_size, md_p, options)
    ccall((:vrna_fold_compound_comparative2, libRNA), Ptr{vrna_fold_compound_t}, (Ptr{Ptr{Cchar}}, Ptr{Ptr{Cchar}}, Ptr{Cuchar}, Ptr{Culonglong}, Ptr{Culonglong}, Ptr{vrna_md_t}, Cuint), sequences, names, orientation, start, genome_size, md_p, options)
end

"""
    vrna_fold_compound_TwoD(sequence, s1, s2, md_p, options)


### Prototype
```c
vrna_fold_compound_t * vrna_fold_compound_TwoD(const char *sequence, const char *s1, const char *s2, vrna_md_t *md_p, unsigned int options);
```
"""
function vrna_fold_compound_TwoD(sequence, s1, s2, md_p, options)
    ccall((:vrna_fold_compound_TwoD, libRNA), Ptr{vrna_fold_compound_t}, (Ptr{Cchar}, Ptr{Cchar}, Ptr{Cchar}, Ptr{vrna_md_t}, Cuint), sequence, s1, s2, md_p, options)
end

"""
    vrna_fold_compound_prepare(fc, options)


### Prototype
```c
int vrna_fold_compound_prepare(vrna_fold_compound_t *fc, unsigned int options);
```
"""
function vrna_fold_compound_prepare(fc, options)
    ccall((:vrna_fold_compound_prepare, libRNA), Cint, (Ptr{vrna_fold_compound_t}, Cuint), fc, options)
end

"""
    vrna_fold_compound_free(fc)

 @brief  Free memory occupied by a #vrna_fold_compound_t

 @see vrna_fold_compound(), vrna_fold_compound_comparative(), vrna_mx_mfe_free(), vrna_mx_pf_free()

 @param  fc  The #vrna_fold_compound_t that is to be erased from memory
### Prototype
```c
void vrna_fold_compound_free(vrna_fold_compound_t *fc);
```
"""
function vrna_fold_compound_free(fc)
    ccall((:vrna_fold_compound_free, libRNA), Cvoid, (Ptr{vrna_fold_compound_t},), fc)
end

"""
    vrna_fold_compound_add_auxdata(fc, data, f)

 @brief  Add auxiliary data to the #vrna_fold_compound_t

 This function allows one to bind arbitrary data to a #vrna_fold_compound_t which may later on be used
 by one of the callback functions, e.g. vrna_recursion_status_f(). To allow for proper cleanup
 of the memory occupied by this auxiliary data, the user may also provide a pointer to a cleanup function
 that free's the corresponding memory. This function will be called automatically when the #vrna_fold_compound_t
 is free'd with vrna_fold_compound_free().

 @note Before attaching the arbitrary data pointer, this function will call the vrna_auxdata_free_f()
       on any pre-existing data that is already attached.

 @see vrna_auxdata_free_f()
 @param  fc    The fold_compound the arbitrary data pointer should be associated with
 @param  data  A pointer to an arbitrary data structure
 @param  f     A pointer to function that free's memory occupied by the arbitrary data (May be NULL)
### Prototype
```c
void vrna_fold_compound_add_auxdata(vrna_fold_compound_t *fc, void *data, vrna_auxdata_free_f f);
```
"""
function vrna_fold_compound_add_auxdata(fc, data, f)
    ccall((:vrna_fold_compound_add_auxdata, libRNA), Cvoid, (Ptr{vrna_fold_compound_t}, Ptr{Cvoid}, vrna_auxdata_free_f), fc, data, f)
end

"""
    vrna_fold_compound_add_callback(fc, f)

 @brief  Add a recursion status callback to the #vrna_fold_compound_t

 Binding a recursion status callback function to a #vrna_fold_compound_t allows one to perform
 arbitrary operations just before, or after an actual recursive computations, e.g. MFE prediction,
 is performed by the RNAlib. The callback function will be provided with a pointer to its
 #vrna_fold_compound_t, and a status message. Hence, it has complete access to all variables that
 incluence the recursive computations.

 @see  vrna_recursion_status_f(), #vrna_fold_compound_t,
       #VRNA_STATUS_MFE_PRE, #VRNA_STATUS_MFE_POST, #VRNA_STATUS_PF_PRE, #VRNA_STATUS_PF_POST

 @param  fc    The fold_compound the callback function should be attached to
 @param  f     The pointer to the recursion status callback function
### Prototype
```c
void vrna_fold_compound_add_callback(vrna_fold_compound_t *fc, vrna_recursion_status_f f);
```
"""
function vrna_fold_compound_add_callback(fc, f)
    ccall((:vrna_fold_compound_add_callback, libRNA), Cvoid, (Ptr{vrna_fold_compound_t}, vrna_recursion_status_f), fc, f)
end

# typedef void ( * vrna_heat_capacity_f ) ( float temp , float heat_capacity , void * data )
"""
 @brief  The callback for heat capacity predictions

 @callback
 @parblock
 This function will be called for each evaluated temperature in the heat capacity prediction.
 @endparblock

 @see vrna_heat_capacity_cb()

 @param temp           The current temperature this results corresponds to in &deg;C
 @param heat_capacity  The heat capacity in Kcal/(Mol * K)
 @param data           Some arbitrary data pointer passed through by the function executing the callback
"""
const vrna_heat_capacity_f = Ptr{Cvoid}

# DEPRECATED
const vrna_heat_capacity_callback = Cvoid

"""
    vrna_heat_capacity_s

 @brief  A single result from heat capacity computations

 @see vrna_heat_capacity()
"""
struct vrna_heat_capacity_s
    temperature::Cfloat
    heat_capacity::Cfloat
end

"""
 @brief  A single result from heat capacity computations

 This is a convenience typedef for #vrna_heat_capacity_s, i.e. results as obtained from vrna_heat_capacity()
"""
const vrna_heat_capacity_t = vrna_heat_capacity_s

"""
    vrna_heat_capacity(fc, T_min, T_max, T_increment, mpoints)

 @brief  Compute the specific heat for an RNA

 This function computes an RNAs specific heat in a given temperature range
 from the partition function by numeric differentiation. The result is returned
 as a list of pairs of temperature in &deg;C and specific heat in Kcal/(Mol*K).

 Users can specify the temperature range for the computation from @p T_min to
 @p T_max, as well as the increment step size @p T_increment. The latter also determines
 how many times the partition function is computed. Finally, the parameter @p mpoints
 determines how smooth the curve should be. The algorithm itself fits a parabola
 to @f\$ 2 \\cdot mpoints + 1 @f\$ data points to calculate 2nd derivatives. Increasing this
 parameter produces a smoother curve.

 @see  vrna_heat_capacity_cb(), vrna_heat_capacity_t, vrna_heat_capacity_s

 @param  fc            The #vrna_fold_compound_t with the RNA sequence to analyze
 @param  T_min         Lowest temperature in &deg;C
 @param  T_max         Highest temperature in &deg;C
 @param  T_increment   Stepsize for temperature incrementation in &deg;C (a reasonable choice might be 1&deg;C)
 @param  mpoints       The number of interpolation points to calculate 2nd derivative (a reasonable choice might be 2, min: 1, max: 100)
 @return               A list of pairs of temperatures and corresponding heat capacity or @em NULL upon any failure.
                       The last entry of the list is indicated by a @b temperature field set to a value smaller than @p T_min
### Prototype
```c
vrna_heat_capacity_t * vrna_heat_capacity(vrna_fold_compound_t *fc, float T_min, float T_max, float T_increment, unsigned int mpoints);
```
"""
function vrna_heat_capacity(fc, T_min, T_max, T_increment, mpoints)
    ccall((:vrna_heat_capacity, libRNA), Ptr{vrna_heat_capacity_t}, (Ptr{vrna_fold_compound_t}, Cfloat, Cfloat, Cfloat, Cuint), fc, T_min, T_max, T_increment, mpoints)
end

"""
    vrna_heat_capacity_cb(fc, T_min, T_max, T_increment, mpoints, cb, data)

 @brief  Compute the specific heat for an RNA  (callback variant)

 Similar to vrna_heat_capacity(), this function computes an RNAs specific heat in
 a given temperature range from the partition function by numeric differentiation.
 Instead of returning a list of temperature/specific heat pairs, however, this
 function returns the individual results through a callback mechanism. The provided
 function will be called for each result and passed the corresponding temperature
 and specific heat values along with the arbitrary data as provided through the
 @p data pointer argument.

 Users can specify the temperature range for the computation from @p T_min to
 @p T_max, as well as the increment step size @p T_increment. The latter also determines
 how many times the partition function is computed. Finally, the parameter @p mpoints
 determines how smooth the curve should be. The algorithm itself fits a parabola
 to @f\$ 2 \\cdot mpoints + 1 @f\$ data points to calculate 2nd derivatives. Increasing this
 parameter produces a smoother curve.

 @see  vrna_heat_capacity(), vrna_heat_capacity_f

 @param  fc            The #vrna_fold_compound_t with the RNA sequence to analyze
 @param  T_min         Lowest temperature in &deg;C
 @param  T_max         Highest temperature in &deg;C
 @param  T_increment   Stepsize for temperature incrementation in &deg;C (a reasonable choice might be 1&deg;C)
 @param  mpoints       The number of interpolation points to calculate 2nd derivative (a reasonable choice might be 2, min: 1, max: 100)
 @param  cb            The user-defined callback function that receives the individual results
 @param  data          An arbitrary data structure that will be passed to the callback in conjunction with the results
 @return               Returns 0 upon failure, and non-zero otherwise
### Prototype
```c
int vrna_heat_capacity_cb(vrna_fold_compound_t *fc, float T_min, float T_max, float T_increment, unsigned int mpoints, vrna_heat_capacity_f cb, void *data);
```
"""
function vrna_heat_capacity_cb(fc, T_min, T_max, T_increment, mpoints, cb, data)
    ccall((:vrna_heat_capacity_cb, libRNA), Cint, (Ptr{vrna_fold_compound_t}, Cfloat, Cfloat, Cfloat, Cuint, vrna_heat_capacity_f, Ptr{Cvoid}), fc, T_min, T_max, T_increment, mpoints, cb, data)
end

"""
    vrna_heat_capacity_simple(sequence, T_min, T_max, T_increment, mpoints)

 @brief  Compute the specific heat for an RNA (simplified variant)

 Similar to vrna_heat_capacity(), this function computes an RNAs specific heat
 in a given temperature range from the partition function by numeric differentiation.
 This simplified version, however, only requires the RNA sequence as input instead of
 a vrna_fold_compound_t data structure. The result is returned as a list of pairs of
 temperature in &deg;C and specific heat in Kcal/(Mol*K).

 Users can specify the temperature range for the computation from @p T_min to
 @p T_max, as well as the increment step size @p T_increment. The latter also determines
 how many times the partition function is computed. Finally, the parameter @p mpoints
 determines how smooth the curve should be. The algorithm itself fits a parabola
 to @f\$ 2 \\cdot mpoints + 1 @f\$ data points to calculate 2nd derivatives. Increasing this
 parameter produces a smoother curve.

 @see  vrna_heat_capacity(), vrna_heat_capacity_cb(), vrna_heat_capacity_t, vrna_heat_capacity_s

 @param  sequence      The RNA sequence input (must be uppercase)
 @param  T_min         Lowest temperature in &deg;C
 @param  T_max         Highest temperature in &deg;C
 @param  T_increment   Stepsize for temperature incrementation in &deg;C (a reasonable choice might be 1&deg;C)
 @param  mpoints       The number of interpolation points to calculate 2nd derivative (a reasonable choice might be 2, min: 1, max: 100)
 @return               A list of pairs of temperatures and corresponding heat capacity or @em NULL upon any failure.
                       The last entry of the list is indicated by a @b temperature field set to a value smaller than @p T_min
### Prototype
```c
vrna_heat_capacity_t * vrna_heat_capacity_simple(const char *sequence, float T_min, float T_max, float T_increment, unsigned int mpoints);
```
"""
function vrna_heat_capacity_simple(sequence, T_min, T_max, T_increment, mpoints)
    ccall((:vrna_heat_capacity_simple, libRNA), Ptr{vrna_heat_capacity_t}, (Ptr{Cchar}, Cfloat, Cfloat, Cfloat, Cuint), sequence, T_min, T_max, T_increment, mpoints)
end

"""
    inverse_fold(start, target)

 \\brief Find sequences with predefined structure

 This function searches for a sequence with minimum free energy structure
 provided in the parameter 'target', starting with sequence 'start'.
 It returns 0 if the search was successful, otherwise a structure distance
 in terms of the energy difference between the search result and the actual
 target 'target' is returned. The found sequence is returned in 'start'.
 If #give_up is set to 1, the function will return as soon as it is
 clear that the search will be unsuccessful, this speeds up the algorithm
 if you are only interested in exact solutions.

 \\param  start   The start sequence
 \\param  target  The target secondary structure in dot-bracket notation
 \\return         The distance to the target in case a search was unsuccessful, 0 otherwise
### Prototype
```c
float inverse_fold( char *start, const char *target);
```
"""
function inverse_fold(start, target)
    ccall((:inverse_fold, libRNA), Cfloat, (Ptr{Cchar}, Ptr{Cchar}), start, target)
end

"""
    inverse_pf_fold(start, target)

 \\brief Find sequence that maximizes probability of a predefined structure

 This function searches for a sequence with maximum probability to fold into
 the provided structure 'target' using the partition function algorithm.
 It returns \\f\$-kT \\cdot \\log(p)\\f\$ where \\f\$p\\f\$ is the frequency of 'target' in
 the ensemble of possible structures. This is usually much slower than
 inverse_fold().

 \\param  start   The start sequence
 \\param  target  The target secondary structure in dot-bracket notation
 \\return         The distance to the target in case a search was unsuccessful, 0 otherwise
### Prototype
```c
float inverse_pf_fold(char *start, const char *target);
```
"""
function inverse_pf_fold(start, target)
    ccall((:inverse_pf_fold, libRNA), Cfloat, (Ptr{Cchar}, Ptr{Cchar}), start, target)
end

# typedef void ( * vrna_move_update_f ) ( vrna_fold_compound_t * fc , vrna_move_t neighbor , unsigned int state , void * data )
"""
 @brief  Prototype of the neighborhood update callback

 @see  vrna_move_neighbor_diff_cb(), #VRNA_NEIGHBOR_CHANGE, #VRNA_NEIGHBOR_INVALID, #VRNA_NEIGHBOR_NEW

 @param  fc        The fold compound the calling function is working on
 @param  neighbor  The move that generates the (changed or new) neighbor
 @param  state     The state of the neighbor (move) as supplied by argument @p neighbor
 @param  data      Some arbitrary data pointer as passed to vrna_move_neighbor_diff_cb()
"""
const vrna_move_update_f = Ptr{Cvoid}

# DEPRECATED
const vrna_callback_move_update = Cvoid

"""
    vrna_loopidx_update(loopidx, pt, length, m)

@brief Alters the loopIndices array that was constructed with vrna_loopidx_from_ptable().

The loopIndex of the current move will be inserted.
The correctness of the input will not be checked because the speed should be optimized.

@param[in,out] loopidx   The loop index data structure that needs an update
@param[in]     pt        A pair table on which the move will be executed
@param         length    The length of the structure
@param[in]     m         The move that is applied to the current structure
### Prototype
```c
void vrna_loopidx_update(int *loopidx, const short *pt, int length, const vrna_move_t *m);
```
"""
function vrna_loopidx_update(loopidx, pt, length, m)
    ccall((:vrna_loopidx_update, libRNA), Cvoid, (Ptr{Cint}, Ptr{Cshort}, Cint, Ptr{vrna_move_t}), loopidx, pt, length, m)
end

"""
    vrna_neighbors(fc, pt, options)

@brief Generate neighbors of a secondary structure

This function allows one to generate all structural neighbors (according to a particular move set)
of an RNA secondary structure. The neighborhood is then returned as a list of transitions / moves
required to transform the current structure into the actual neighbor.

@see vrna_neighbors_successive(), vrna_move_apply(),
     #VRNA_MOVESET_INSERTION, #VRNA_MOVESET_DELETION, #VRNA_MOVESET_SHIFT, #VRNA_MOVESET_DEFAULT

@param[in] fc        A vrna_fold_compound_t containing the energy parameters and model details
@param[in] pt        The pair table representation of the structure
@param     options   Options to modify the behavior of this function, e.g. available move set
@return              Neighbors as a list of moves / transitions (the last element in the list has both of its fields set to 0)
### Prototype
```c
vrna_move_t * vrna_neighbors(vrna_fold_compound_t *fc, const short *pt, unsigned int options);
```
"""
function vrna_neighbors(fc, pt, options)
    ccall((:vrna_neighbors, libRNA), Ptr{vrna_move_t}, (Ptr{vrna_fold_compound_t}, Ptr{Cshort}, Cuint), fc, pt, options)
end

"""
    vrna_neighbors_successive(fc, curr_move, prev_pt, prev_neighbors, size_prev_neighbors, size_neighbors, options)

@brief Generate neighbors of a secondary structure (the fast way)

This function implements a fast way to generate all neighbors of a secondary structure
that results from successive applications of individual moves. The speed-up results from
updating an already known list of valid neighbors before the individual move towards the
current structure took place. In essence, this function removes neighbors that are not
accessible anymore and inserts neighbors emerging after a move took place.

@see vrna_neighbors(), vrna_move_apply(),
     #VRNA_MOVESET_INSERTION, #VRNA_MOVESET_DELETION, #VRNA_MOVESET_SHIFT, #VRNA_MOVESET_DEFAULT

@param[in]   fc                  A vrna_fold_compound_t containing the energy parameters and model details
@param[in]   curr_move           The move that was/will be applied to @p prev_pt
@param[in]   prev_pt             A pair table representation of the structure before @p curr_move is/was applied
@param[in]   prev_neighbors      The list of neighbors of @p prev_pt
@param       size_prev_neighbors The size of @p prev_neighbors, i.e. the lists length
@param[out]  size_neighbors      A pointer to store the size / length of the new neighbor list
@param       options             Options to modify the behavior of this function, e.g. available move set
@return                          Neighbors as a list of moves / transitions (the last element in the list has both of its fields set to 0)
### Prototype
```c
vrna_move_t * vrna_neighbors_successive(const vrna_fold_compound_t *fc, const vrna_move_t *curr_move, const short *prev_pt, const vrna_move_t *prev_neighbors, int size_prev_neighbors, int *size_neighbors, unsigned int options);
```
"""
function vrna_neighbors_successive(fc, curr_move, prev_pt, prev_neighbors, size_prev_neighbors, size_neighbors, options)
    ccall((:vrna_neighbors_successive, libRNA), Ptr{vrna_move_t}, (Ptr{vrna_fold_compound_t}, Ptr{vrna_move_t}, Ptr{Cshort}, Ptr{vrna_move_t}, Cint, Ptr{Cint}, Cuint), fc, curr_move, prev_pt, prev_neighbors, size_prev_neighbors, size_neighbors, options)
end

"""
    vrna_move_neighbor_diff_cb(fc, ptable, move, cb, data, options)

 @brief  Apply a move to a secondary structure and indicate which neighbors have changed consequentially

 This function applies a move to a secondary structure and explores the local neighborhood of the
 affected loop. Any changes to previously compatible neighbors that have been affected by this loop
 will be reported through a callback function. In particular, any of the three cases might appear:
 - A previously available neighbor move has changed, usually the free energy change of the move (#VRNA_NEIGHBOR_CHANGE)
 - A previously available neighbor move became invalid (#VRNA_NEIGHBOR_INVALID)
 - A new neighbor move becomes available (#VRNA_NEIGHBOR_NEW)

 @see  vrna_move_neighbor_diff(), #VRNA_NEIGHBOR_CHANGE, #VRNA_NEIGHBOR_INVALID, #VRNA_NEIGHBOR_NEW,
       #vrna_move_update_f

 @param  fc        A fold compound for the RNA sequence(s) that this function operates on
 @param  ptable    The current structure as pair table
 @param  move      The move to apply
 @param  cb        The address of the callback function that is passed the neighborhood changes
 @param  data      An arbitrary data pointer that will be passed through to the callback function @p cb
 @param  options   Options to modify the behavior of this function, .e.g available move set
 @return           Non-zero on success, 0 otherwise
### Prototype
```c
int vrna_move_neighbor_diff_cb(vrna_fold_compound_t *fc, short *ptable, vrna_move_t move, vrna_move_update_f cb, void *data, unsigned int options);
```
"""
function vrna_move_neighbor_diff_cb(fc, ptable, move, cb, data, options)
    ccall((:vrna_move_neighbor_diff_cb, libRNA), Cint, (Ptr{vrna_fold_compound_t}, Ptr{Cshort}, vrna_move_t, vrna_move_update_f, Ptr{Cvoid}, Cuint), fc, ptable, move, cb, data, options)
end

"""
    vrna_move_neighbor_diff(fc, ptable, move, invalid_moves, options)

 @brief  Apply a move to a secondary structure and indicate which neighbors have changed consequentially

 Similar to vrna_move_neighbor_diff_cb(), this function applies a move to a secondary structure and
 reports back the neighbors of the current structure become affected by this move. Instead of executing
 a callback for each of the affected neighbors, this function compiles two lists of neighbor moves, one
 that is returned and consists of all moves that are novel or may have changed in energy, and a second,
 @p invalid_moves, that consists of all the neighbor moves that become invalid, respectively.

 @param  fc        A fold compound for the RNA sequence(s) that this function operates on
 @param  ptable    The current structure as pair table
 @param  move      The move to apply
 @param  invalid_moves The address of a move list where the function stores those moves that become invalid
 @param  options   Options to modify the behavior of this function, .e.g available move set
 @return           A list of moves that might have changed in energy or are novel compared to the structure before application of the move
### Prototype
```c
vrna_move_t * vrna_move_neighbor_diff(vrna_fold_compound_t *fc, short *ptable, vrna_move_t move, vrna_move_t **invalid_moves, unsigned int options);
```
"""
function vrna_move_neighbor_diff(fc, ptable, move, invalid_moves, options)
    ccall((:vrna_move_neighbor_diff, libRNA), Ptr{vrna_move_t}, (Ptr{vrna_fold_compound_t}, Ptr{Cshort}, vrna_move_t, Ptr{Ptr{vrna_move_t}}, Cuint), fc, ptable, move, invalid_moves, options)
end

"""
    vrna_MEA(fc, gamma, mea)

 @brief Compute a MEA (maximum expected accuracy) structure

 The algorithm maximizes the expected accuracy

 @f[
   A(S) = \\sum_{(i,j) \\in S} 2 \\gamma p_{ij} + \\sum_{i \\notin S} p^u_i
 @f]

 Higher values of @f\$\\gamma@f\$ result in more base pairs of lower
 probability and thus higher sensitivity. Low values of @f\$\\gamma@f\$ result in structures
 containing only highly likely pairs (high specificity).
 The code of the MEA function also demonstrates the use of sparse dynamic
 programming scheme to reduce the time and memory complexity of folding.

 @pre  vrna_pf() must be executed on input parameter @p fc

 @ingroup  mea_fold

 @param  fc    The fold compound data structure with pre-filled base pair probability matrix
 @param  gamma The weighting factor for base pairs vs. unpaired nucleotides
 @param  mea   A pointer to a variable where the MEA value will be written to
 @return       An MEA structure (or NULL on any error)
### Prototype
```c
char * vrna_MEA(vrna_fold_compound_t *fc, double gamma, float *mea);
```
"""
function vrna_MEA(fc, gamma, mea)
    ccall((:vrna_MEA, libRNA), Ptr{Cchar}, (Ptr{vrna_fold_compound_t}, Cdouble, Ptr{Cfloat}), fc, gamma, mea)
end

"""
    vrna_MEA_from_plist(plist_, sequence, gamma, md, mea)

 @brief Compute a MEA (maximum expected accuracy) structure from a list of probabilities

 The algorithm maximizes the expected accuracy

 @f[
   A(S) = \\sum_{(i,j) \\in S} 2 \\gamma p_{ij} + \\sum_{i \\notin S} p^u_i
 @f]

 Higher values of @f\$\\gamma@f\$ result in more base pairs of lower
 probability and thus higher sensitivity. Low values of @f\$\\gamma@f\$ result in structures
 containing only highly likely pairs (high specificity).
 The code of the MEA function also demonstrates the use of sparse dynamic
 programming scheme to reduce the time and memory complexity of folding.

 @note The unpaired probabilities @f\$p^u_i = 1 - \\sum_{j \\neq i} p_{ij}@f\$ are usually
       computed from the supplied pairing probabilities @f\$p_{ij}@f\$ as stored in @p plist
       entries of type #VRNA_PLIST_TYPE_BASEPAIR. To overwrite individual @f\$p^u_o@f\$
       values simply add entries with type #VRNA_PLIST_TYPE_UNPAIRED<br>
       To include G-Quadruplex support, the corresponding field in @p md must be set.

 @ingroup  mea_fold

 @param  plist     A list of base pair probabilities the MEA structure is computed from
 @param  sequence  The RNA sequence that corresponds to the list of probability values
 @param  gamma     The weighting factor for base pairs vs. unpaired nucleotides
 @param  md        A model details data structure (maybe NULL)
 @param  mea       A pointer to a variable where the MEA value will be written to
 @return           An MEA structure (or NULL on any error)
### Prototype
```c
char * vrna_MEA_from_plist(vrna_ep_t *plist, const char *sequence, double gamma, vrna_md_t *md, float *mea);
```
"""
function vrna_MEA_from_plist(plist_, sequence, gamma, md, mea)
    ccall((:vrna_MEA_from_plist, libRNA), Ptr{Cchar}, (Ptr{vrna_ep_t}, Ptr{Cchar}, Cdouble, Ptr{vrna_md_t}, Ptr{Cfloat}), plist_, sequence, gamma, md, mea)
end

"""
    MEA(p, structure, gamma)


### Prototype
```c
;
```
"""
function MEA(p, structure, gamma)
    ccall((:MEA, libRNA), Cfloat, (Ptr{plist}, Ptr{Cchar}, Cdouble), p, structure, gamma)
end

"""
    MEA_seq(p, sequence, structure, gamma, pf)


### Prototype
```c
;
```
"""
function MEA_seq(p, sequence, structure, gamma, pf)
    ccall((:MEA_seq, libRNA), Cfloat, (Ptr{plist}, Ptr{Cchar}, Ptr{Cchar}, Cdouble, Ptr{vrna_exp_param_t}), p, sequence, structure, gamma, pf)
end

"""
    vrna_mfe(fc, structure)

 @brief Compute minimum free energy and an appropriate secondary
 structure of an RNA sequence, or RNA sequence alignment

 Depending on the type of the provided #vrna_fold_compound_t, this function
 predicts the MFE for a single sequence (or connected component of multiple
 sequences), or an averaged MFE for a sequence alignment.
 If backtracking is activated, it also constructs the corresponding secondary
 structure, or consensus structure.
 Therefore, the second parameter, @a structure, has to point to an allocated
 block of memory with a size of at least @f\$\\mathrm{strlen}(\\mathrm{sequence})+1@f\$ to
 store the backtracked MFE structure. (For consensus structures, this is the length of
 the alignment + 1. If @p NULL is passed, no backtracking will be performed.

 @note This function is polymorphic. It accepts #vrna_fold_compound_t of type
       #VRNA_FC_TYPE_SINGLE, and #VRNA_FC_TYPE_COMPARATIVE.

 @see #vrna_fold_compound_t, vrna_fold_compound(), vrna_fold(), vrna_circfold(),
       vrna_fold_compound_comparative(), vrna_alifold(), vrna_circalifold()

 @param fc             fold compound
 @param structure      A pointer to the character array where the
                       secondary structure in dot-bracket notation will be written to (Maybe NULL)

 @return the minimum free energy (MFE) in kcal/mol
### Prototype
```c
float vrna_mfe(vrna_fold_compound_t *fc, char *structure);
```
"""
function vrna_mfe(fc, structure)
    ccall((:vrna_mfe, libRNA), Cfloat, (Ptr{vrna_fold_compound_t}, Ptr{Cchar}), fc, structure)
end

"""
    vrna_mfe_dimer(fc, structure)


### Prototype
```c
;
```
"""
function vrna_mfe_dimer(fc, structure)
    ccall((:vrna_mfe_dimer, libRNA), Cfloat, (Ptr{vrna_fold_compound_t}, Ptr{Cchar}), fc, structure)
end

"""
    vrna_fold(sequence, structure)

 @brief Compute Minimum Free Energy (MFE), and a corresponding secondary structure for an RNA sequence

 This simplified interface to vrna_mfe() computes the MFE and, if required, a secondary structure for an
 RNA sequence using default options. Memory required for dynamic programming (DP) matrices will
 be allocated and free'd on-the-fly. Hence, after return of this function, the recursively filled
 matrices are not available any more for any post-processing, e.g. suboptimal backtracking, etc.

 @note In case you want to use the filled DP matrices for any subsequent post-processing step, or
       you require other conditions than specified by the default model details, use vrna_mfe(),
       and the data structure #vrna_fold_compound_t instead.

 @see vrna_circfold(), vrna_mfe()

 @param sequence   RNA sequence
 @param structure  A pointer to the character array where the
        secondary structure in dot-bracket notation will be written to
 @return the minimum free energy (MFE) in kcal/mol
### Prototype
```c
float vrna_fold(const char *sequence, char *structure);
```
"""
function vrna_fold(sequence, structure)
    ccall((:vrna_fold, libRNA), Cfloat, (Ptr{Cchar}, Ptr{Cchar}), sequence, structure)
end

"""
    vrna_circfold(sequence, structure)

 @brief Compute Minimum Free Energy (MFE), and a corresponding secondary structure for a circular RNA sequence

 This simplified interface to vrna_mfe() computes the MFE and, if required, a secondary structure for a
 circular RNA sequence using default options. Memory required for dynamic programming (DP) matrices will
 be allocated and free'd on-the-fly. Hence, after return of this function, the recursively filled
 matrices are not available any more for any post-processing, e.g. suboptimal backtracking, etc.

 Folding of circular RNA sequences is handled as a post-processing step of the forward
 recursions. See @cite hofacker:2006 for further details.

 @note In case you want to use the filled DP matrices for any subsequent post-processing step, or
       you require other conditions than specified by the default model details, use vrna_mfe(),
       and the data structure #vrna_fold_compound_t instead.

 @see vrna_fold(), vrna_mfe()

 @param sequence   RNA sequence
 @param structure  A pointer to the character array where the
        secondary structure in dot-bracket notation will be written to
 @return the minimum free energy (MFE) in kcal/mol
### Prototype
```c
float vrna_circfold(const char *sequence, char *structure);
```
"""
function vrna_circfold(sequence, structure)
    ccall((:vrna_circfold, libRNA), Cfloat, (Ptr{Cchar}, Ptr{Cchar}), sequence, structure)
end

"""
    vrna_alifold(sequences, structure)

 @brief  Compute Minimum Free Energy (MFE), and a corresponding consensus secondary structure
         for an RNA sequence alignment using a comparative method

 This simplified interface to vrna_mfe() computes the MFE and, if required, a consensus secondary
 structure for an RNA sequence alignment using default options. Memory required for dynamic programming
 (DP) matrices will be allocated and free'd on-the-fly. Hence, after return of this function, the
 recursively filled matrices are not available any more for any post-processing, e.g. suboptimal
 backtracking, etc.

 @note In case you want to use the filled DP matrices for any subsequent post-processing step, or
       you require other conditions than specified by the default model details, use vrna_mfe(),
       and the data structure #vrna_fold_compound_t instead.

 @see vrna_circalifold(), vrna_mfe()

 @param sequences  RNA sequence alignment
 @param structure  A pointer to the character array where the
        secondary structure in dot-bracket notation will be written to
 @return the minimum free energy (MFE) in kcal/mol
### Prototype
```c
float vrna_alifold(const char **sequences, char *structure);
```
"""
function vrna_alifold(sequences, structure)
    ccall((:vrna_alifold, libRNA), Cfloat, (Ptr{Ptr{Cchar}}, Ptr{Cchar}), sequences, structure)
end

"""
    vrna_circalifold(sequences, structure)

 @brief  Compute Minimum Free Energy (MFE), and a corresponding consensus secondary structure
         for a sequence alignment of circular RNAs using a comparative method

 This simplified interface to vrna_mfe() computes the MFE and, if required, a consensus secondary
 structure for an RNA sequence alignment using default options. Memory required for dynamic programming
 (DP) matrices will be allocated and free'd on-the-fly. Hence, after return of this function, the
 recursively filled matrices are not available any more for any post-processing, e.g. suboptimal
 backtracking, etc.

 Folding of circular RNA sequences is handled as a post-processing step of the forward
 recursions. See @cite hofacker:2006 for further details.

 @note In case you want to use the filled DP matrices for any subsequent post-processing step, or
       you require other conditions than specified by the default model details, use vrna_mfe(),
       and the data structure #vrna_fold_compound_t instead.

 @see vrna_alifold(), vrna_mfe()

 @param sequences  Sequence alignment of circular RNAs
 @param structure  A pointer to the character array where the
        secondary structure in dot-bracket notation will be written to
 @return the minimum free energy (MFE) in kcal/mol
### Prototype
```c
float vrna_circalifold(const char **sequences, char *structure);
```
"""
function vrna_circalifold(sequences, structure)
    ccall((:vrna_circalifold, libRNA), Cfloat, (Ptr{Ptr{Cchar}}, Ptr{Cchar}), sequences, structure)
end

"""
    vrna_cofold(sequence, structure)


### Prototype
```c
;
```
"""
function vrna_cofold(sequence, structure)
    ccall((:vrna_cofold, libRNA), Cfloat, (Ptr{Cchar}, Ptr{Cchar}), sequence, structure)
end

"""
    vrna_backtrack_from_intervals(fc, bp_stack, bt_stack, s)

 @brief
### Prototype
```c
int vrna_backtrack_from_intervals(vrna_fold_compound_t *fc, vrna_bp_stack_t *bp_stack, sect bt_stack[], int s);
```
"""
function vrna_backtrack_from_intervals(fc, bp_stack, bt_stack, s)
    ccall((:vrna_backtrack_from_intervals, libRNA), Cint, (Ptr{vrna_fold_compound_t}, Ptr{vrna_bp_stack_t}, Ptr{sect}, Cint), fc, bp_stack, bt_stack, s)
end

"""
    vrna_backtrack5(fc, length, structure)

 @brief Backtrack an MFE (sub)structure

 This function allows one to backtrack the MFE structure for a (sub)sequence

 @note On error, the function returns #INF / 100. and stores the empty string
       in @p structure.

 @pre  Requires pre-filled MFE dynamic programming matrices, i.e. one has to call vrna_mfe()
       prior to calling this function

 @see vrna_mfe(), vrna_pbacktrack5()

 @param fc             fold compound
 @param length         The length of the subsequence, starting from the 5' end
 @param structure      A pointer to the character array where the secondary structure in
                       dot-bracket notation will be written to. (Must have size of at least \$p length + 1)

 @return               The minimum free energy (MFE) for the specified @p length in kcal/mol and
                       a corresponding secondary structure in dot-bracket notation (stored in @p structure)
### Prototype
```c
float vrna_backtrack5(vrna_fold_compound_t *fc, unsigned int length, char *structure);
```
"""
function vrna_backtrack5(fc, length, structure)
    ccall((:vrna_backtrack5, libRNA), Cfloat, (Ptr{vrna_fold_compound_t}, Cuint, Ptr{Cchar}), fc, length, structure)
end

"""
    vrna_backtrack_window(fc, Lfold_filename, file_pos, structure, mfe)


### Prototype
```c
int vrna_backtrack_window(vrna_fold_compound_t *fc, const char *Lfold_filename, long file_pos, char **structure, double mfe);
```
"""
function vrna_backtrack_window(fc, Lfold_filename, file_pos, structure, mfe)
    ccall((:vrna_backtrack_window, libRNA), Cint, (Ptr{vrna_fold_compound_t}, Ptr{Cchar}, Clong, Ptr{Ptr{Cchar}}, Cdouble), fc, Lfold_filename, file_pos, structure, mfe)
end

# typedef void ( * vrna_mfe_window_f ) ( int start , int end , const char * structure , float en , void * data )
"""
 @brief  The default callback for sliding window MFE structure predictions

 @callback
 @parblock
 This function will be called for each hit in a sliding window MFE prediction.
 @endparblock

 @see vrna_mfe_window()

 @param start provides the first position of the hit (1-based, relative to entire sequence/alignment)
 @param end provides the last position of the hit (1-based, relative to the entire sequence/alignment)
 @param structure provides the (sub)structure in dot-bracket notation
 @param en is the free energy of the structure hit in kcal/mol
 @param data is some arbitrary data pointer passed through by the function executing the callback
"""
const vrna_mfe_window_f = Ptr{Cvoid}

# DEPRECATED
const vrna_mfe_window_callback = Cvoid

"""
    vrna_mfe_window(fc, file)

 @brief Local MFE prediction using a sliding window approach.

 Computes minimum free energy structures using a sliding window
 approach, where base pairs may not span outside the window.
 In contrast to vrna_mfe(), where a maximum base pair span
 may be set using the #vrna_md_t.max_bp_span attribute and one
 globally optimal structure is predicted, this function uses a
 sliding window to retrieve all locally optimal structures within
 each window.
 The size of the sliding window is set in the #vrna_md_t.window_size
 attribute, prior to the retrieval of the #vrna_fold_compound_t
 using vrna_fold_compound() with option #VRNA_OPTION_WINDOW

 The predicted structures are written on-the-fly, either to
 stdout, if a NULL pointer is passed as file parameter, or to
 the corresponding filehandle.

 @see  vrna_fold_compound(), vrna_mfe_window_zscore(), vrna_mfe(),
       vrna_Lfold(), vrna_Lfoldz(),
       #VRNA_OPTION_WINDOW, #vrna_md_t.max_bp_span, #vrna_md_t.window_size

 @param  fc        The #vrna_fold_compound_t with preallocated memory for the DP matrices
 @param  file      The output file handle where predictions are written to (maybe NULL)
### Prototype
```c
float vrna_mfe_window(vrna_fold_compound_t *fc, FILE *file);
```
"""
function vrna_mfe_window(fc, file)
    ccall((:vrna_mfe_window, libRNA), Cfloat, (Ptr{vrna_fold_compound_t}, Ptr{Libc.FILE}), fc, file)
end

"""
    vrna_mfe_window_cb(fc, cb, data)


### Prototype
```c
float vrna_mfe_window_cb(vrna_fold_compound_t *fc, vrna_mfe_window_f cb, void *data);
```
"""
function vrna_mfe_window_cb(fc, cb, data)
    ccall((:vrna_mfe_window_cb, libRNA), Cfloat, (Ptr{vrna_fold_compound_t}, vrna_mfe_window_f, Ptr{Cvoid}), fc, cb, data)
end

"""
    vrna_Lfold(string, window_size, file)

 @brief Local MFE prediction using a sliding window approach (simplified interface)

 This simplified interface to vrna_mfe_window() computes the MFE and locally
 optimal secondary structure using default options. Structures are predicted
 using a sliding window approach, where base pairs may not span outside the
 window. Memory required for dynamic programming (DP) matrices will
 be allocated and free'd on-the-fly. Hence, after return of this function, the recursively filled
 matrices are not available any more for any post-processing.

 @note In case you want to use the filled DP matrices for any subsequent post-processing step, or
       you require other conditions than specified by the default model details, use vrna_mfe_window(),
       and the data structure #vrna_fold_compound_t instead.

 @see  vrna_mfe_window(), vrna_Lfoldz(), vrna_mfe_window_zscore()

 @param  string      The nucleic acid sequence
 @param  window_size The window size for locally optimal structures
 @param  file        The output file handle where predictions are written to (if NULL, output is written to stdout)
### Prototype
```c
float vrna_Lfold(const char *string, int window_size, FILE *file);
```
"""
function vrna_Lfold(string, window_size, file)
    ccall((:vrna_Lfold, libRNA), Cfloat, (Ptr{Cchar}, Cint, Ptr{Libc.FILE}), string, window_size, file)
end

"""
    vrna_Lfold_cb(string, window_size, cb, data)


### Prototype
```c
float vrna_Lfold_cb(const char *string, int window_size, vrna_mfe_window_f cb, void *data);
```
"""
function vrna_Lfold_cb(string, window_size, cb, data)
    ccall((:vrna_Lfold_cb, libRNA), Cfloat, (Ptr{Cchar}, Cint, vrna_mfe_window_f, Ptr{Cvoid}), string, window_size, cb, data)
end

"""
    vrna_aliLfold(alignment, maxdist, fp)


### Prototype
```c
float vrna_aliLfold(const char **alignment, int maxdist, FILE *fp);
```
"""
function vrna_aliLfold(alignment, maxdist, fp)
    ccall((:vrna_aliLfold, libRNA), Cfloat, (Ptr{Ptr{Cchar}}, Cint, Ptr{Libc.FILE}), alignment, maxdist, fp)
end

"""
    vrna_aliLfold_cb(alignment, maxdist, cb, data)


### Prototype
```c
float vrna_aliLfold_cb(const char **alignment, int maxdist, vrna_mfe_window_f cb, void *data);
```
"""
function vrna_aliLfold_cb(alignment, maxdist, cb, data)
    ccall((:vrna_aliLfold_cb, libRNA), Cfloat, (Ptr{Ptr{Cchar}}, Cint, vrna_mfe_window_f, Ptr{Cvoid}), alignment, maxdist, cb, data)
end

"""
    vrna_params_load(fname, options)

 @brief Load energy parameters from a file

 @see  vrna_params_load_from_string(), vrna_params_save(),
       vrna_params_load_defaults(), vrna_params_load_RNA_Turner2004(),
       vrna_params_load_RNA_Turner1999(), vrna_params_load_RNA_Andronescu2007(),
       vrna_params_load_RNA_Langdon2018(), vrna_params_load_RNA_misc_special_hairpins(),
       vrna_params_load_DNA_Mathews2004(), vrna_params_load_DNA_Mathews1999()

 @param  fname   The path to the file containing the energy parameters
 @param  options File format bit-mask (usually #VRNA_PARAMETER_FORMAT_DEFAULT)
 @return         Non-zero on success, 0 on failure
### Prototype
```c
int vrna_params_load(const char fname[], unsigned int options);
```
"""
function vrna_params_load(fname, options)
    ccall((:vrna_params_load, libRNA), Cint, (Ptr{Cchar}, Cuint), fname, options)
end

"""
    vrna_params_save(fname, options)

 @brief Save energy parameters to a file

 @see vrna_params_load()

 @param fname  A filename (path) for the file where the current energy parameters will be written to
 @param  options File format bit-mask (usually #VRNA_PARAMETER_FORMAT_DEFAULT)
 @return         Non-zero on success, 0 on failure
### Prototype
```c
int vrna_params_save(const char fname[], unsigned int options);
```
"""
function vrna_params_save(fname, options)
    ccall((:vrna_params_save, libRNA), Cint, (Ptr{Cchar}, Cuint), fname, options)
end

"""
    vrna_params_load_from_string(string, name, options)

 @brief  Load energy paramters from string

 The string must follow the default energy parameter file convention!
 The optional @p name argument allows one to specify a name for the
 parameter set which is stored internally.

 @see  vrna_params_load(), vrna_params_save(),
       vrna_params_load_defaults(), vrna_params_load_RNA_Turner2004(),
       vrna_params_load_RNA_Turner1999(), vrna_params_load_RNA_Andronescu2007(),
       vrna_params_load_RNA_Langdon2018(), vrna_params_load_RNA_misc_special_hairpins(),
       vrna_params_load_DNA_Mathews2004(), vrna_params_load_DNA_Mathews1999()

 @param    string  A 0-terminated string containing energy parameters
 @param    name    A name for the parameter set in @p string (Maybe @p NULL)
 @param    options File format bit-mask (usually #VRNA_PARAMETER_FORMAT_DEFAULT)
 @return           Non-zero on success, 0 on failure
### Prototype
```c
int vrna_params_load_from_string(const char *string, const char *name, unsigned int options);
```
"""
function vrna_params_load_from_string(string, name, options)
    ccall((:vrna_params_load_from_string, libRNA), Cint, (Ptr{Cchar}, Ptr{Cchar}, Cuint), string, name, options)
end

"""
    vrna_params_load_defaults()

 @brief  Load default RNA energy parameter set

 This is a convenience function to load the Turner 2004 RNA free
 energy parameters. It's the same as calling vrna_params_load_RNA_Turner2004()

 @see  vrna_params_load(), vrna_params_load_from_string(),
       vrna_params_save(), vrna_params_load_RNA_Turner2004(),
       vrna_params_load_RNA_Turner1999(), vrna_params_load_RNA_Andronescu2007(),
       vrna_params_load_RNA_Langdon2018(), vrna_params_load_RNA_misc_special_hairpins(),
       vrna_params_load_DNA_Mathews2004(), vrna_params_load_DNA_Mathews1999()

 @return Non-zero on success, 0 on failure
### Prototype
```c
int vrna_params_load_defaults(void);
```
"""
function vrna_params_load_defaults()
    ccall((:vrna_params_load_defaults, libRNA), Cint, ())
end

"""
    vrna_params_load_RNA_Turner2004()

 @brief  Load Turner 2004 RNA energy parameter set

 @warning  This function also resets the default geometric parameters
           as stored in #vrna_md_t to those of RNA. Only subsequently
           initialized #vrna_md_t structures will be affected by this
           change.

 @see  vrna_params_load(), vrna_params_load_from_string(),
       vrna_params_save(), vrna_params_load_defaults(),
       vrna_params_load_RNA_Turner1999(), vrna_params_load_RNA_Andronescu2007(),
       vrna_params_load_RNA_Langdon2018(), vrna_params_load_RNA_misc_special_hairpins(),
       vrna_params_load_DNA_Mathews2004(), vrna_params_load_DNA_Mathews1999()

 @return Non-zero on success, 0 on failure
### Prototype
```c
int vrna_params_load_RNA_Turner2004(void);
```
"""
function vrna_params_load_RNA_Turner2004()
    ccall((:vrna_params_load_RNA_Turner2004, libRNA), Cint, ())
end

"""
    vrna_params_load_RNA_Turner1999()

 @brief  Load Turner 1999 RNA energy parameter set

 @warning  This function also resets the default geometric parameters
           as stored in #vrna_md_t to those of RNA. Only subsequently
           initialized #vrna_md_t structures will be affected by this
           change.

 @see  vrna_params_load(), vrna_params_load_from_string(),
       vrna_params_save(), vrna_params_load_RNA_Turner2004(),
       vrna_params_load_defaults(), vrna_params_load_RNA_Andronescu2007(),
       vrna_params_load_RNA_Langdon2018(), vrna_params_load_RNA_misc_special_hairpins(),
       vrna_params_load_DNA_Mathews2004(), vrna_params_load_DNA_Mathews1999()


 @return Non-zero on success, 0 on failure
### Prototype
```c
int vrna_params_load_RNA_Turner1999(void);
```
"""
function vrna_params_load_RNA_Turner1999()
    ccall((:vrna_params_load_RNA_Turner1999, libRNA), Cint, ())
end

"""
    vrna_params_load_RNA_Andronescu2007()

 @brief  Load Andronsecu 2007 RNA energy parameter set

 @warning  This function also resets the default geometric parameters
           as stored in #vrna_md_t to those of RNA. Only subsequently
           initialized #vrna_md_t structures will be affected by this
           change.

 @see  vrna_params_load(), vrna_params_load_from_string(),
       vrna_params_save(), vrna_params_load_RNA_Turner2004(),
       vrna_params_load_RNA_Turner1999(), vrna_params_load_defaults(),
       vrna_params_load_RNA_Langdon2018(), vrna_params_load_RNA_misc_special_hairpins(),
       vrna_params_load_DNA_Mathews2004(), vrna_params_load_DNA_Mathews1999()

 @return Non-zero on success, 0 on failure
### Prototype
```c
int vrna_params_load_RNA_Andronescu2007(void);
```
"""
function vrna_params_load_RNA_Andronescu2007()
    ccall((:vrna_params_load_RNA_Andronescu2007, libRNA), Cint, ())
end

"""
    vrna_params_load_RNA_Langdon2018()

 @brief  Load Langdon 2018 RNA energy parameter set

 @warning  This function also resets the default geometric parameters
           as stored in #vrna_md_t to those of RNA. Only subsequently
           initialized #vrna_md_t structures will be affected by this
           change.

 @see  vrna_params_load(), vrna_params_load_from_string(),
       vrna_params_save(), vrna_params_load_RNA_Turner2004(),
       vrna_params_load_RNA_Turner1999(), vrna_params_load_RNA_Andronescu2007(),
       vrna_params_load_defaults(), vrna_params_load_RNA_misc_special_hairpins(),
       vrna_params_load_DNA_Mathews2004(), vrna_params_load_DNA_Mathews1999()

 @return Non-zero on success, 0 on failure
### Prototype
```c
int vrna_params_load_RNA_Langdon2018(void);
```
"""
function vrna_params_load_RNA_Langdon2018()
    ccall((:vrna_params_load_RNA_Langdon2018, libRNA), Cint, ())
end

"""
    vrna_params_load_RNA_misc_special_hairpins()

 @brief  Load Misc Special Hairpin RNA energy parameter set

 @warning  This function also resets the default geometric parameters
           as stored in #vrna_md_t to those of RNA. Only subsequently
           initialized #vrna_md_t structures will be affected by this
           change.

 @see  vrna_params_load(), vrna_params_load_from_string(),
       vrna_params_save(), vrna_params_load_RNA_Turner2004(),
       vrna_params_load_RNA_Turner1999(), vrna_params_load_RNA_Andronescu2007(),
       vrna_params_load_RNA_Langdon2018(), vrna_params_load_defaults(),
       vrna_params_load_DNA_Mathews2004(), vrna_params_load_DNA_Mathews1999()


 @return Non-zero on success, 0 on failure
### Prototype
```c
int vrna_params_load_RNA_misc_special_hairpins(void);
```
"""
function vrna_params_load_RNA_misc_special_hairpins()
    ccall((:vrna_params_load_RNA_misc_special_hairpins, libRNA), Cint, ())
end

"""
    vrna_params_load_DNA_Mathews2004()

 @brief  Load Mathews 2004 DNA energy parameter set

 @warning  This function also resets the default geometric parameters
           as stored in #vrna_md_t to those of DNA. Only subsequently
           initialized #vrna_md_t structures will be affected by this
           change.

 @see  vrna_params_load(), vrna_params_load_from_string(),
       vrna_params_save(), vrna_params_load_RNA_Turner2004(),
       vrna_params_load_RNA_Turner1999(), vrna_params_load_RNA_Andronescu2007(),
       vrna_params_load_RNA_Langdon2018(), vrna_params_load_RNA_misc_special_hairpins(),
       vrna_params_load_defaults(), vrna_params_load_DNA_Mathews1999()


 @return Non-zero on success, 0 on failure
### Prototype
```c
int vrna_params_load_DNA_Mathews2004(void);
```
"""
function vrna_params_load_DNA_Mathews2004()
    ccall((:vrna_params_load_DNA_Mathews2004, libRNA), Cint, ())
end

"""
    vrna_params_load_DNA_Mathews1999()

 @brief  Load Mathews 1999 DNA energy parameter set

 @warning  This function also resets the default geometric parameters
           as stored in #vrna_md_t to those of DNA. Only subsequently
           initialized #vrna_md_t structures will be affected by this
           change.

 @see  vrna_params_load(), vrna_params_load_from_string(),
       vrna_params_save(), vrna_params_load_RNA_Turner2004(),
       vrna_params_load_RNA_Turner1999(), vrna_params_load_RNA_Andronescu2007(),
       vrna_params_load_RNA_Langdon2018(), vrna_params_load_RNA_misc_special_hairpins(),
       vrna_params_load_DNA_Mathews2004(), vrna_params_load_defaults()


 @return Non-zero on success, 0 on failure
### Prototype
```c
int vrna_params_load_DNA_Mathews1999(void);
```
"""
function vrna_params_load_DNA_Mathews1999()
    ccall((:vrna_params_load_DNA_Mathews1999, libRNA), Cint, ())
end

"""
    parset

 @brief
"""
@cenum parset::Int32 begin
    UNKNOWN = -1
    QUIT = 0
    S = 1
    S_H = 2
    HP = 3
    HP_H = 4
    B = 5
    B_H = 6
    IL = 7
    IL_H = 8
    MMH = 9
    MMH_H = 10
    MMI = 11
    MMI_H = 12
    MMI1N = 13
    MMI1N_H = 14
    MMI23 = 15
    MMI23_H = 16
    MMM = 17
    MMM_H = 18
    MME = 19
    MME_H = 20
    D5 = 21
    D5_H = 22
    D3 = 23
    D3_H = 24
    INT11 = 25
    INT11_H = 26
    INT21 = 27
    INT21_H = 28
    INT22 = 29
    INT22_H = 30
    ML = 31
    TL = 32
    TRI = 33
    HEX = 34
    NIN = 35
    MISC = 36
end

"""
    last_parameter_file()

 @brief Get the file name of the parameter file that was most recently loaded

 @return The file name of the last parameter file, or NULL if parameters are still at defaults
### Prototype
```c
const char * last_parameter_file(void);
```
"""
function last_parameter_file()
    ccall((:last_parameter_file, libRNA), Ptr{Cchar}, ())
end

"""
    read_parameter_file(fname)


### Prototype
```c
;
```
"""
function read_parameter_file(fname)
    ccall((:read_parameter_file, libRNA), Cvoid, (Ptr{Cchar},), fname)
end

"""
    write_parameter_file(fname)


### Prototype
```c
;
```
"""
function write_parameter_file(fname)
    ccall((:write_parameter_file, libRNA), Cvoid, (Ptr{Cchar},), fname)
end

"""
    gettype(ident)

 @brief

### Prototype
```c
enum parset gettype(const char *ident);
```
"""
function gettype(ident)
    ccall((:gettype, libRNA), parset, (Ptr{Cchar},), ident)
end

"""
    settype(s)

 @brief

### Prototype
```c
char * settype(enum parset s);
```
"""
function settype(s)
    ccall((:settype, libRNA), Ptr{Cchar}, (parset,), s)
end

"""
    vrna_dimer_pf_s

 @brief  Data structure returned by vrna_pf_dimer()
"""
struct vrna_dimer_pf_s
    F0AB::Cdouble
    FAB::Cdouble
    FcAB::Cdouble
    FA::Cdouble
    FB::Cdouble
end

"""
 @brief Typename for the data structure that stores the dimer partition functions, #vrna_dimer_pf_s, as returned by vrna_pf_dimer()
 @ingroup  pf_cofold
"""
const vrna_dimer_pf_t = vrna_dimer_pf_s

struct vrna_multimer_pf_s
    F_connected::Cdouble
    F_monomers::Ptr{Cdouble}
    num_monomers::Csize_t
end

const vrna_multimer_pf_t = vrna_multimer_pf_s

"""
 @brief Backward compatibility typedef for #vrna_dimer_pf_s
 @ingroup  pf_cofold
"""
const cofoldF = vrna_dimer_pf_s

"""
    vrna_centroid(fc, dist)

 @brief Get the centroid structure of the ensemble

 The centroid is the structure with the minimal average distance to all other structures
 \\n @f\$ <d(S)> = \\sum_{(i,j) \\in S} (1-p_{ij}) + \\sum_{(i,j) \\notin S} p_{ij} @f\$ \\n
 Thus, the centroid is simply the structure containing all pairs with @f\$p_ij>0.5@f\$
 The distance of the centroid to the ensemble is written to the memory adressed by @a dist.

 @ingroup              centroid_fold
 @param[in]    fc      The fold compound data structure
 @param[out]   dist    A pointer to the distance variable where the centroid distance will be written to
 @return               The centroid structure of the ensemble in dot-bracket notation (@p NULL on error)
### Prototype
```c
char * vrna_centroid(vrna_fold_compound_t *fc, double *dist);
```
"""
function vrna_centroid(fc, dist)
    ccall((:vrna_centroid, libRNA), Ptr{Cchar}, (Ptr{vrna_fold_compound_t}, Ptr{Cdouble}), fc, dist)
end

"""
    vrna_centroid_from_plist(length, dist, pl)

 @brief Get the centroid structure of the ensemble

 This function is a threadsafe replacement for @ref centroid() with a #vrna_ep_t input

 The centroid is the structure with the minimal average distance to all other structures
 \\n @f\$ <d(S)> = \\sum_{(i,j) \\in S} (1-p_{ij}) + \\sum_{(i,j) \\notin S} p_{ij} @f\$ \\n
 Thus, the centroid is simply the structure containing all pairs with @f\$p_ij>0.5@f\$
 The distance of the centroid to the ensemble is written to the memory adressed by @a dist.

 @ingroup            centroid_fold
 @param[in]  length  The length of the sequence
 @param[out] dist    A pointer to the distance variable where the centroid distance will be written to
 @param[in]  pl      A pair list containing base pair probability information about the ensemble
 @return             The centroid structure of the ensemble in dot-bracket notation (@p NULL on error)
### Prototype
```c
char * vrna_centroid_from_plist(int length, double *dist, vrna_ep_t *pl);
```
"""
function vrna_centroid_from_plist(length, dist, pl)
    ccall((:vrna_centroid_from_plist, libRNA), Ptr{Cchar}, (Cint, Ptr{Cdouble}, Ptr{vrna_ep_t}), length, dist, pl)
end

"""
    vrna_centroid_from_probs(length, dist, probs)

 @brief Get the centroid structure of the ensemble

 This function is a threadsafe replacement for @ref centroid() with a probability array input

 The centroid is the structure with the minimal average distance to all other structures
 \\n @f\$ <d(S)> = \\sum_{(i,j) \\in S} (1-p_{ij}) + \\sum_{(i,j) \\notin S} p_{ij} @f\$ \\n
 Thus, the centroid is simply the structure containing all pairs with @f\$p_ij>0.5@f\$
 The distance of the centroid to the ensemble is written to the memory adressed by @a dist.

 @ingroup              centroid_fold
 @param[in]    length  The length of the sequence
 @param[out]   dist    A pointer to the distance variable where the centroid distance will be written to
 @param[in]    probs   An upper triangular matrix containing base pair probabilities (access via iindx @ref vrna_idx_row_wise() )
 @return               The centroid structure of the ensemble in dot-bracket notation (@p NULL on error)
### Prototype
```c
char * vrna_centroid_from_probs(int length, double *dist, FLT_OR_DBL *probs);
```
"""
function vrna_centroid_from_probs(length, dist, probs)
    ccall((:vrna_centroid_from_probs, libRNA), Ptr{Cchar}, (Cint, Ptr{Cdouble}, Ptr{FLT_OR_DBL}), length, dist, probs)
end

"""
    get_centroid_struct_pl(length, dist, pl)


### Prototype
```c
;
```
"""
function get_centroid_struct_pl(length, dist, pl)
    ccall((:get_centroid_struct_pl, libRNA), Ptr{Cchar}, (Cint, Ptr{Cdouble}, Ptr{vrna_ep_t}), length, dist, pl)
end

"""
    get_centroid_struct_pr(length, dist, pr)


### Prototype
```c
;
```
"""
function get_centroid_struct_pr(length, dist, pr)
    ccall((:get_centroid_struct_pr, libRNA), Ptr{Cchar}, (Cint, Ptr{Cdouble}, Ptr{FLT_OR_DBL}), length, dist, pr)
end

# typedef void ( * vrna_bs_result_f ) ( const char * structure , void * data )
"""
 @brief  Callback for Boltzmann sampling

@callback
@parblock
This function will be called for each secondary structure that has been successfully backtraced
from the partition function DP matrices.
@endparblock

@see vrna_pbacktrack5_cb(), vrna_pbacktrack_cb(), vrna_pbacktrack5_resume_cb(),
     vrna_pbacktrack_resume_cb()

@param structure The secondary structure in dot-bracket notation
@param data      Some arbitrary, auxiliary data address as provided to the calling function
"""
const vrna_bs_result_f = Ptr{Cvoid}

# DEPRECATED
const vrna_boltzmann_sampling_callback = Cvoid

mutable struct vrna_pbacktrack_memory_s end

"""
 @brief  Boltzmann sampling memory data structure

 This structure is required for properly resuming a previous sampling round in
 specialized Boltzmann sampling, such as non-redundant backtracking.

 Initialize with @p NULL and pass its address to the corresponding
 functions vrna_pbacktrack5_resume(), etc.

 @note Do not forget to release memory occupied by this data structure before
       losing its context! Use vrna_pbacktrack_mem_free().

 @see  vrna_pbacktrack5_resume(), vrna_pbacktrack_resume(), vrna_pbacktrack5_resume_cb(),
       vrna_pbacktrack_resume_cb(), vrna_pbacktrack_mem_free()
"""
const vrna_pbacktrack_mem_t = Ptr{vrna_pbacktrack_memory_s}

"""
    vrna_pbacktrack5(fc, length)

 @brief Sample a secondary structure of a subsequence from the Boltzmann ensemble according its probability

 Perform a probabilistic (stochastic) backtracing in the partition function DP arrays
 to obtain a secondary structure. The parameter @p length specifies the length
 of the substructure starting from the 5' end.

 The structure @f\$ s @f\$ with free energy @f\$ E(s) @f\$ is picked from the Boltzmann distributed
 ensemble according to its probability

 @f[
 p(s) = \\frac{exp(-E(s) / kT)}{Z}
 @f]

 with partition function @f\$ Z = \\sum_s exp(-E(s) / kT) @f\$, Boltzmann constant @f\$ k @f\$ and
 thermodynamic temperature @f\$ T @f\$.

 @pre    Unique multiloop decomposition has to be active upon creation of @p fc with vrna_fold_compound()
         or similar. This can be done easily by passing vrna_fold_compound() a model details parameter
         with vrna_md_t.uniq_ML = 1.<br>
         vrna_pf() has to be called first to fill the partition function matrices

 @note This function is polymorphic. It accepts #vrna_fold_compound_t of type
       #VRNA_FC_TYPE_SINGLE, and #VRNA_FC_TYPE_COMPARATIVE.

 @see vrna_pbacktrack5_num(), vrna_pbacktrack5_cb(), vrna_pbacktrack()

 @param  fc      The fold compound data structure
 @param  length  The length of the subsequence to consider (starting with 5' end)
 @return         A sampled secondary structure in dot-bracket notation (or NULL on error)
### Prototype
```c
char * vrna_pbacktrack5(vrna_fold_compound_t *fc, unsigned int length);
```
"""
function vrna_pbacktrack5(fc, length)
    ccall((:vrna_pbacktrack5, libRNA), Ptr{Cchar}, (Ptr{vrna_fold_compound_t}, Cuint), fc, length)
end

"""
    vrna_pbacktrack5_num(fc, num_samples, length, options)

 @brief Obtain a set of secondary structure samples for a subsequence from the Boltzmann ensemble according their probability

 Perform a probabilistic (stochastic) backtracing in the partition function DP arrays
 to obtain a set of @p num_samples secondary structures. The parameter @p length specifies
 the length of the substructure starting from the 5' end.

 Any structure @f\$ s @f\$ with free energy @f\$ E(s) @f\$ is picked from the Boltzmann distributed
 ensemble according to its probability

 @f[
 p(s) = \\frac{exp(-E(s) / kT)}{Z}
 @f]

 with partition function @f\$ Z = \\sum_s exp(-E(s) / kT) @f\$, Boltzmann constant @f\$ k @f\$ and
 thermodynamic temperature @f\$ T @f\$.

 Using the @p options flag one can switch between regular (#VRNA_PBACKTRACK_DEFAULT) backtracing
 mode, and non-redundant sampling (#VRNA_PBACKTRACK_NON_REDUNDANT) along the lines of Michalik
 et al. 2017 @cite michalik:2017.

 @pre    Unique multiloop decomposition has to be active upon creation of @p fc with vrna_fold_compound()
         or similar. This can be done easily by passing vrna_fold_compound() a model details parameter
         with vrna_md_t.uniq_ML = 1.<br>
         vrna_pf() has to be called first to fill the partition function matrices

 @note This function is polymorphic. It accepts #vrna_fold_compound_t of type
       #VRNA_FC_TYPE_SINGLE, and #VRNA_FC_TYPE_COMPARATIVE.

 @warning  In non-redundant sampling mode (#VRNA_PBACKTRACK_NON_REDUNDANT), this function may
           not yield the full number of requested samples. This may happen if
           a)  the number of requested structures is larger than the total number
               of structuresin the ensemble,
           b)  numeric instabilities prevent the backtracking function to enumerate
               structures with high free energies, or
           c)  any other error occurs.

 @see  vrna_pbacktrack5(), vrna_pbacktrack5_cb(), vrna_pbacktrack_num(),
       #VRNA_PBACKTRACK_DEFAULT, #VRNA_PBACKTRACK_NON_REDUNDANT

 @param  fc            The fold compound data structure
 @param  num_samples   The size of the sample set, i.e. number of structures
 @param  length        The length of the subsequence to consider (starting with 5' end)
 @param  options       A bitwise OR-flag indicating the backtracing mode.
 @return               A set of secondary structure samples in dot-bracket notation terminated by NULL (or NULL on error)
### Prototype
```c
char ** vrna_pbacktrack5_num(vrna_fold_compound_t *fc, unsigned int num_samples, unsigned int length, unsigned int options);
```
"""
function vrna_pbacktrack5_num(fc, num_samples, length, options)
    ccall((:vrna_pbacktrack5_num, libRNA), Ptr{Ptr{Cchar}}, (Ptr{vrna_fold_compound_t}, Cuint, Cuint, Cuint), fc, num_samples, length, options)
end

"""
    vrna_pbacktrack5_cb(fc, num_samples, length, cb, data, options)

 @brief Obtain a set of secondary structure samples for a subsequence from the Boltzmann ensemble according their probability

 Perform a probabilistic (stochastic) backtracing in the partition function DP arrays
 to obtain a set of @p num_samples secondary structures. The parameter @p length specifies
 the length of the substructure starting from the 5' end.

 Any structure @f\$ s @f\$ with free energy @f\$ E(s) @f\$ is picked from the Boltzmann distributed
 ensemble according to its probability

 @f[
 p(s) = \\frac{exp(-E(s) / kT)}{Z}
 @f]

 with partition function @f\$ Z = \\sum_s exp(-E(s) / kT) @f\$, Boltzmann constant @f\$ k @f\$ and
 thermodynamic temperature @f\$ T @f\$.

 Using the @p options flag one can switch between regular (#VRNA_PBACKTRACK_DEFAULT) backtracing
 mode, and non-redundant sampling (#VRNA_PBACKTRACK_NON_REDUNDANT) along the lines of Michalik
 et al. 2017 @cite michalik:2017.

 In contrast to vrna_pbacktrack5() and vrna_pbacktrack5_num() this function yields the
 structure samples through a callback mechanism.

 @pre    Unique multiloop decomposition has to be active upon creation of @p fc with vrna_fold_compound()
         or similar. This can be done easily by passing vrna_fold_compound() a model details parameter
         with vrna_md_t.uniq_ML = 1.<br>
         vrna_pf() has to be called first to fill the partition function matrices

 @note This function is polymorphic. It accepts #vrna_fold_compound_t of type
       #VRNA_FC_TYPE_SINGLE, and #VRNA_FC_TYPE_COMPARATIVE.

 @warning  In non-redundant sampling mode (#VRNA_PBACKTRACK_NON_REDUNDANT), this function may
           not yield the full number of requested samples. This may happen if
           a)  the number of requested structures is larger than the total number
               of structuresin the ensemble,
           b)  numeric instabilities prevent the backtracking function to enumerate
               structures with high free energies, or
           c)  any other error occurs.

 @see  vrna_pbacktrack5(), vrna_pbacktrack5_num(), vrna_pbacktrack_cb(),
       #VRNA_PBACKTRACK_DEFAULT, #VRNA_PBACKTRACK_NON_REDUNDANT

 @param  fc            The fold compound data structure
 @param  num_samples   The size of the sample set, i.e. number of structures
 @param  length        The length of the subsequence to consider (starting with 5' end)
 @param  cb            The callback that receives the sampled structure
 @param  data          A data structure passed through to the callback @p cb
 @param  options       A bitwise OR-flag indicating the backtracing mode.
 @return               The number of structures actually backtraced
### Prototype
```c
unsigned int vrna_pbacktrack5_cb(vrna_fold_compound_t *fc, unsigned int num_samples, unsigned int length, vrna_bs_result_f cb, void *data, unsigned int options);
```
"""
function vrna_pbacktrack5_cb(fc, num_samples, length, cb, data, options)
    ccall((:vrna_pbacktrack5_cb, libRNA), Cuint, (Ptr{vrna_fold_compound_t}, Cuint, Cuint, vrna_bs_result_f, Ptr{Cvoid}, Cuint), fc, num_samples, length, cb, data, options)
end

"""
    vrna_pbacktrack5_resume(fc, num_samples, length, nr_mem, options)

 @brief Obtain a set of secondary structure samples for a subsequence from the Boltzmann ensemble according their probability

 Perform a probabilistic (stochastic) backtracing in the partition function DP arrays
 to obtain a set of @p num_samples secondary structures. The parameter @p length specifies
 the length of the substructure starting from the 5' end.

 Any structure @f\$ s @f\$ with free energy @f\$ E(s) @f\$ is picked from the Boltzmann distributed
 ensemble according to its probability

 @f[
 p(s) = \\frac{exp(-E(s) / kT)}{Z}
 @f]

 with partition function @f\$ Z = \\sum_s exp(-E(s) / kT) @f\$, Boltzmann constant @f\$ k @f\$ and
 thermodynamic temperature @f\$ T @f\$.

 Using the @p options flag one can switch between regular (#VRNA_PBACKTRACK_DEFAULT) backtracing
 mode, and non-redundant sampling (#VRNA_PBACKTRACK_NON_REDUNDANT) along the lines of Michalik
 et al. 2017 @cite michalik:2017.

 In contrast to vrna_pbacktrack5_cb() this function allows for resuming a previous
 sampling round in specialized Boltzmann sampling, such as non-redundant backtracking.
 For that purpose, the user passes the address of a Boltzmann sampling data structure
 (#vrna_pbacktrack_mem_t) which will be re-used in each round of sampling, i.e. each
 successive call to vrna_pbacktrack5_resume_cb() or vrna_pbacktrack5_resume().

 A successive sample call to this function may look like:
@code{.c}
vrna_pbacktrack_mem_t nonredundant_memory = NULL;

// sample the first 100 structures
vrna_pbacktrack5_resume(fc,
                        100,
                        fc->length,
                        &nonredundant_memory,
                        options);

// sample another 500 structures
vrna_pbacktrack5_resume(fc,
                        500,
                        fc->length,
                        &nonredundant_memory,
                        options);

// release memory occupied by the non-redundant memory data structure
vrna_pbacktrack_mem_free(nonredundant_memory);
@endcode

 @pre    Unique multiloop decomposition has to be active upon creation of @p fc with vrna_fold_compound()
         or similar. This can be done easily by passing vrna_fold_compound() a model details parameter
         with vrna_md_t.uniq_ML = 1.<br>
         vrna_pf() has to be called first to fill the partition function matrices

 @note This function is polymorphic. It accepts #vrna_fold_compound_t of type
       #VRNA_FC_TYPE_SINGLE, and #VRNA_FC_TYPE_COMPARATIVE.

 @warning  In non-redundant sampling mode (#VRNA_PBACKTRACK_NON_REDUNDANT), this function may
           not yield the full number of requested samples. This may happen if
           a)  the number of requested structures is larger than the total number
               of structuresin the ensemble,
           b)  numeric instabilities prevent the backtracking function to enumerate
               structures with high free energies, or
           c)  any other error occurs.

 @see  vrna_pbacktrack5_resume_cb(), vrna_pbacktrack5_cb(), vrna_pbacktrack_resume(),
       #vrna_pbacktrack_mem_t, #VRNA_PBACKTRACK_DEFAULT, #VRNA_PBACKTRACK_NON_REDUNDANT,
       vrna_pbacktrack_mem_free

 @param  fc            The fold compound data structure
 @param  num_samples   The size of the sample set, i.e. number of structures
 @param  length        The length of the subsequence to consider (starting with 5' end)
 @param  nr_mem        The address of the Boltzmann sampling memory data structure
 @param  options       A bitwise OR-flag indicating the backtracing mode.
 @return               A set of secondary structure samples in dot-bracket notation terminated by NULL (or NULL on error)
### Prototype
```c
char ** vrna_pbacktrack5_resume(vrna_fold_compound_t *fc, unsigned int num_samples, unsigned int length, vrna_pbacktrack_mem_t *nr_mem, unsigned int options);
```
"""
function vrna_pbacktrack5_resume(fc, num_samples, length, nr_mem, options)
    ccall((:vrna_pbacktrack5_resume, libRNA), Ptr{Ptr{Cchar}}, (Ptr{vrna_fold_compound_t}, Cuint, Cuint, Ptr{vrna_pbacktrack_mem_t}, Cuint), fc, num_samples, length, nr_mem, options)
end

"""
    vrna_pbacktrack5_resume_cb(fc, num_samples, length, cb, data, nr_mem, options)

 @brief Obtain a set of secondary structure samples for a subsequence from the Boltzmann ensemble according their probability

 Perform a probabilistic (stochastic) backtracing in the partition function DP arrays
 to obtain a set of @p num_samples secondary structures. The parameter @p length specifies
 the length of the substructure starting from the 5' end.

 Any structure @f\$ s @f\$ with free energy @f\$ E(s) @f\$ is picked from the Boltzmann distributed
 ensemble according to its probability

 @f[
 p(s) = \\frac{exp(-E(s) / kT)}{Z}
 @f]

 with partition function @f\$ Z = \\sum_s exp(-E(s) / kT) @f\$, Boltzmann constant @f\$ k @f\$ and
 thermodynamic temperature @f\$ T @f\$.

 Using the @p options flag one can switch between regular (#VRNA_PBACKTRACK_DEFAULT) backtracing
 mode, and non-redundant sampling (#VRNA_PBACKTRACK_NON_REDUNDANT) along the lines of Michalik
 et al. 2017 @cite michalik:2017.

 In contrast to vrna_pbacktrack5_resume() this function yields the structure samples
 through a callback mechanism.

 A successive sample call to this function may look like:
@code{.c}
vrna_pbacktrack_mem_t nonredundant_memory = NULL;

// sample the first 100 structures
vrna_pbacktrack5_resume_cb(fc,
                           100,
                           fc->length,
                           &callback_function,
                           (void *)&callback_data,
                           &nonredundant_memory,
                           options);

// sample another 500 structures
vrna_pbacktrack5_resume_cb(fc,
                           500,
                           fc->length,
                           &callback_function,
                           (void *)&callback_data,
                           &nonredundant_memory,
                           options);

// release memory occupied by the non-redundant memory data structure
vrna_pbacktrack_mem_free(nonredundant_memory);
@endcode

 @pre    Unique multiloop decomposition has to be active upon creation of @p fc with vrna_fold_compound()
         or similar. This can be done easily by passing vrna_fold_compound() a model details parameter
         with vrna_md_t.uniq_ML = 1.<br>
         vrna_pf() has to be called first to fill the partition function matrices

 @note This function is polymorphic. It accepts #vrna_fold_compound_t of type
       #VRNA_FC_TYPE_SINGLE, and #VRNA_FC_TYPE_COMPARATIVE.

 @warning  In non-redundant sampling mode (#VRNA_PBACKTRACK_NON_REDUNDANT), this function may
           not yield the full number of requested samples. This may happen if
           a)  the number of requested structures is larger than the total number
               of structuresin the ensemble,
           b)  numeric instabilities prevent the backtracking function to enumerate
               structures with high free energies, or
           c)  any other error occurs.

 @see  vrna_pbacktrack5_resume(), vrna_pbacktrack5_cb(), vrna_pbacktrack_resume_cb(),
       #vrna_pbacktrack_mem_t, #VRNA_PBACKTRACK_DEFAULT, #VRNA_PBACKTRACK_NON_REDUNDANT,
       vrna_pbacktrack_mem_free

 @param  fc            The fold compound data structure
 @param  num_samples   The size of the sample set, i.e. number of structures
 @param  length        The length of the subsequence to consider (starting with 5' end)
 @param  cb            The callback that receives the sampled structure
 @param  data          A data structure passed through to the callback @p cb
 @param  nr_mem        The address of the Boltzmann sampling memory data structure
 @param  options       A bitwise OR-flag indicating the backtracing mode.
 @return               The number of structures actually backtraced
### Prototype
```c
unsigned int vrna_pbacktrack5_resume_cb(vrna_fold_compound_t *fc, unsigned int num_samples, unsigned int length, vrna_bs_result_f cb, void *data, vrna_pbacktrack_mem_t *nr_mem, unsigned int options);
```
"""
function vrna_pbacktrack5_resume_cb(fc, num_samples, length, cb, data, nr_mem, options)
    ccall((:vrna_pbacktrack5_resume_cb, libRNA), Cuint, (Ptr{vrna_fold_compound_t}, Cuint, Cuint, vrna_bs_result_f, Ptr{Cvoid}, Ptr{vrna_pbacktrack_mem_t}, Cuint), fc, num_samples, length, cb, data, nr_mem, options)
end

"""
    vrna_pbacktrack(fc)

 @brief Sample a secondary structure from the Boltzmann ensemble according its probability

 Perform a probabilistic (stochastic) backtracing in the partition function DP arrays
 to obtain a secondary structure.

 The structure @f\$ s @f\$ with free energy @f\$ E(s) @f\$ is picked from the Boltzmann distributed
 ensemble according to its probability

 @f[
 p(s) = \\frac{exp(-E(s) / kT)}{Z}
 @f]

 with partition function @f\$ Z = \\sum_s exp(-E(s) / kT) @f\$, Boltzmann constant @f\$ k @f\$ and
 thermodynamic temperature @f\$ T @f\$.

 @pre    Unique multiloop decomposition has to be active upon creation of @p fc with vrna_fold_compound()
         or similar. This can be done easily by passing vrna_fold_compound() a model details parameter
         with vrna_md_t.uniq_ML = 1.<br>
         vrna_pf() has to be called first to fill the partition function matrices

 @note This function is polymorphic. It accepts #vrna_fold_compound_t of type
       #VRNA_FC_TYPE_SINGLE, and #VRNA_FC_TYPE_COMPARATIVE.

 @see vrna_pbacktrack5(), vrna_pbacktrack_num, vrna_pbacktrack_cb()

 @param  fc      The fold compound data structure
 @return         A sampled secondary structure in dot-bracket notation (or NULL on error)
### Prototype
```c
char * vrna_pbacktrack(vrna_fold_compound_t *fc);
```
"""
function vrna_pbacktrack(fc)
    ccall((:vrna_pbacktrack, libRNA), Ptr{Cchar}, (Ptr{vrna_fold_compound_t},), fc)
end

"""
    vrna_pbacktrack_num(fc, num_samples, options)

 @brief Obtain a set of secondary structure samples from the Boltzmann ensemble according their probability

 Perform a probabilistic (stochastic) backtracing in the partition function DP arrays
 to obtain a set of @p num_samples secondary structures.

 Any structure @f\$ s @f\$ with free energy @f\$ E(s) @f\$ is picked from the Boltzmann distributed
 ensemble according to its probability

 @f[
 p(s) = \\frac{exp(-E(s) / kT)}{Z}
 @f]

 with partition function @f\$ Z = \\sum_s exp(-E(s) / kT) @f\$, Boltzmann constant @f\$ k @f\$ and
 thermodynamic temperature @f\$ T @f\$.

 Using the @p options flag one can switch between regular (#VRNA_PBACKTRACK_DEFAULT) backtracing
 mode, and non-redundant sampling (#VRNA_PBACKTRACK_NON_REDUNDANT) along the lines of Michalik
 et al. 2017 @cite michalik:2017.

 @pre    Unique multiloop decomposition has to be active upon creation of @p fc with vrna_fold_compound()
         or similar. This can be done easily by passing vrna_fold_compound() a model details parameter
         with vrna_md_t.uniq_ML = 1.<br>
         vrna_pf() has to be called first to fill the partition function matrices

 @note This function is polymorphic. It accepts #vrna_fold_compound_t of type
       #VRNA_FC_TYPE_SINGLE, and #VRNA_FC_TYPE_COMPARATIVE.

 @warning  In non-redundant sampling mode (#VRNA_PBACKTRACK_NON_REDUNDANT), this function may
           not yield the full number of requested samples. This may happen if
           a)  the number of requested structures is larger than the total number
               of structuresin the ensemble,
           b)  numeric instabilities prevent the backtracking function to enumerate
               structures with high free energies, or
           c)  any other error occurs.

 @see  vrna_pbacktrack(), vrna_pbacktrack_cb(), vrna_pbacktrack5_num(),
       #VRNA_PBACKTRACK_DEFAULT, #VRNA_PBACKTRACK_NON_REDUNDANT

 @param  fc            The fold compound data structure
 @param  num_samples   The size of the sample set, i.e. number of structures
 @param  options       A bitwise OR-flag indicating the backtracing mode.
 @return               A set of secondary structure samples in dot-bracket notation terminated by NULL (or NULL on error)
### Prototype
```c
char ** vrna_pbacktrack_num(vrna_fold_compound_t *fc, unsigned int num_samples, unsigned int options);
```
"""
function vrna_pbacktrack_num(fc, num_samples, options)
    ccall((:vrna_pbacktrack_num, libRNA), Ptr{Ptr{Cchar}}, (Ptr{vrna_fold_compound_t}, Cuint, Cuint), fc, num_samples, options)
end

"""
    vrna_pbacktrack_cb(fc, num_samples, cb, data, options)

 @brief Obtain a set of secondary structure samples from the Boltzmann ensemble according their probability

 Perform a probabilistic (stochastic) backtracing in the partition function DP arrays
 to obtain a set of @p num_samples secondary structures.

 Any structure @f\$ s @f\$ with free energy @f\$ E(s) @f\$ is picked from the Boltzmann distributed
 ensemble according to its probability

 @f[
 p(s) = \\frac{exp(-E(s) / kT)}{Z}
 @f]

 with partition function @f\$ Z = \\sum_s exp(-E(s) / kT) @f\$, Boltzmann constant @f\$ k @f\$ and
 thermodynamic temperature @f\$ T @f\$.

 Using the @p options flag one can switch between regular (#VRNA_PBACKTRACK_DEFAULT) backtracing
 mode, and non-redundant sampling (#VRNA_PBACKTRACK_NON_REDUNDANT) along the lines of Michalik
 et al. 2017 @cite michalik:2017.

 In contrast to vrna_pbacktrack() and vrna_pbacktrack_num() this function yields the
 structure samples through a callback mechanism.

 @pre    Unique multiloop decomposition has to be active upon creation of @p fc with vrna_fold_compound()
         or similar. This can be done easily by passing vrna_fold_compound() a model details parameter
         with vrna_md_t.uniq_ML = 1.<br>
         vrna_pf() has to be called first to fill the partition function matrices

 @note This function is polymorphic. It accepts #vrna_fold_compound_t of type
       #VRNA_FC_TYPE_SINGLE, and #VRNA_FC_TYPE_COMPARATIVE.

 @warning  In non-redundant sampling mode (#VRNA_PBACKTRACK_NON_REDUNDANT), this function may
           not yield the full number of requested samples. This may happen if
           a)  the number of requested structures is larger than the total number
               of structuresin the ensemble,
           b)  numeric instabilities prevent the backtracking function to enumerate
               structures with high free energies, or
           c)  any other error occurs.

 @see  vrna_pbacktrack(), vrna_pbacktrack_num(), vrna_pbacktrack5_cb(),
       #VRNA_PBACKTRACK_DEFAULT, #VRNA_PBACKTRACK_NON_REDUNDANT

 @param  fc            The fold compound data structure
 @param  num_samples   The size of the sample set, i.e. number of structures
 @param  cb            The callback that receives the sampled structure
 @param  data          A data structure passed through to the callback @p cb
 @param  options       A bitwise OR-flag indicating the backtracing mode.
 @return               The number of structures actually backtraced
### Prototype
```c
unsigned int vrna_pbacktrack_cb(vrna_fold_compound_t *fc, unsigned int num_samples, vrna_bs_result_f cb, void *data, unsigned int options);
```
"""
function vrna_pbacktrack_cb(fc, num_samples, cb, data, options)
    ccall((:vrna_pbacktrack_cb, libRNA), Cuint, (Ptr{vrna_fold_compound_t}, Cuint, vrna_bs_result_f, Ptr{Cvoid}, Cuint), fc, num_samples, cb, data, options)
end

"""
    vrna_pbacktrack_resume(fc, num_samples, nr_mem, options)

 @brief Obtain a set of secondary structure samples from the Boltzmann ensemble according their probability

 Perform a probabilistic (stochastic) backtracing in the partition function DP arrays
 to obtain a set of @p num_samples secondary structures.

 Any structure @f\$ s @f\$ with free energy @f\$ E(s) @f\$ is picked from the Boltzmann distributed
 ensemble according to its probability

 @f[
 p(s) = \\frac{exp(-E(s) / kT)}{Z}
 @f]

 with partition function @f\$ Z = \\sum_s exp(-E(s) / kT) @f\$, Boltzmann constant @f\$ k @f\$ and
 thermodynamic temperature @f\$ T @f\$.

 Using the @p options flag one can switch between regular (#VRNA_PBACKTRACK_DEFAULT) backtracing
 mode, and non-redundant sampling (#VRNA_PBACKTRACK_NON_REDUNDANT) along the lines of Michalik
 et al. 2017 @cite michalik:2017.

 In contrast to vrna_pbacktrack_cb() this function allows for resuming a previous
 sampling round in specialized Boltzmann sampling, such as non-redundant backtracking.
 For that purpose, the user passes the address of a Boltzmann sampling data structure
 (#vrna_pbacktrack_mem_t) which will be re-used in each round of sampling, i.e. each
 successive call to vrna_pbacktrack_resume_cb() or vrna_pbacktrack_resume().

 A successive sample call to this function may look like:
@code{.c}
vrna_pbacktrack_mem_t nonredundant_memory = NULL;

// sample the first 100 structures
vrna_pbacktrack_resume(fc,
                       100,
                       &nonredundant_memory,
                       options);

// sample another 500 structures
vrna_pbacktrack_resume(fc,
                       500,
                       &nonredundant_memory,
                       options);

// release memory occupied by the non-redundant memory data structure
vrna_pbacktrack_mem_free(nonredundant_memory);
@endcode

 @pre    Unique multiloop decomposition has to be active upon creation of @p fc with vrna_fold_compound()
         or similar. This can be done easily by passing vrna_fold_compound() a model details parameter
         with vrna_md_t.uniq_ML = 1.<br>
         vrna_pf() has to be called first to fill the partition function matrices

 @note This function is polymorphic. It accepts #vrna_fold_compound_t of type
       #VRNA_FC_TYPE_SINGLE, and #VRNA_FC_TYPE_COMPARATIVE.

 @warning  In non-redundant sampling mode (#VRNA_PBACKTRACK_NON_REDUNDANT), this function may
           not yield the full number of requested samples. This may happen if
           a)  the number of requested structures is larger than the total number
               of structuresin the ensemble,
           b)  numeric instabilities prevent the backtracking function to enumerate
               structures with high free energies, or
           c)  any other error occurs.

 @see  vrna_pbacktrack_resume_cb(), vrna_pbacktrack_cb(), vrna_pbacktrack5_resume(),
       #vrna_pbacktrack_mem_t, #VRNA_PBACKTRACK_DEFAULT, #VRNA_PBACKTRACK_NON_REDUNDANT,
       vrna_pbacktrack_mem_free

 @param  fc            The fold compound data structure
 @param  num_samples   The size of the sample set, i.e. number of structures
 @param  nr_mem        The address of the Boltzmann sampling memory data structure
 @param  options       A bitwise OR-flag indicating the backtracing mode.
 @return               A set of secondary structure samples in dot-bracket notation terminated by NULL (or NULL on error)
### Prototype
```c
char ** vrna_pbacktrack_resume(vrna_fold_compound_t *fc, unsigned int num_samples, vrna_pbacktrack_mem_t *nr_mem, unsigned int options);
```
"""
function vrna_pbacktrack_resume(fc, num_samples, nr_mem, options)
    ccall((:vrna_pbacktrack_resume, libRNA), Ptr{Ptr{Cchar}}, (Ptr{vrna_fold_compound_t}, Cuint, Ptr{vrna_pbacktrack_mem_t}, Cuint), fc, num_samples, nr_mem, options)
end

"""
    vrna_pbacktrack_resume_cb(fc, num_samples, cb, data, nr_mem, options)

 @brief Obtain a set of secondary structure samples from the Boltzmann ensemble according their probability

 Perform a probabilistic (stochastic) backtracing in the partition function DP arrays
 to obtain a set of @p num_samples secondary structures.

 Any structure @f\$ s @f\$ with free energy @f\$ E(s) @f\$ is picked from the Boltzmann distributed
 ensemble according to its probability

 @f[
 p(s) = \\frac{exp(-E(s) / kT)}{Z}
 @f]

 with partition function @f\$ Z = \\sum_s exp(-E(s) / kT) @f\$, Boltzmann constant @f\$ k @f\$ and
 thermodynamic temperature @f\$ T @f\$.

 Using the @p options flag one can switch between regular (#VRNA_PBACKTRACK_DEFAULT) backtracing
 mode, and non-redundant sampling (#VRNA_PBACKTRACK_NON_REDUNDANT) along the lines of Michalik
 et al. 2017 @cite michalik:2017.

 In contrast to vrna_pbacktrack5_resume() this function yields the structure samples
 through a callback mechanism.

 A successive sample call to this function may look like:
@code{.c}
vrna_pbacktrack_mem_t nonredundant_memory = NULL;

// sample the first 100 structures
vrna_pbacktrack5_resume_cb(fc,
                           100,
                           &callback_function,
                           (void *)&callback_data,
                           &nonredundant_memory,
                           options);

// sample another 500 structures
vrna_pbacktrack5_resume_cb(fc,
                           500,
                           &callback_function,
                           (void *)&callback_data,
                           &nonredundant_memory,
                           options);

// release memory occupied by the non-redundant memory data structure
vrna_pbacktrack_mem_free(nonredundant_memory);
@endcode

 @pre    Unique multiloop decomposition has to be active upon creation of @p fc with vrna_fold_compound()
         or similar. This can be done easily by passing vrna_fold_compound() a model details parameter
         with vrna_md_t.uniq_ML = 1.<br>
         vrna_pf() has to be called first to fill the partition function matrices

 @note This function is polymorphic. It accepts #vrna_fold_compound_t of type
       #VRNA_FC_TYPE_SINGLE, and #VRNA_FC_TYPE_COMPARATIVE.

 @warning  In non-redundant sampling mode (#VRNA_PBACKTRACK_NON_REDUNDANT), this function may
           not yield the full number of requested samples. This may happen if
           a)  the number of requested structures is larger than the total number
               of structuresin the ensemble,
           b)  numeric instabilities prevent the backtracking function to enumerate
               structures with high free energies, or
           c)  any other error occurs.

 @see  vrna_pbacktrack_resume(), vrna_pbacktrack_cb(), vrna_pbacktrack5_resume_cb(),
       #vrna_pbacktrack_mem_t, #VRNA_PBACKTRACK_DEFAULT, #VRNA_PBACKTRACK_NON_REDUNDANT,
       vrna_pbacktrack_mem_free

 @param  fc            The fold compound data structure
 @param  num_samples   The size of the sample set, i.e. number of structures
 @param  cb            The callback that receives the sampled structure
 @param  data          A data structure passed through to the callback @p cb
 @param  nr_mem        The address of the Boltzmann sampling memory data structure
 @param  options       A bitwise OR-flag indicating the backtracing mode.
 @return               The number of structures actually backtraced
### Prototype
```c
unsigned int vrna_pbacktrack_resume_cb(vrna_fold_compound_t *fc, unsigned int num_samples, vrna_bs_result_f cb, void *data, vrna_pbacktrack_mem_t *nr_mem, unsigned int options);
```
"""
function vrna_pbacktrack_resume_cb(fc, num_samples, cb, data, nr_mem, options)
    ccall((:vrna_pbacktrack_resume_cb, libRNA), Cuint, (Ptr{vrna_fold_compound_t}, Cuint, vrna_bs_result_f, Ptr{Cvoid}, Ptr{vrna_pbacktrack_mem_t}, Cuint), fc, num_samples, cb, data, nr_mem, options)
end

"""
    vrna_pbacktrack_sub(fc, start, _end)

 @brief Sample a secondary structure of a subsequence from the Boltzmann ensemble according its probability

 Perform a probabilistic (stochastic) backtracing in the partition function DP arrays
 to obtain a secondary structure. The parameters @p start and @p end specify the interval
 @f\$ [start:end] @f\$ of the subsequence with @f\$ 1 \\leq start < end \\leq n@f\$ for sequence length @f\$ n @f\$,
 the structure @f\$ s_{start,end} @f\$ should be drawn from.

 The resulting substructure @f\$ s_{start,end} @f\$ with free energy @f\$ E(s_{start, end}) @f\$ is picked from
 the Boltzmann distributed sub ensemble of all structures within the interval @f\$ [start:end] @f\$ according
 to its probability

 @f[
 p(s_{start,end}) = \\frac{exp(-E(s_{start,end}) / kT)}{Z_{start,end}}
 @f]

 with partition function @f\$ Z_{start,end} = \\sum_{s_{start,end}} exp(-E(s_{start,end}) / kT) @f\$,
 Boltzmann constant @f\$ k @f\$ and thermodynamic temperature @f\$ T @f\$.

 @pre    Unique multiloop decomposition has to be active upon creation of @p fc with vrna_fold_compound()
         or similar. This can be done easily by passing vrna_fold_compound() a model details parameter
         with vrna_md_t.uniq_ML = 1.<br>
         vrna_pf() has to be called first to fill the partition function matrices

 @note This function is polymorphic. It accepts #vrna_fold_compound_t of type
       #VRNA_FC_TYPE_SINGLE, and #VRNA_FC_TYPE_COMPARATIVE.

 @see vrna_pbacktrack_sub_num(), vrna_pbacktrack_sub_cb(), vrna_pbacktrack()

 @param  fc      The fold compound data structure
 @param  start   The start of  the subsequence to consider, i.e. 5'-end position(1-based)
 @param  end     The end of the subsequence to consider, i.e. 3'-end position (1-based)
 @return         A sampled secondary structure in dot-bracket notation (or NULL on error)
### Prototype
```c
char * vrna_pbacktrack_sub(vrna_fold_compound_t *fc, unsigned int start, unsigned int end);
```
"""
function vrna_pbacktrack_sub(fc, start, _end)
    ccall((:vrna_pbacktrack_sub, libRNA), Ptr{Cchar}, (Ptr{vrna_fold_compound_t}, Cuint, Cuint), fc, start, _end)
end

"""
    vrna_pbacktrack_sub_num(fc, num_samples, start, _end, options)

 @brief Obtain a set of secondary structure samples for a subsequence from the Boltzmann ensemble according their probability

 Perform a probabilistic (stochastic) backtracing in the partition function DP arrays
 to obtain a set of @p num_samples secondary structures. The parameter @p length specifies
 the length of the substructure starting from the 5' end.

 Any structure @f\$ s @f\$ with free energy @f\$ E(s) @f\$ is picked from the Boltzmann distributed
 ensemble according to its probability

 @f[
 p(s) = \\frac{exp(-E(s) / kT)}{Z}
 @f]

 with partition function @f\$ Z = \\sum_s exp(-E(s) / kT) @f\$, Boltzmann constant @f\$ k @f\$ and
 thermodynamic temperature @f\$ T @f\$.

 Using the @p options flag one can switch between regular (#VRNA_PBACKTRACK_DEFAULT) backtracing
 mode, and non-redundant sampling (#VRNA_PBACKTRACK_NON_REDUNDANT) along the lines of Michalik
 et al. 2017 @cite michalik:2017.

 @pre    Unique multiloop decomposition has to be active upon creation of @p fc with vrna_fold_compound()
         or similar. This can be done easily by passing vrna_fold_compound() a model details parameter
         with vrna_md_t.uniq_ML = 1.<br>
         vrna_pf() has to be called first to fill the partition function matrices

 @note This function is polymorphic. It accepts #vrna_fold_compound_t of type
       #VRNA_FC_TYPE_SINGLE, and #VRNA_FC_TYPE_COMPARATIVE.

 @warning  In non-redundant sampling mode (#VRNA_PBACKTRACK_NON_REDUNDANT), this function may
           not yield the full number of requested samples. This may happen if
           a)  the number of requested structures is larger than the total number
               of structuresin the ensemble,
           b)  numeric instabilities prevent the backtracking function to enumerate
               structures with high free energies, or
           c)  any other error occurs.

 @see  vrna_pbacktrack_sub(), vrna_pbacktrack_sub_cb(), vrna_pbacktrack_num(),
       #VRNA_PBACKTRACK_DEFAULT, #VRNA_PBACKTRACK_NON_REDUNDANT

 @param  fc            The fold compound data structure
 @param  num_samples   The size of the sample set, i.e. number of structures
 @param  start         The start of  the subsequence to consider, i.e. 5'-end position(1-based)
 @param  end           The end of the subsequence to consider, i.e. 3'-end position (1-based)
 @param  options       A bitwise OR-flag indicating the backtracing mode.
 @return               A set of secondary structure samples in dot-bracket notation terminated by NULL (or NULL on error)
### Prototype
```c
char ** vrna_pbacktrack_sub_num(vrna_fold_compound_t *fc, unsigned int num_samples, unsigned int start, unsigned int end, unsigned int options);
```
"""
function vrna_pbacktrack_sub_num(fc, num_samples, start, _end, options)
    ccall((:vrna_pbacktrack_sub_num, libRNA), Ptr{Ptr{Cchar}}, (Ptr{vrna_fold_compound_t}, Cuint, Cuint, Cuint, Cuint), fc, num_samples, start, _end, options)
end

"""
    vrna_pbacktrack_sub_cb(fc, num_samples, start, _end, cb, data, options)

 @brief Obtain a set of secondary structure samples for a subsequence from the Boltzmann ensemble according their probability

 Perform a probabilistic (stochastic) backtracing in the partition function DP arrays
 to obtain a set of @p num_samples secondary structures. The parameter @p length specifies
 the length of the substructure starting from the 5' end.

 Any structure @f\$ s @f\$ with free energy @f\$ E(s) @f\$ is picked from the Boltzmann distributed
 ensemble according to its probability

 @f[
 p(s) = \\frac{exp(-E(s) / kT)}{Z}
 @f]

 with partition function @f\$ Z = \\sum_s exp(-E(s) / kT) @f\$, Boltzmann constant @f\$ k @f\$ and
 thermodynamic temperature @f\$ T @f\$.

 Using the @p options flag one can switch between regular (#VRNA_PBACKTRACK_DEFAULT) backtracing
 mode, and non-redundant sampling (#VRNA_PBACKTRACK_NON_REDUNDANT) along the lines of Michalik
 et al. 2017 @cite michalik:2017.

 In contrast to vrna_pbacktrack5() and vrna_pbacktrack5_num() this function yields the
 structure samples through a callback mechanism.

 @pre    Unique multiloop decomposition has to be active upon creation of @p fc with vrna_fold_compound()
         or similar. This can be done easily by passing vrna_fold_compound() a model details parameter
         with vrna_md_t.uniq_ML = 1.<br>
         vrna_pf() has to be called first to fill the partition function matrices

 @note This function is polymorphic. It accepts #vrna_fold_compound_t of type
       #VRNA_FC_TYPE_SINGLE, and #VRNA_FC_TYPE_COMPARATIVE.

 @warning  In non-redundant sampling mode (#VRNA_PBACKTRACK_NON_REDUNDANT), this function may
           not yield the full number of requested samples. This may happen if
           a)  the number of requested structures is larger than the total number
               of structuresin the ensemble,
           b)  numeric instabilities prevent the backtracking function to enumerate
               structures with high free energies, or
           c)  any other error occurs.

 @see  vrna_pbacktrack5(), vrna_pbacktrack5_num(), vrna_pbacktrack_cb(),
       #VRNA_PBACKTRACK_DEFAULT, #VRNA_PBACKTRACK_NON_REDUNDANT

 @param  fc            The fold compound data structure
 @param  num_samples   The size of the sample set, i.e. number of structures
 @param  start         The start of  the subsequence to consider, i.e. 5'-end position(1-based)
 @param  end           The end of the subsequence to consider, i.e. 3'-end position (1-based)
 @param  cb            The callback that receives the sampled structure
 @param  data          A data structure passed through to the callback @p cb
 @param  options       A bitwise OR-flag indicating the backtracing mode.
 @return               The number of structures actually backtraced
### Prototype
```c
unsigned int vrna_pbacktrack_sub_cb(vrna_fold_compound_t *fc, unsigned int num_samples, unsigned int start, unsigned int end, vrna_bs_result_f cb, void *data, unsigned int options);
```
"""
function vrna_pbacktrack_sub_cb(fc, num_samples, start, _end, cb, data, options)
    ccall((:vrna_pbacktrack_sub_cb, libRNA), Cuint, (Ptr{vrna_fold_compound_t}, Cuint, Cuint, Cuint, vrna_bs_result_f, Ptr{Cvoid}, Cuint), fc, num_samples, start, _end, cb, data, options)
end

"""
    vrna_pbacktrack_sub_resume(fc, num_samples, start, _end, nr_mem, options)

 @brief Obtain a set of secondary structure samples for a subsequence from the Boltzmann ensemble according their probability

 Perform a probabilistic (stochastic) backtracing in the partition function DP arrays
 to obtain a set of @p num_samples secondary structures. The parameter @p length specifies
 the length of the substructure starting from the 5' end.

 Any structure @f\$ s @f\$ with free energy @f\$ E(s) @f\$ is picked from the Boltzmann distributed
 ensemble according to its probability

 @f[
 p(s) = \\frac{exp(-E(s) / kT)}{Z}
 @f]

 with partition function @f\$ Z = \\sum_s exp(-E(s) / kT) @f\$, Boltzmann constant @f\$ k @f\$ and
 thermodynamic temperature @f\$ T @f\$.

 Using the @p options flag one can switch between regular (#VRNA_PBACKTRACK_DEFAULT) backtracing
 mode, and non-redundant sampling (#VRNA_PBACKTRACK_NON_REDUNDANT) along the lines of Michalik
 et al. 2017 @cite michalik:2017.

 In contrast to vrna_pbacktrack5_cb() this function allows for resuming a previous
 sampling round in specialized Boltzmann sampling, such as non-redundant backtracking.
 For that purpose, the user passes the address of a Boltzmann sampling data structure
 (#vrna_pbacktrack_mem_t) which will be re-used in each round of sampling, i.e. each
 successive call to vrna_pbacktrack5_resume_cb() or vrna_pbacktrack5_resume().

 A successive sample call to this function may look like:
@code{.c}
vrna_pbacktrack_mem_t nonredundant_memory = NULL;

// sample the first 100 structures
vrna_pbacktrack5_resume(fc,
                        100,
                        fc->length,
                        &nonredundant_memory,
                        options);

// sample another 500 structures
vrna_pbacktrack5_resume(fc,
                        500,
                        fc->length,
                        &nonredundant_memory,
                        options);

// release memory occupied by the non-redundant memory data structure
vrna_pbacktrack_mem_free(nonredundant_memory);
@endcode

 @pre    Unique multiloop decomposition has to be active upon creation of @p fc with vrna_fold_compound()
         or similar. This can be done easily by passing vrna_fold_compound() a model details parameter
         with vrna_md_t.uniq_ML = 1.<br>
         vrna_pf() has to be called first to fill the partition function matrices

 @note This function is polymorphic. It accepts #vrna_fold_compound_t of type
       #VRNA_FC_TYPE_SINGLE, and #VRNA_FC_TYPE_COMPARATIVE.

 @warning  In non-redundant sampling mode (#VRNA_PBACKTRACK_NON_REDUNDANT), this function may
           not yield the full number of requested samples. This may happen if
           a)  the number of requested structures is larger than the total number
               of structuresin the ensemble,
           b)  numeric instabilities prevent the backtracking function to enumerate
               structures with high free energies, or
           c)  any other error occurs.

 @see  vrna_pbacktrack5_resume_cb(), vrna_pbacktrack5_cb(), vrna_pbacktrack_resume(),
       #vrna_pbacktrack_mem_t, #VRNA_PBACKTRACK_DEFAULT, #VRNA_PBACKTRACK_NON_REDUNDANT,
       vrna_pbacktrack_mem_free

 @param  fc            The fold compound data structure
 @param  num_samples   The size of the sample set, i.e. number of structures
 @param  start         The start of  the subsequence to consider, i.e. 5'-end position(1-based)
 @param  end           The end of the subsequence to consider, i.e. 3'-end position (1-based)
 @param  nr_mem        The address of the Boltzmann sampling memory data structure
 @param  options       A bitwise OR-flag indicating the backtracing mode.
 @return               A set of secondary structure samples in dot-bracket notation terminated by NULL (or NULL on error)
### Prototype
```c
char ** vrna_pbacktrack_sub_resume(vrna_fold_compound_t *fc, unsigned int num_samples, unsigned int start, unsigned int end, vrna_pbacktrack_mem_t *nr_mem, unsigned int options);
```
"""
function vrna_pbacktrack_sub_resume(fc, num_samples, start, _end, nr_mem, options)
    ccall((:vrna_pbacktrack_sub_resume, libRNA), Ptr{Ptr{Cchar}}, (Ptr{vrna_fold_compound_t}, Cuint, Cuint, Cuint, Ptr{vrna_pbacktrack_mem_t}, Cuint), fc, num_samples, start, _end, nr_mem, options)
end

"""
    vrna_pbacktrack_sub_resume_cb(fc, num_samples, start, _end, cb, data, nr_mem, options)

 @brief Obtain a set of secondary structure samples for a subsequence from the Boltzmann ensemble according their probability

 Perform a probabilistic (stochastic) backtracing in the partition function DP arrays
 to obtain a set of @p num_samples secondary structures. The parameter @p length specifies
 the length of the substructure starting from the 5' end.

 Any structure @f\$ s @f\$ with free energy @f\$ E(s) @f\$ is picked from the Boltzmann distributed
 ensemble according to its probability

 @f[
 p(s) = \\frac{exp(-E(s) / kT)}{Z}
 @f]

 with partition function @f\$ Z = \\sum_s exp(-E(s) / kT) @f\$, Boltzmann constant @f\$ k @f\$ and
 thermodynamic temperature @f\$ T @f\$.

 Using the @p options flag one can switch between regular (#VRNA_PBACKTRACK_DEFAULT) backtracing
 mode, and non-redundant sampling (#VRNA_PBACKTRACK_NON_REDUNDANT) along the lines of Michalik
 et al. 2017 @cite michalik:2017.

 In contrast to vrna_pbacktrack5_resume() this function yields the structure samples
 through a callback mechanism.

 A successive sample call to this function may look like:
@code{.c}
vrna_pbacktrack_mem_t nonredundant_memory = NULL;

// sample the first 100 structures
vrna_pbacktrack5_resume_cb(fc,
                           100,
                           fc->length,
                           &callback_function,
                           (void *)&callback_data,
                           &nonredundant_memory,
                           options);

// sample another 500 structures
vrna_pbacktrack5_resume_cb(fc,
                           500,
                           fc->length,
                           &callback_function,
                           (void *)&callback_data,
                           &nonredundant_memory,
                           options);

// release memory occupied by the non-redundant memory data structure
vrna_pbacktrack_mem_free(nonredundant_memory);
@endcode

 @pre    Unique multiloop decomposition has to be active upon creation of @p fc with vrna_fold_compound()
         or similar. This can be done easily by passing vrna_fold_compound() a model details parameter
         with vrna_md_t.uniq_ML = 1.<br>
         vrna_pf() has to be called first to fill the partition function matrices

 @note This function is polymorphic. It accepts #vrna_fold_compound_t of type
       #VRNA_FC_TYPE_SINGLE, and #VRNA_FC_TYPE_COMPARATIVE.

 @warning  In non-redundant sampling mode (#VRNA_PBACKTRACK_NON_REDUNDANT), this function may
           not yield the full number of requested samples. This may happen if
           a)  the number of requested structures is larger than the total number
               of structuresin the ensemble,
           b)  numeric instabilities prevent the backtracking function to enumerate
               structures with high free energies, or
           c)  any other error occurs.

 @see  vrna_pbacktrack5_resume(), vrna_pbacktrack5_cb(), vrna_pbacktrack_resume_cb(),
       #vrna_pbacktrack_mem_t, #VRNA_PBACKTRACK_DEFAULT, #VRNA_PBACKTRACK_NON_REDUNDANT,
       vrna_pbacktrack_mem_free

 @param  fc            The fold compound data structure
 @param  num_samples   The size of the sample set, i.e. number of structures
 @param  start         The start of  the subsequence to consider, i.e. 5'-end position(1-based)
 @param  end           The end of the subsequence to consider, i.e. 3'-end position (1-based)
 @param  cb            The callback that receives the sampled structure
 @param  data          A data structure passed through to the callback @p cb
 @param  nr_mem        The address of the Boltzmann sampling memory data structure
 @param  options       A bitwise OR-flag indicating the backtracing mode.
 @return               The number of structures actually backtraced
### Prototype
```c
unsigned int vrna_pbacktrack_sub_resume_cb(vrna_fold_compound_t *fc, unsigned int num_samples, unsigned int start, unsigned int end, vrna_bs_result_f cb, void *data, vrna_pbacktrack_mem_t *nr_mem, unsigned int options);
```
"""
function vrna_pbacktrack_sub_resume_cb(fc, num_samples, start, _end, cb, data, nr_mem, options)
    ccall((:vrna_pbacktrack_sub_resume_cb, libRNA), Cuint, (Ptr{vrna_fold_compound_t}, Cuint, Cuint, Cuint, vrna_bs_result_f, Ptr{Cvoid}, Ptr{vrna_pbacktrack_mem_t}, Cuint), fc, num_samples, start, _end, cb, data, nr_mem, options)
end

"""
    vrna_pbacktrack_mem_free(s)

 @brief  Release memory occupied by a Boltzmann sampling memory data structure

 @see  #vrna_pbacktrack_mem_t, vrna_pbacktrack5_resume(), vrna_pbacktrack5_resume_cb(),
       vrna_pbacktrack_resume(), vrna_pbacktrack_resume_cb()

 @param  s   The non-redundancy memory data structure
### Prototype
```c
void vrna_pbacktrack_mem_free(vrna_pbacktrack_mem_t s);
```
"""
function vrna_pbacktrack_mem_free(s)
    ccall((:vrna_pbacktrack_mem_free, libRNA), Cvoid, (vrna_pbacktrack_mem_t,), s)
end

"""
    vrna_pf(fc, structure)

 @brief Compute the partition function @f\$Q@f\$ for a given RNA sequence, or sequence alignment

 If @a structure is not a NULL pointer on input, it contains on
 return a string consisting of the letters " . , | { } ( ) " denoting
 bases that are essentially unpaired, weakly paired, strongly paired without
 preference, weakly upstream (downstream) paired, or strongly up-
 (down-)stream paired bases, respectively.
 If the model's compute_bpp is set to 0 base pairing probabilities will not
 be computed (saving CPU time), otherwise after calculations took place #pr will
 contain the probability that bases @a i and @a j pair.

 @note This function is polymorphic. It accepts #vrna_fold_compound_t of type
       #VRNA_FC_TYPE_SINGLE, and #VRNA_FC_TYPE_COMPARATIVE.
       Also, this function may return #INF / 100. in case of contradicting constraints
       or numerical over-/underflow. In the latter case, a corresponding warning
       will be issued to @p stdout.

 @see  #vrna_fold_compound_t, vrna_fold_compound(), vrna_pf_fold(), vrna_pf_circfold(),
       vrna_fold_compound_comparative(), vrna_pf_alifold(), vrna_pf_circalifold(),
       vrna_db_from_probs(), vrna_exp_params(), vrna_aln_pinfo()

 @param[in,out]  fc              The fold compound data structure
 @param[in,out]  structure       A pointer to the character array where position-wise pairing propensity
                                 will be stored. (Maybe NULL)
 @return         The ensemble free energy @f\$G = -RT \\cdot \\log(Q) @f\$ in kcal/mol
### Prototype
```c
FLT_OR_DBL vrna_pf(vrna_fold_compound_t *fc, char *structure);
```
"""
function vrna_pf(fc, structure)
    ccall((:vrna_pf, libRNA), FLT_OR_DBL, (Ptr{vrna_fold_compound_t}, Ptr{Cchar}), fc, structure)
end

"""
    vrna_pf_dimer(fc, structure)

 @brief  Calculate partition function and base pair probabilities of
         nucleic acid/nucleic acid dimers

 This is the cofold partition function folding.

 @note This function may return #INF / 100. for the @p FA, @p FB, @p FAB, @p F0AB
       members of the output data structure in case of contradicting constraints
       or numerical over-/underflow. In the latter case, a corresponding warning
       will be issued to @p stdout.

 @see    vrna_fold_compound() for how to retrieve the necessary data structure

 @param  fc        the fold compound data structure
 @param  structure Will hold the structure or constraints
 @return           vrna_dimer_pf_t structure containing a set of energies needed for
                   concentration computations.
### Prototype
```c
vrna_dimer_pf_t vrna_pf_dimer(vrna_fold_compound_t *fc, char *structure);
```
"""
function vrna_pf_dimer(fc, structure)
    ccall((:vrna_pf_dimer, libRNA), vrna_dimer_pf_t, (Ptr{vrna_fold_compound_t}, Ptr{Cchar}), fc, structure)
end

"""
    vrna_pf_substrands(fc, complex_size)


### Prototype
```c
FLT_OR_DBL * vrna_pf_substrands(vrna_fold_compound_t *fc, size_t complex_size);
```
"""
function vrna_pf_substrands(fc, complex_size)
    ccall((:vrna_pf_substrands, libRNA), Ptr{FLT_OR_DBL}, (Ptr{vrna_fold_compound_t}, Csize_t), fc, complex_size)
end

"""
    vrna_pf_add(dG1, dG2, kT)


### Prototype
```c
FLT_OR_DBL vrna_pf_add(FLT_OR_DBL dG1, FLT_OR_DBL dG2, double kT);
```
"""
function vrna_pf_add(dG1, dG2, kT)
    ccall((:vrna_pf_add, libRNA), FLT_OR_DBL, (FLT_OR_DBL, FLT_OR_DBL, Cdouble), dG1, dG2, kT)
end

"""
    vrna_pf_fold(sequence, structure, pl)

 @brief  Compute Partition function @f\$Q@f\$ (and base pair probabilities) for an RNA
         sequence using a comparative method

 This simplified interface to vrna_pf() computes the partition function and, if required,
 base pair probabilities for an RNA sequence using default options. Memory required for
 dynamic programming (DP) matrices will be allocated and free'd on-the-fly. Hence, after return of
 this function, the recursively filled matrices are not available any more for any post-processing.

 @note In case you want to use the filled DP matrices for any subsequent post-processing step, or
       you require other conditions than specified by the default model details, use vrna_pf(),
       and the data structure #vrna_fold_compound_t instead.

 @see  vrna_pf_circfold(), vrna_pf(), vrna_fold_compound(), #vrna_fold_compound_t

 @param sequence   RNA sequence
 @param structure  A pointer to the character array where position-wise pairing propensity
                   will be stored. (Maybe NULL)
 @param pl         A pointer to a list of #vrna_ep_t to store pairing probabilities (Maybe NULL)
 @return           The ensemble free energy @f\$G = -RT \\cdot \\log(Q) @f\$ in kcal/mol
### Prototype
```c
float vrna_pf_fold(const char *sequence, char *structure, vrna_ep_t **pl);
```
"""
function vrna_pf_fold(sequence, structure, pl)
    ccall((:vrna_pf_fold, libRNA), Cfloat, (Ptr{Cchar}, Ptr{Cchar}, Ptr{Ptr{vrna_ep_t}}), sequence, structure, pl)
end

"""
    vrna_pf_circfold(sequence, structure, pl)

 @brief  Compute Partition function @f\$Q@f\$ (and base pair probabilities) for a circular
         RNA sequences using a comparative method

 This simplified interface to vrna_pf() computes the partition function and, if required,
 base pair probabilities for a circular RNA sequence using default options. Memory required for
 dynamic programming (DP) matrices will be allocated and free'd on-the-fly. Hence, after return of
 this function, the recursively filled matrices are not available any more for any post-processing.

 @note In case you want to use the filled DP matrices for any subsequent post-processing step, or
       you require other conditions than specified by the default model details, use vrna_pf(),
       and the data structure #vrna_fold_compound_t instead.

 Folding of circular RNA sequences is handled as a post-processing step of the forward
 recursions. See @cite hofacker:2006 for further details.

 @see vrna_pf_fold(), vrna_pf(), vrna_fold_compound(), #vrna_fold_compound_t

 @param sequence  A circular RNA sequence
 @param structure  A pointer to the character array where position-wise pairing propensity
                   will be stored. (Maybe NULL)
 @param pl         A pointer to a list of #vrna_ep_t to store pairing probabilities (Maybe NULL)
 @return           The ensemble free energy @f\$G = -RT \\cdot \\log(Q) @f\$ in kcal/mol
### Prototype
```c
float vrna_pf_circfold(const char *sequence, char *structure, vrna_ep_t **pl);
```
"""
function vrna_pf_circfold(sequence, structure, pl)
    ccall((:vrna_pf_circfold, libRNA), Cfloat, (Ptr{Cchar}, Ptr{Cchar}, Ptr{Ptr{vrna_ep_t}}), sequence, structure, pl)
end

"""
    vrna_pf_alifold(sequences, structure, pl)

 @brief  Compute Partition function @f\$Q@f\$ (and base pair probabilities) for an RNA
         sequence alignment using a comparative method

 This simplified interface to vrna_pf() computes the partition function and, if required,
 base pair probabilities for an RNA sequence alignment using default options. Memory required for
 dynamic programming (DP) matrices will be allocated and free'd on-the-fly. Hence, after return of
 this function, the recursively filled matrices are not available any more for any post-processing.

 @note In case you want to use the filled DP matrices for any subsequent post-processing step, or
       you require other conditions than specified by the default model details, use vrna_pf(),
       and the data structure #vrna_fold_compound_t instead.

 @see vrna_pf_circalifold(), vrna_pf(), vrna_fold_compound_comparative(), #vrna_fold_compound_t

 @param sequences  RNA sequence alignment
 @param structure  A pointer to the character array where position-wise pairing propensity
                   will be stored. (Maybe NULL)
 @param pl         A pointer to a list of #vrna_ep_t to store pairing probabilities (Maybe NULL)
 @return           The ensemble free energy @f\$G = -RT \\cdot \\log(Q) @f\$ in kcal/mol
### Prototype
```c
float vrna_pf_alifold(const char **sequences, char *structure, vrna_ep_t **pl);
```
"""
function vrna_pf_alifold(sequences, structure, pl)
    ccall((:vrna_pf_alifold, libRNA), Cfloat, (Ptr{Ptr{Cchar}}, Ptr{Cchar}, Ptr{Ptr{vrna_ep_t}}), sequences, structure, pl)
end

"""
    vrna_pf_circalifold(sequences, structure, pl)

 @brief  Compute Partition function @f\$Q@f\$ (and base pair probabilities) for an alignment
         of circular RNA sequences using a comparative method

 This simplified interface to vrna_pf() computes the partition function and, if required,
 base pair probabilities for an RNA sequence alignment using default options. Memory required for
 dynamic programming (DP) matrices will be allocated and free'd on-the-fly. Hence, after return of
 this function, the recursively filled matrices are not available any more for any post-processing.

 @note In case you want to use the filled DP matrices for any subsequent post-processing step, or
       you require other conditions than specified by the default model details, use vrna_pf(),
       and the data structure #vrna_fold_compound_t instead.

 Folding of circular RNA sequences is handled as a post-processing step of the forward
 recursions. See @cite hofacker:2006 for further details.

 @see vrna_pf_alifold(), vrna_pf(), vrna_fold_compound_comparative(), #vrna_fold_compound_t

 @param sequences  Sequence alignment of circular RNAs
 @param structure  A pointer to the character array where position-wise pairing propensity
                   will be stored. (Maybe NULL)
 @param pl         A pointer to a list of #vrna_ep_t to store pairing probabilities (Maybe NULL)
 @return           The ensemble free energy @f\$G = -RT \\cdot \\log(Q) @f\$ in kcal/mol
### Prototype
```c
float vrna_pf_circalifold(const char **sequences, char *structure, vrna_ep_t **pl);
```
"""
function vrna_pf_circalifold(sequences, structure, pl)
    ccall((:vrna_pf_circalifold, libRNA), Cfloat, (Ptr{Ptr{Cchar}}, Ptr{Cchar}, Ptr{Ptr{vrna_ep_t}}), sequences, structure, pl)
end

"""
    vrna_pf_co_fold(seq, structure, pl)

 @brief  Calculate partition function and base pair probabilities of
         nucleic acid/nucleic acid dimers

 This simplified interface to vrna_pf_dimer() computes the partition
 function and, if required, base pair probabilities for an RNA-RNA
 interaction using default options. Memory required for dynamic
 programming (DP) matrices will be allocated and free'd on-the-fly.
 Hence, after return of this function, the recursively filled matrices
 are not available any more for any post-processing.

 @note In case you want to use the filled DP matrices for any subsequent
       post-processing step, or you require other conditions than
       specified by the default model details, use vrna_pf_dimer(),
       and the data structure #vrna_fold_compound_t instead.

 @see  vrna_pf_dimer()

 @ingroup  pf_cofold
 @param seq        Two concatenated RNA sequences with a delimiting '&' in between
 @param structure  A pointer to the character array where position-wise pairing propensity
                   will be stored. (Maybe NULL)
 @param pl         A pointer to a list of #vrna_ep_t to store pairing probabilities (Maybe NULL)
 @return           vrna_dimer_pf_t structure containing a set of energies needed for
                   concentration computations.
### Prototype
```c
vrna_dimer_pf_t vrna_pf_co_fold(const char *seq, char *structure, vrna_ep_t **pl);
```
"""
function vrna_pf_co_fold(seq, structure, pl)
    ccall((:vrna_pf_co_fold, libRNA), vrna_dimer_pf_t, (Ptr{Cchar}, Ptr{Cchar}, Ptr{Ptr{vrna_ep_t}}), seq, structure, pl)
end

"""
    vrna_pf_float_precision()

 @brief  Find out whether partition function computations are using
         single precision floating points

 @ingroup  pf_fold

 @see #FLT_OR_DBL

 @return  1 if single precision is used, 0 otherwise
### Prototype
```c
int vrna_pf_float_precision(void);
```
"""
function vrna_pf_float_precision()
    ccall((:vrna_pf_float_precision, libRNA), Cint, ())
end

"""
    pf_fold_par(sequence, structure, parameters, calculate_bppm, is_constrained, is_circular)


### Prototype
```c
;
```
"""
function pf_fold_par(sequence, structure, parameters, calculate_bppm, is_constrained, is_circular)
    ccall((:pf_fold_par, libRNA), Cfloat, (Ptr{Cchar}, Ptr{Cchar}, Ptr{vrna_exp_param_t}, Cint, Cint, Cint), sequence, structure, parameters, calculate_bppm, is_constrained, is_circular)
end

"""
    pf_fold(sequence, structure)


### Prototype
```c
;
```
"""
function pf_fold(sequence, structure)
    ccall((:pf_fold, libRNA), Cfloat, (Ptr{Cchar}, Ptr{Cchar}), sequence, structure)
end

"""
    pf_circ_fold(sequence, structure)


### Prototype
```c
;
```
"""
function pf_circ_fold(sequence, structure)
    ccall((:pf_circ_fold, libRNA), Cfloat, (Ptr{Cchar}, Ptr{Cchar}), sequence, structure)
end

"""
    pbacktrack(sequence)


### Prototype
```c
;
```
"""
function pbacktrack(sequence)
    ccall((:pbacktrack, libRNA), Ptr{Cchar}, (Ptr{Cchar},), sequence)
end

"""
    pbacktrack5(sequence, length)


### Prototype
```c
;
```
"""
function pbacktrack5(sequence, length)
    ccall((:pbacktrack5, libRNA), Ptr{Cchar}, (Ptr{Cchar}, Cint), sequence, length)
end

"""
    pbacktrack_circ(sequence)


### Prototype
```c
;
```
"""
function pbacktrack_circ(sequence)
    ccall((:pbacktrack_circ, libRNA), Ptr{Cchar}, (Ptr{Cchar},), sequence)
end

"""
    free_pf_arrays()


### Prototype
```c
;
```
"""
function free_pf_arrays()
    ccall((:free_pf_arrays, libRNA), Cvoid, ())
end

"""
    update_pf_params(length)


### Prototype
```c
;
```
"""
function update_pf_params(length)
    ccall((:update_pf_params, libRNA), Cvoid, (Cint,), length)
end

"""
    update_pf_params_par(length, parameters)


### Prototype
```c
;
```
"""
function update_pf_params_par(length, parameters)
    ccall((:update_pf_params_par, libRNA), Cvoid, (Cint, Ptr{vrna_exp_param_t}), length, parameters)
end

"""
    export_bppm()


### Prototype
```c
;
```
"""
function export_bppm()
    ccall((:export_bppm, libRNA), Ptr{FLT_OR_DBL}, ())
end

"""
    get_pf_arrays(S_p, S1_p, ptype_p, qb_p, qm_p, q1k_p, qln_p)


### Prototype
```c
;
```
"""
function get_pf_arrays(S_p, S1_p, ptype_p, qb_p, qm_p, q1k_p, qln_p)
    ccall((:get_pf_arrays, libRNA), Cint, (Ptr{Ptr{Cshort}}, Ptr{Ptr{Cshort}}, Ptr{Ptr{Cchar}}, Ptr{Ptr{FLT_OR_DBL}}, Ptr{Ptr{FLT_OR_DBL}}, Ptr{Ptr{FLT_OR_DBL}}, Ptr{Ptr{FLT_OR_DBL}}), S_p, S1_p, ptype_p, qb_p, qm_p, q1k_p, qln_p)
end

"""
    get_subseq_F(i, j)


### Prototype
```c
;
```
"""
function get_subseq_F(i, j)
    ccall((:get_subseq_F, libRNA), Cdouble, (Cint, Cint), i, j)
end

"""
    mean_bp_distance(length)


### Prototype
```c
;
```
"""
function mean_bp_distance(length)
    ccall((:mean_bp_distance, libRNA), Cdouble, (Cint,), length)
end

"""
    mean_bp_distance_pr(length, pr)


### Prototype
```c
;
```
"""
function mean_bp_distance_pr(length, pr)
    ccall((:mean_bp_distance_pr, libRNA), Cdouble, (Cint, Ptr{FLT_OR_DBL}), length, pr)
end

"""
    stackProb(cutoff)


### Prototype
```c
;
```
"""
function stackProb(cutoff)
    ccall((:stackProb, libRNA), Ptr{vrna_ep_t}, (Cdouble,), cutoff)
end

"""
    init_pf_fold(length)


### Prototype
```c
;
```
"""
function init_pf_fold(length)
    ccall((:init_pf_fold, libRNA), Cvoid, (Cint,), length)
end

"""
    centroid(length, dist)


### Prototype
```c
;
```
"""
function centroid(length, dist)
    ccall((:centroid, libRNA), Ptr{Cchar}, (Cint, Ptr{Cdouble}), length, dist)
end

"""
    get_centroid_struct_gquad_pr(length, dist)


### Prototype
```c
;
```
"""
function get_centroid_struct_gquad_pr(length, dist)
    ccall((:get_centroid_struct_gquad_pr, libRNA), Ptr{Cchar}, (Cint, Ptr{Cdouble}), length, dist)
end

"""
    mean_bp_dist(length)


### Prototype
```c
;
```
"""
function mean_bp_dist(length)
    ccall((:mean_bp_dist, libRNA), Cdouble, (Cint,), length)
end

"""
    expLoopEnergy(u1, u2, type, type2, si1, sj1, sp1, sq1)


### Prototype
```c
;
```
"""
function expLoopEnergy(u1, u2, type, type2, si1, sj1, sp1, sq1)
    ccall((:expLoopEnergy, libRNA), Cdouble, (Cint, Cint, Cint, Cint, Cshort, Cshort, Cshort, Cshort), u1, u2, type, type2, si1, sj1, sp1, sq1)
end

"""
    expHairpinEnergy(u, type, si1, sj1, string)


### Prototype
```c
;
```
"""
function expHairpinEnergy(u, type, si1, sj1, string)
    ccall((:expHairpinEnergy, libRNA), Cdouble, (Cint, Cint, Cshort, Cshort, Ptr{Cchar}), u, type, si1, sj1, string)
end

"""
    assign_plist_gquad_from_pr(pl, length, cut_off)


### Prototype
```c
;
```
"""
function assign_plist_gquad_from_pr(pl, length, cut_off)
    ccall((:assign_plist_gquad_from_pr, libRNA), Cvoid, (Ptr{Ptr{vrna_ep_t}}, Cint, Cdouble), pl, length, cut_off)
end

# typedef void ( * vrna_probs_window_f ) ( FLT_OR_DBL * pr , int pr_size , int i , int max , unsigned int type , void * data )
"""
@brief Sliding window probability computation callback

@callback
@parblock
This function will be called for each probability data set in the sliding
window probability computation implementation of vrna_probs_window().
The argument @a type specifies the type of probability that is passed to
this function.
@endparblock

#### Types: ####
 * #VRNA_PROBS_WINDOW_BPP  - @copybrief #VRNA_PROBS_WINDOW_BPP
 * #VRNA_PROBS_WINDOW_UP   - @copybrief #VRNA_PROBS_WINDOW_UP
 * #VRNA_PROBS_WINDOW_PF   - @copybrief #VRNA_PROBS_WINDOW_PF

The above types usually come exclusively. However, for unpaired
probabilities, the #VRNA_PROBS_WINDOW_UP flag is OR-ed together
with one of the loop type contexts

 * #VRNA_EXT_LOOP  - @copybrief #VRNA_EXT_LOOP
 * #VRNA_HP_LOOP   - @copybrief #VRNA_HP_LOOP
 * #VRNA_INT_LOOP  - @copybrief #VRNA_INT_LOOP
 * #VRNA_MB_LOOP   - @copybrief #VRNA_MB_LOOP
 * #VRNA_ANY_LOOP  - @copybrief #VRNA_ANY_LOOP

to indicate the particular type of data available through the @p pr
pointer.

@see vrna_probs_window(), vrna_pfl_fold_up_cb()

@param pr      An array of probabilities
@param pr_size The length of the probability array
@param i       The i-position (5') of the probabilities
@param max     The (theoretical) maximum length of the probability array
@param type    The type of data that is provided
@param data    Auxiliary data
"""
const vrna_probs_window_f = Ptr{Cvoid}

# DEPRECATED
const vrna_probs_window_callback = Cvoid

"""
    vrna_probs_window(fc, ulength, options, cb, data)

 @brief  Compute various equilibrium probabilities under a sliding window approach

 This function applies a sliding window scan for the sequence provided with the
 argument @p fc and reports back equilibrium probabilities through the callback
 function @p cb. The data reported to the callback depends on the @p options flag.

 @note   The parameter @p ulength only affects computation and resulting data if unpaired
         probability computations are requested through the @p options flag.

 #### Options: ####
 * #VRNA_PROBS_WINDOW_BPP      - @copybrief #VRNA_PROBS_WINDOW_BPP
 * #VRNA_PROBS_WINDOW_UP       - @copybrief #VRNA_PROBS_WINDOW_UP
 * #VRNA_PROBS_WINDOW_UP_SPLIT - @copybrief #VRNA_PROBS_WINDOW_UP_SPLIT

 Options may be OR-ed together

 @see  vrna_pfl_fold_cb(), vrna_pfl_fold_up_cb()

 @param  fc            The fold compound with sequence data, model settings and precomputed energy parameters
 @param  ulength       The maximal length of an unpaired segment (only for unpaired probability computations)
 @param  cb            The callback function which collects the pair probability data for further processing
 @param  data          Some arbitrary data structure that is passed to the callback @p cb
 @param  options       Option flags to control the behavior of this function
 @return               0 on failure, non-zero on success
### Prototype
```c
int vrna_probs_window(vrna_fold_compound_t *fc, int ulength, unsigned int options, vrna_probs_window_f cb, void *data);
```
"""
function vrna_probs_window(fc, ulength, options, cb, data)
    ccall((:vrna_probs_window, libRNA), Cint, (Ptr{vrna_fold_compound_t}, Cint, Cuint, vrna_probs_window_f, Ptr{Cvoid}), fc, ulength, options, cb, data)
end

"""
    vrna_pfl_fold(sequence, window_size, max_bp_span, cutoff)

 @brief  Compute base pair probabilities using a sliding-window approach

 This is a simplified wrapper to vrna_probs_window() that given a nucleid acid sequence,
 a window size, a maximum base pair span, and a cutoff value computes the pair probabilities
 for any base pair in any window. The pair probabilities are returned as a list and the user
 has to take care to free() the memory occupied by the list.

 @note This function uses default model settings! For custom model settings, we refer to
       the function vrna_probs_window().<br>
       In case of any computation errors, this function returns @p NULL

 @see    vrna_probs_window(), vrna_pfl_fold_cb(), vrna_pfl_fold_up()

 @param  sequence      The nucleic acid input sequence
 @param  window_size   The size of the sliding window
 @param  max_bp_span   The maximum distance along the backbone between two nucleotides that form a base pairs
 @param  cutoff        A cutoff value that omits all pairs with lower probability
 @return               A list of base pair probabilities, terminated by an entry with #vrna_ep_t.i and #vrna_ep_t.j set to 0
### Prototype
```c
vrna_ep_t * vrna_pfl_fold(const char *sequence, int window_size, int max_bp_span, float cutoff);
```
"""
function vrna_pfl_fold(sequence, window_size, max_bp_span, cutoff)
    ccall((:vrna_pfl_fold, libRNA), Ptr{vrna_ep_t}, (Ptr{Cchar}, Cint, Cint, Cfloat), sequence, window_size, max_bp_span, cutoff)
end

"""
    vrna_pfl_fold_cb(sequence, window_size, max_bp_span, cb, data)

 @brief  Compute base pair probabilities using a sliding-window approach (callback version)

 This is a simplified wrapper to vrna_probs_window() that given a nucleid acid sequence,
 a window size, a maximum base pair span, and a cutoff value computes the pair probabilities
 for any base pair in any window. It is similar to vrna_pfl_fold() but uses a callback mechanism
 to return the pair probabilities.

 Read the details for vrna_probs_window() for details on the callback implementation!

 @note This function uses default model settings! For custom model settings, we refer to
       the function vrna_probs_window().

 @see    vrna_probs_window(), vrna_pfl_fold(), vrna_pfl_fold_up_cb()

 @param  sequence      The nucleic acid input sequence
 @param  window_size   The size of the sliding window
 @param  max_bp_span   The maximum distance along the backbone between two nucleotides that form a base pairs
 @param  cb            The callback function which collects the pair probability data for further processing
 @param  data          Some arbitrary data structure that is passed to the callback @p cb
 @return               0 on failure, non-zero on success
### Prototype
```c
int vrna_pfl_fold_cb(const char *sequence, int window_size, int max_bp_span, vrna_probs_window_f cb, void *data);
```
"""
function vrna_pfl_fold_cb(sequence, window_size, max_bp_span, cb, data)
    ccall((:vrna_pfl_fold_cb, libRNA), Cint, (Ptr{Cchar}, Cint, Cint, vrna_probs_window_f, Ptr{Cvoid}), sequence, window_size, max_bp_span, cb, data)
end

"""
    vrna_pfl_fold_up(sequence, ulength, window_size, max_bp_span)

 @brief  Compute probability of contiguous unpaired segments

 This is a simplified wrapper to vrna_probs_window() that given a nucleic acid sequence,
 a maximum length of unpaired segments (@p ulength), a window size, and a maximum base
 pair span computes the equilibrium probability of any segment not exceeding @p ulength.
 The probabilities to be unpaired are returned as a 1-based, 2-dimensional matrix with
 dimensions @f\$ N \\times M @f\$, where @f\$N@f\$ is the length of the sequence and @f\$M@f\$
 is the maximum segment length. As an example, the probability of a segment of size 5
 starting at position 100 is stored in the matrix entry @f\$X[100][5]@f\$.

 It is the users responsibility to free the memory occupied by this matrix.

 @note This function uses default model settings! For custom model settings, we refer to
       the function vrna_probs_window().

 @param  sequence      The nucleic acid input sequence
 @param  ulength       The maximal length of an unpaired segment
 @param  window_size   The size of the sliding window
 @param  max_bp_span   The maximum distance along the backbone between two nucleotides that form a base pairs
 @return               The probabilities to be unpaired for any segment not exceeding @p ulength
### Prototype
```c
double ** vrna_pfl_fold_up(const char *sequence, int ulength, int window_size, int max_bp_span);
```
"""
function vrna_pfl_fold_up(sequence, ulength, window_size, max_bp_span)
    ccall((:vrna_pfl_fold_up, libRNA), Ptr{Ptr{Cdouble}}, (Ptr{Cchar}, Cint, Cint, Cint), sequence, ulength, window_size, max_bp_span)
end

"""
    vrna_pfl_fold_up_cb(sequence, ulength, window_size, max_bp_span, cb, data)

 @brief  Compute probability of contiguous unpaired segments

 This is a simplified wrapper to vrna_probs_window() that given a nucleic acid sequence,
 a maximum length of unpaired segments (@p ulength), a window size, and a maximum base
 pair span computes the equilibrium probability of any segment not exceeding @p ulength.
 It is similar to vrna_pfl_fold_up() but uses a callback mechanism to return the unpaired
 probabilities.

 Read the details for vrna_probs_window() for details on the callback implementation!


 @note This function uses default model settings! For custom model settings, we refer to
       the function vrna_probs_window().

 @param  sequence      The nucleic acid input sequence
 @param  ulength       The maximal length of an unpaired segment
 @param  window_size   The size of the sliding window
 @param  max_bp_span   The maximum distance along the backbone between two nucleotides that form a base pairs
 @param  cb            The callback function which collects the pair probability data for further processing
 @param  data          Some arbitrary data structure that is passed to the callback @p cb
 @return               0 on failure, non-zero on success
### Prototype
```c
int vrna_pfl_fold_up_cb(const char *sequence, int ulength, int window_size, int max_bp_span, vrna_probs_window_f cb, void *data);
```
"""
function vrna_pfl_fold_up_cb(sequence, ulength, window_size, max_bp_span, cb, data)
    ccall((:vrna_pfl_fold_up_cb, libRNA), Cint, (Ptr{Cchar}, Cint, Cint, Cint, vrna_probs_window_f, Ptr{Cvoid}), sequence, ulength, window_size, max_bp_span, cb, data)
end

struct vrna_plot_layout_s
    length::Cuint
    x::Ptr{Cfloat}
    y::Ptr{Cfloat}
    arcs::Ptr{Cdouble}
    bbox::NTuple{4, Cint}
end

"""
 @brief  RNA secondary structure figure layout

 @see  vrna_plot_layout(), vrna_plot_layout_free(), vrna_plot_layout_simple(),
       vrna_plot_layout_circular(), vrna_plot_layout_naview(), vrna_plot_layout_turtle(),
       vrna_plot_layout_puzzler()
"""
const vrna_plot_layout_t = vrna_plot_layout_s

"""
    vrna_plot_coords_turtle(structure, x, y, arc_coords)

 @brief Compute nucleotide coordinates for secondary structure plot using the <i>RNAturtle</i> algorithm @cite wiegreffe:2018

 This function basically is a wrapper to vrna_plot_coords() that passes the @p plot_type #VRNA_PLOT_TYPE_TURTLE.

 Here is a simple example how to use this function, assuming variable @p structure contains
 a valid dot-bracket string:
 @code{.c}
 float  *x, *y;
 double *arcs;

 if (vrna_plot_coords_turtle(structure, &x, &y, &arcs)) {
   printf("all fine");
 } else {
   printf("some failure occured!");
 }

 free(x);
 free(y);
 free(arcs);
 @endcode

 @note On success, this function allocates memory for X, Y and arc coordinates and assigns
 the pointers at addressess @p x, @p y and @p arc_coords to the corresponding memory locations. It's
 the users responsibility to cleanup this memory after usage!

 @see  vrna_plot_coords(), vrna_plot_coords_turtle_pt(), vrna_plot_coords_circular(),
       vrna_plot_coords_simple(), vrna_plot_coords_naview(), vrna_plot_coords_puzzler()

 @param        structure   The secondary structure in dot-bracket notation
 @param[inout] x           The address of a pointer of X coordinates (pointer will point to memory, or NULL on failure)
 @param[inout] y           The address of a pointer of Y coordinates (pointer will point to memory, or NULL on failure)
 @param[inout] arc_coords  The address of a pointer that will hold arc coordinates (pointer will point to memory, or NULL on failure)
 @return                   The length of the structure on success, 0 otherwise
### Prototype
```c
int vrna_plot_coords_turtle(const char *structure, float **x, float **y, double **arc_coords);
```
"""
function vrna_plot_coords_turtle(structure, x, y, arc_coords)
    ccall((:vrna_plot_coords_turtle, libRNA), Cint, (Ptr{Cchar}, Ptr{Ptr{Cfloat}}, Ptr{Ptr{Cfloat}}, Ptr{Ptr{Cdouble}}), structure, x, y, arc_coords)
end

"""
    vrna_plot_coords_turtle_pt(pair_table, x, y, arc_coords)

 @brief Compute nucleotide coordinates for secondary structure plot using the <i>RNAturtle</i> algorithm @cite wiegreffe:2018

 Same as vrna_plot_coords_turtle() but takes a pair table with the structure
 information as input.

 @note On success, this function allocates memory for X, Y and arc coordinates and assigns
 the pointers at addressess @p x, @p y and @p arc_coords to the corresponding memory locations. It's
 the users responsibility to cleanup this memory after usage!

 @see  vrna_plot_coords_pt(), vrna_plot_coords_turtle(), vrna_plot_coords_circular_pt(),
       vrna_plot_coords_simple_pt(), vrna_plot_coords_puzzler_pt(), vrna_plot_coords_naview_pt()

 @param        pt          The pair table that holds the secondary structure
 @param[inout] x           The address of a pointer of X coordinates (pointer will point to memory, or NULL on failure)
 @param[inout] y           The address of a pointer of Y coordinates (pointer will point to memory, or NULL on failure)
 @param[inout] arc_coords  The address of a pointer that will hold arc coordinates (pointer will point to memory, or NULL on failure)
 @return                   The length of the structure on success, 0 otherwise
### Prototype
```c
int vrna_plot_coords_turtle_pt(short const *const pair_table, float **x, float **y, double **arc_coords);
```
"""
function vrna_plot_coords_turtle_pt(pair_table, x, y, arc_coords)
    ccall((:vrna_plot_coords_turtle_pt, libRNA), Cint, (Ptr{Cshort}, Ptr{Ptr{Cfloat}}, Ptr{Ptr{Cfloat}}, Ptr{Ptr{Cdouble}}), pair_table, x, y, arc_coords)
end

"""
    vrna_plot_options_puzzler_t

 @brief  Options data structure for RNApuzzler algorithm implementation
"""
struct vrna_plot_options_puzzler_t
    drawArcs::Cshort
    paired::Cdouble
    unpaired::Cdouble
    checkAncestorIntersections::Cshort
    checkSiblingIntersections::Cshort
    checkExteriorIntersections::Cshort
    allowFlipping::Cshort
    optimize::Cshort
    maximumNumberOfConfigChangesAllowed::Cint
    config::Ptr{Cchar}
    filename::Ptr{Cchar}
    numberOfChangesAppliedToConfig::Cint
    psNumber::Cint
end

"""
    vrna_plot_coords_puzzler(structure, x, y, arc_coords, options)

 @brief Compute nucleotide coordinates for secondary structure plot using the <i>RNApuzzler</i> algorithm @cite wiegreffe:2018

 This function basically is a wrapper to vrna_plot_coords() that passes the @p plot_type #VRNA_PLOT_TYPE_PUZZLER.

 Here is a simple example how to use this function, assuming variable @p structure contains
 a valid dot-bracket string and using the default options (@p options = NULL):
 @code{.c}
 float  *x, *y;
 double *arcs;

 if (vrna_plot_coords_puzzler(structure, &x, &y, &arcs, NULL)) {
   printf("all fine");
 } else {
   printf("some failure occured!");
 }

 free(x);
 free(y);
 free(arcs);
 @endcode

 @note On success, this function allocates memory for X, Y and arc coordinates and assigns
 the pointers at addressess @p x, @p y and @p arc_coords to the corresponding memory locations. It's
 the users responsibility to cleanup this memory after usage!

 @see  vrna_plot_coords(), vrna_plot_coords_puzzler_pt(), vrna_plot_coords_circular(),
       vrna_plot_coords_simple(), vrna_plot_coords_turtle(), vrna_plot_coords_naview(),
       vrna_plot_options_puzzler()

 @param        structure   The secondary structure in dot-bracket notation
 @param[inout] x           The address of a pointer of X coordinates (pointer will point to memory, or NULL on failure)
 @param[inout] y           The address of a pointer of Y coordinates (pointer will point to memory, or NULL on failure)
 @param[inout] arc_coords  The address of a pointer that will hold arc coordinates (pointer will point to memory, or NULL on failure)
 @param        options     The options for the RNApuzzler algorithm (or NULL)
 @return                   The length of the structure on success, 0 otherwise
### Prototype
```c
int vrna_plot_coords_puzzler(const char *structure, float **x, float **y, double **arc_coords, vrna_plot_options_puzzler_t *options);
```
"""
function vrna_plot_coords_puzzler(structure, x, y, arc_coords, options)
    ccall((:vrna_plot_coords_puzzler, libRNA), Cint, (Ptr{Cchar}, Ptr{Ptr{Cfloat}}, Ptr{Ptr{Cfloat}}, Ptr{Ptr{Cdouble}}, Ptr{vrna_plot_options_puzzler_t}), structure, x, y, arc_coords, options)
end

"""
    vrna_plot_coords_puzzler_pt(pair_table, x, y, arc_coords, puzzler)

 @brief Compute nucleotide coordinates for secondary structure plot using the <i>RNApuzzler</i> algorithm @cite wiegreffe:2018

 Same as vrna_plot_coords_puzzler() but takes a pair table with the structure
 information as input.

 @note On success, this function allocates memory for X, Y and arc coordinates and assigns
 the pointers at addressess @p x, @p y and @p arc_coords to the corresponding memory locations. It's
 the users responsibility to cleanup this memory after usage!

 @see  vrna_plot_coords_pt(), vrna_plot_coords_puzzler(), vrna_plot_coords_circular_pt(),
       vrna_plot_coords_simple_pt(), vrna_plot_coords_turtle_pt(), vrna_plot_coords_naview_pt()

 @param        pt          The pair table that holds the secondary structure
 @param[inout] x           The address of a pointer of X coordinates (pointer will point to memory, or NULL on failure)
 @param[inout] y           The address of a pointer of Y coordinates (pointer will point to memory, or NULL on failure)
 @param[inout] arc_coords  The address of a pointer that will hold arc coordinates (pointer will point to memory, or NULL on failure)
 @param        options     The options for the RNApuzzler algorithm (or NULL)
 @return                   The length of the structure on success, 0 otherwise
### Prototype
```c
int vrna_plot_coords_puzzler_pt(short const *const pair_table, float **x, float **y, double **arc_coords, vrna_plot_options_puzzler_t *puzzler);
```
"""
function vrna_plot_coords_puzzler_pt(pair_table, x, y, arc_coords, puzzler)
    ccall((:vrna_plot_coords_puzzler_pt, libRNA), Cint, (Ptr{Cshort}, Ptr{Ptr{Cfloat}}, Ptr{Ptr{Cfloat}}, Ptr{Ptr{Cdouble}}, Ptr{vrna_plot_options_puzzler_t}), pair_table, x, y, arc_coords, puzzler)
end

"""
    vrna_plot_options_puzzler()

 @brief  Create an RNApuzzler options data structure

 @see    vrna_plot_options_puzzler_free(), vrna_plot_coords_puzzler(), vrna_plot_coords_puzzler_pt(),
         vrna_plot_layout_puzzler()

 @return An RNApuzzler options data structure with default settings
### Prototype
```c
vrna_plot_options_puzzler_t * vrna_plot_options_puzzler(void);
```
"""
function vrna_plot_options_puzzler()
    ccall((:vrna_plot_options_puzzler, libRNA), Ptr{vrna_plot_options_puzzler_t}, ())
end

"""
    vrna_plot_options_puzzler_free(options)

 @brief  Free memory occupied by an RNApuzzler options data structure

 @see    vrna_plot_options_puzzler(), vrna_plot_coords_puzzler(), vrna_plot_coords_puzzler_pt(),
         vrna_plot_layout_puzzler()

 @param  options   A pointer to the options data structure to free
### Prototype
```c
void vrna_plot_options_puzzler_free(vrna_plot_options_puzzler_t *options);
```
"""
function vrna_plot_options_puzzler_free(options)
    ccall((:vrna_plot_options_puzzler_free, libRNA), Cvoid, (Ptr{vrna_plot_options_puzzler_t},), options)
end

"""
    vrna_plot_layout(structure, plot_type)

 @brief  Create a layout (coordinates, etc.) for a secondary structure plot

 This function can be used to create a secondary structure nucleotide layout
 that is then further processed by an actual plotting function. The layout
 algorithm can be specified using the @p plot_type parameter, and the following
 algorithms are currently supported:
 - #VRNA_PLOT_TYPE_SIMPLE
 - #VRNA_PLOT_TYPE_NAVIEW
 - #VRNA_PLOT_TYPE_CIRCULAR
 - #VRNA_PLOT_TYPE_TURTLE
 - #VRNA_PLOT_TYPE_PUZZLER

 Passing an unsupported selection leads to the default algorithm #VRNA_PLOT_TYPE_NAVIEW

 @note If only X-Y coordinates of the corresponding structure layout are required, consider
       using vrna_plot_coords() instead!

 @see  vrna_plot_layout_free(), vrna_plot_layout_simple(), vrna_plot_layout_naview(),
       vrna_plot_layout_circular(), vrna_plot_layout_turtle(), vrna_plot_layout_puzzler(),
       vrna_plot_coords(), vrna_file_PS_rnaplot_layout()

 @param    structure   The secondary structure in dot-bracket notation
 @param    plot_type   The layout algorithm to be used
 @return               The layout data structure for the provided secondary structure
### Prototype
```c
vrna_plot_layout_t * vrna_plot_layout(const char *structure, unsigned int plot_type);
```
"""
function vrna_plot_layout(structure, plot_type)
    ccall((:vrna_plot_layout, libRNA), Ptr{vrna_plot_layout_t}, (Ptr{Cchar}, Cuint), structure, plot_type)
end

"""
    vrna_plot_layout_simple(structure)

 @brief  Create a layout (coordinates, etc.) for a <i>simple</i> secondary structure plot

 This function basically is a wrapper to vrna_plot_layout() that passes the @p plot_type #VRNA_PLOT_TYPE_SIMPLE.

 @note If only X-Y coordinates of the corresponding structure layout are required, consider
       using vrna_plot_coords_simple() instead!

 @see  vrna_plot_layout_free(), vrna_plot_layout(), vrna_plot_layout_naview(),
       vrna_plot_layout_circular(), vrna_plot_layout_turtle(), vrna_plot_layout_puzzler(),
       vrna_plot_coords_simple(), vrna_file_PS_rnaplot_layout()

 @param    structure   The secondary structure in dot-bracket notation
 @return               The layout data structure for the provided secondary structure
### Prototype
```c
vrna_plot_layout_t * vrna_plot_layout_simple(const char *structure);
```
"""
function vrna_plot_layout_simple(structure)
    ccall((:vrna_plot_layout_simple, libRNA), Ptr{vrna_plot_layout_t}, (Ptr{Cchar},), structure)
end

"""
    vrna_plot_layout_circular(structure)

 @brief  Create a layout (coordinates, etc.) for a <i>circular</i> secondary structure plot

 This function basically is a wrapper to vrna_plot_layout() that passes the @p plot_type #VRNA_PLOT_TYPE_CIRCULAR.

 @note If only X-Y coordinates of the corresponding structure layout are required, consider
       using vrna_plot_coords_circular() instead!

 @see  vrna_plot_layout_free(), vrna_plot_layout(), vrna_plot_layout_naview(),
       vrna_plot_layout_simple(), vrna_plot_layout_turtle(), vrna_plot_layout_puzzler(),
       vrna_plot_coords_circular(), vrna_file_PS_rnaplot_layout()

 @param    structure   The secondary structure in dot-bracket notation
 @return               The layout data structure for the provided secondary structure
### Prototype
```c
vrna_plot_layout_t * vrna_plot_layout_circular(const char *structure);
```
"""
function vrna_plot_layout_circular(structure)
    ccall((:vrna_plot_layout_circular, libRNA), Ptr{vrna_plot_layout_t}, (Ptr{Cchar},), structure)
end

"""
    vrna_plot_layout_turtle(structure)

 @brief  Create a layout (coordinates, etc.) for a secondary structure plot using the <i>Turtle Algorithm</i> @cite wiegreffe:2018

 This function basically is a wrapper to vrna_plot_layout() that passes the @p plot_type #VRNA_PLOT_TYPE_TURTLE.

 @note If only X-Y coordinates of the corresponding structure layout are required, consider
       using vrna_plot_coords_turtle() instead!

 @see  vrna_plot_layout_free(), vrna_plot_layout(), vrna_plot_layout_simple(),
       vrna_plot_layout_circular(), vrna_plot_layout_naview(), vrna_plot_layout_puzzler(),
       vrna_plot_coords_turtle(), vrna_file_PS_rnaplot_layout()

 @param    structure   The secondary structure in dot-bracket notation
 @return               The layout data structure for the provided secondary structure
### Prototype
```c
vrna_plot_layout_t * vrna_plot_layout_turtle(const char *structure);
```
"""
function vrna_plot_layout_turtle(structure)
    ccall((:vrna_plot_layout_turtle, libRNA), Ptr{vrna_plot_layout_t}, (Ptr{Cchar},), structure)
end

"""
    vrna_plot_layout_puzzler(structure, options)

 @brief  Create a layout (coordinates, etc.) for a secondary structure plot using the <i>RNApuzzler Algorithm</i> @cite wiegreffe:2018

 This function basically is a wrapper to vrna_plot_layout() that passes the @p plot_type #VRNA_PLOT_TYPE_PUZZLER.

 @note If only X-Y coordinates of the corresponding structure layout are required, consider
       using vrna_plot_coords_puzzler() instead!

 @see  vrna_plot_layout_free(), vrna_plot_layout(), vrna_plot_layout_simple(),
       vrna_plot_layout_circular(), vrna_plot_layout_naview(), vrna_plot_layout_turtle(),
       vrna_plot_coords_puzzler(), vrna_file_PS_rnaplot_layout()

 @param    structure   The secondary structure in dot-bracket notation
 @return               The layout data structure for the provided secondary structure
### Prototype
```c
vrna_plot_layout_t * vrna_plot_layout_puzzler(const char *structure, vrna_plot_options_puzzler_t *options);
```
"""
function vrna_plot_layout_puzzler(structure, options)
    ccall((:vrna_plot_layout_puzzler, libRNA), Ptr{vrna_plot_layout_t}, (Ptr{Cchar}, Ptr{vrna_plot_options_puzzler_t}), structure, options)
end

"""
    vrna_plot_layout_free(layout)

 @brief  Free memory occupied by a figure layout data structure

 @see  #vrna_plot_layout_t, vrna_plot_layout(), vrna_plot_layout_simple(),
       vrna_plot_layout_circular(), vrna_plot_layout_naview(), vrna_plot_layout_turtle(),
       vrna_plot_layout_puzzler(), vrna_file_PS_rnaplot_layout()

 @param  layout  The layout data structure to free
### Prototype
```c
void vrna_plot_layout_free(vrna_plot_layout_t *layout);
```
"""
function vrna_plot_layout_free(layout)
    ccall((:vrna_plot_layout_free, libRNA), Cvoid, (Ptr{vrna_plot_layout_t},), layout)
end

"""
    vrna_plot_coords(structure, x, y, plot_type)

 @brief Compute nucleotide coordinates for secondary structure plot

 This function takes a secondary structure and computes X-Y coordinates
 for each nucleotide that then can be used to create a structure plot.
 The parameter @p plot_type is used to select the underlying layout algorithm.
 Currently, the following selections are provided:
 - #VRNA_PLOT_TYPE_SIMPLE
 - #VRNA_PLOT_TYPE_NAVIEW
 - #VRNA_PLOT_TYPE_CIRCULAR
 - #VRNA_PLOT_TYPE_TURTLE
 - #VRNA_PLOT_TYPE_PUZZLER

 Passing an unsupported selection leads to the default algorithm #VRNA_PLOT_TYPE_NAVIEW

 Here is a simple example how to use this function, assuming variable @p structure contains
 a valid dot-bracket string:
 @code{.c}
 float *x, *y;

 if (vrna_plot_coords(structure, &x, &y)) {
   printf("all fine");
 } else {
   printf("some failure occured!");
 }

 free(x);
 free(y);
 @endcode

 @note On success, this function allocates memory for X and Y coordinates and assigns
       the pointers at addressess @p x and @p y to the corresponding memory locations. It's
       the users responsibility to cleanup this memory after usage!

 @see  vrna_plot_coords_pt(), vrna_plot_coords_simple(), vrna_plot_coords_naview()
       vrna_plot_coords_circular(), vrna_plot_coords_turtle(), vrna_plot_coords_puzzler()

 @param        structure   The secondary structure in dot-bracket notation
 @param[inout] x           The address of a pointer of X coordinates (pointer will point to memory, or NULL on failure)
 @param[inout] y           The address of a pointer of Y coordinates (pointer will point to memory, or NULL on failure)
 @param        plot_type   The layout algorithm to be used
 @return                   The length of the structure on success, 0 otherwise
### Prototype
```c
int vrna_plot_coords(const char *structure, float **x, float **y, int plot_type);
```
"""
function vrna_plot_coords(structure, x, y, plot_type)
    ccall((:vrna_plot_coords, libRNA), Cint, (Ptr{Cchar}, Ptr{Ptr{Cfloat}}, Ptr{Ptr{Cfloat}}, Cint), structure, x, y, plot_type)
end

"""
    vrna_plot_coords_pt(pt, x, y, plot_type)

 @brief Compute nucleotide coordinates for secondary structure plot

 Same as vrna_plot_coords() but takes a pair table with the structure
 information as input.

 @note On success, this function allocates memory for X and Y coordinates and assigns
       the pointers at addressess @p x and @p y to the corresponding memory locations. It's
       the users responsibility to cleanup this memory after usage!

 @see  vrna_plot_coords(), vrna_plot_coords_simple_pt(), vrna_plot_coords_naview_pt()
       vrna_plot_coords_circular_pt(), vrna_plot_coords_turtle_pt(), vrna_plot_coords_puzzler_pt()

 @param        pt          The pair table that holds the secondary structure
 @param[inout] x           The address of a pointer of X coordinates (pointer will point to memory, or NULL on failure)
 @param[inout] y           The address of a pointer of Y coordinates (pointer will point to memory, or NULL on failure)
 @param        plot_type   The layout algorithm to be used
 @return                   The length of the structure on success, 0 otherwise
### Prototype
```c
int vrna_plot_coords_pt(const short *pt, float **x, float **y, int plot_type);
```
"""
function vrna_plot_coords_pt(pt, x, y, plot_type)
    ccall((:vrna_plot_coords_pt, libRNA), Cint, (Ptr{Cshort}, Ptr{Ptr{Cfloat}}, Ptr{Ptr{Cfloat}}, Cint), pt, x, y, plot_type)
end

"""
    vrna_plot_coords_simple(structure, x, y)

 @brief Compute nucleotide coordinates for secondary structure plot the <i>Simple way</i>

 This function basically is a wrapper to vrna_plot_coords() that passes the @p plot_type #VRNA_PLOT_TYPE_SIMPLE.

 Here is a simple example how to use this function, assuming variable @p structure contains
 a valid dot-bracket string:
 @code{.c}
 float *x, *y;

 if (vrna_plot_coords_simple(structure, &x, &y)) {
   printf("all fine");
 } else {
   printf("some failure occured!");
 }

 free(x);
 free(y);
 @endcode

 @note On success, this function allocates memory for X and Y coordinates and assigns
       the pointers at addressess @p x and @p y to the corresponding memory locations. It's
       the users responsibility to cleanup this memory after usage!

 @see  vrna_plot_coords(), vrna_plot_coords_simple_pt(), vrna_plot_coords_circular(),
       vrna_plot_coords_naview(), vrna_plot_coords_turtle(), vrna_plot_coords_puzzler()

 @param        structure   The secondary structure in dot-bracket notation
 @param[inout] x           The address of a pointer of X coordinates (pointer will point to memory, or NULL on failure)
 @param[inout] y           The address of a pointer of Y coordinates (pointer will point to memory, or NULL on failure)
 @return                   The length of the structure on success, 0 otherwise
### Prototype
```c
int vrna_plot_coords_simple(const char *structure, float **x, float **y);
```
"""
function vrna_plot_coords_simple(structure, x, y)
    ccall((:vrna_plot_coords_simple, libRNA), Cint, (Ptr{Cchar}, Ptr{Ptr{Cfloat}}, Ptr{Ptr{Cfloat}}), structure, x, y)
end

"""
    vrna_plot_coords_simple_pt(pt, x, y)

 @brief Compute nucleotide coordinates for secondary structure plot the <i>Simple way</i>

 Same as vrna_plot_coords_simple() but takes a pair table with the structure
 information as input.

 @note On success, this function allocates memory for X and Y coordinates and assigns
       the pointers at addressess @p x and @p y to the corresponding memory locations. It's
       the users responsibility to cleanup this memory after usage!

 @see  vrna_plot_coords_pt(), vrna_plot_coords_simple(), vrna_plot_coords_circular_pt(),
       vrna_plot_coords_naview_pt(), vrna_plot_coords_turtle_pt(), vrna_plot_coords_puzzler_pt()

 @param        pt          The pair table that holds the secondary structure
 @param[inout] x           The address of a pointer of X coordinates (pointer will point to memory, or NULL on failure)
 @param[inout] y           The address of a pointer of Y coordinates (pointer will point to memory, or NULL on failure)
 @return                   The length of the structure on success, 0 otherwise
### Prototype
```c
int vrna_plot_coords_simple_pt(const short *pt, float **x, float **y);
```
"""
function vrna_plot_coords_simple_pt(pt, x, y)
    ccall((:vrna_plot_coords_simple_pt, libRNA), Cint, (Ptr{Cshort}, Ptr{Ptr{Cfloat}}, Ptr{Ptr{Cfloat}}), pt, x, y)
end

"""
    vrna_plot_coords_circular(structure, x, y)

 @brief Compute coordinates of nucleotides mapped in equal distancies onto a unit circle.

 This function basically is a wrapper to vrna_plot_coords() that passes the @p plot_type #VRNA_PLOT_TYPE_CIRCULAR.

 In order to draw nice arcs using quadratic bezier curves that connect base pairs one may calculate
 a second tangential point @f\$P^t@f\$ in addition to the actual R<sup>2</sup> coordinates.
 the simplest way to do so may be to compute a radius scaling factor @f\$rs@f\$ in the interval @f\$[0,1]@f\$ that
 weights the proportion of base pair span to the actual length of the sequence. This scaling factor
 can then be used to calculate the coordinates for @f\$P^t@f\$, i.e.

 @f[ P^{t}_x[i] = X[i] * rs @f]

 and

 @f[ P^{t}_y[i] = Y[i] * rs @f].

 @note On success, this function allocates memory for X and Y coordinates and assigns
       the pointers at addressess @p x and @p y to the corresponding memory locations. It's
       the users responsibility to cleanup this memory after usage!

 @see  vrna_plot_coords(), vrna_plot_coords_circular_pt(), vrna_plot_coords_simple(),
       vrna_plot_coords_naview(), vrna_plot_coords_turtle(), vrna_plot_coords_puzzler()

 @param        structure   The secondary structure in dot-bracket notation
 @param[inout] x           The address of a pointer of X coordinates (pointer will point to memory, or NULL on failure)
 @param[inout] y           The address of a pointer of Y coordinates (pointer will point to memory, or NULL on failure)
 @return                   The length of the structure on success, 0 otherwise
### Prototype
```c
int vrna_plot_coords_circular(const char *structure, float **x, float **y);
```
"""
function vrna_plot_coords_circular(structure, x, y)
    ccall((:vrna_plot_coords_circular, libRNA), Cint, (Ptr{Cchar}, Ptr{Ptr{Cfloat}}, Ptr{Ptr{Cfloat}}), structure, x, y)
end

"""
    vrna_plot_coords_circular_pt(pt, x, y)

 @brief Compute nucleotide coordinates for a <i>Circular Plot</i>

 Same as vrna_plot_coords_circular() but takes a pair table with the structure
 information as input.

 @note On success, this function allocates memory for X and Y coordinates and assigns
       the pointers at addressess @p x and @p y to the corresponding memory locations. It's
       the users responsibility to cleanup this memory after usage!

 @see  vrna_plot_coords_pt(), vrna_plot_coords_circular(), vrna_plot_coords_simple_pt(),
       vrna_plot_coords_naview_pt(), vrna_plot_coords_turtle_pt(), vrna_plot_coords_puzzler_pt()

 @param        pt          The pair table that holds the secondary structure
 @param[inout] x           The address of a pointer of X coordinates (pointer will point to memory, or NULL on failure)
 @param[inout] y           The address of a pointer of Y coordinates (pointer will point to memory, or NULL on failure)
 @return                   The length of the structure on success, 0 otherwise
### Prototype
```c
int vrna_plot_coords_circular_pt(const short *pt, float **x, float **y);
```
"""
function vrna_plot_coords_circular_pt(pt, x, y)
    ccall((:vrna_plot_coords_circular_pt, libRNA), Cint, (Ptr{Cshort}, Ptr{Ptr{Cfloat}}, Ptr{Ptr{Cfloat}}), pt, x, y)
end

"""
    COORDINATE

 @brief this is a workarround for the SWIG Perl Wrapper RNA plot function
 that returns an array of type COORDINATE
"""
struct COORDINATE
    X::Cfloat
    Y::Cfloat
end

"""
    simple_xy_coordinates(pair_table, X, Y)


### Prototype
```c
;
```
"""
function simple_xy_coordinates(pair_table, X, Y)
    ccall((:simple_xy_coordinates, libRNA), Cint, (Ptr{Cshort}, Ptr{Cfloat}, Ptr{Cfloat}), pair_table, X, Y)
end

"""
    simple_circplot_coordinates(pair_table, x, y)


### Prototype
```c
;
```
"""
function simple_circplot_coordinates(pair_table, x, y)
    ccall((:simple_circplot_coordinates, libRNA), Cint, (Ptr{Cshort}, Ptr{Cfloat}, Ptr{Cfloat}), pair_table, x, y)
end

"""
    vrna_subopt_sol_s

 @brief  Solution element from subopt.c
"""
struct vrna_subopt_sol_s
    energy::Cfloat
    structure::Ptr{Cchar}
end

"""
 @brief Typename for the subopt solution list repesenting data structure #vrna_subopt_sol_s
"""
const vrna_subopt_solution_t = vrna_subopt_sol_s

# typedef void ( * vrna_subopt_result_f ) ( const char * stucture , float energy , void * data )
"""
 @brief  Callback for vrna_subopt_cb()
 @ingroup subopt_wuchty

@callback
@parblock
This function will be called for each suboptimal secondary structure that is successfully backtraced.
@endparblock

@see vrna_subopt_cb()

@param structure The suboptimal secondary structure in dot-bracket notation
@param energy    The free energy of the secondary structure in kcal/mol
@param data      Some arbitrary, auxiliary data address as passed to vrna_subopt_cb()
"""
const vrna_subopt_result_f = Ptr{Cvoid}

# DEPRECATED
const vrna_subopt_callback = Cvoid

"""
 @brief  Backward compatibility typedef for #vrna_subopt_sol_s
 @deprecated Use #vrna_subopt_solution_t instead!
"""
const SOLUTION = vrna_subopt_sol_s

"""
    vrna_subopt(fc, delta, sorted, fp)

 @brief Returns list of subopt structures or writes to fp

 This function produces <b>all</b> suboptimal secondary structures within
 'delta' * 0.01 kcal/mol of the optimum, see @cite wuchty:1999. The results
 are either directly written to a 'fp' (if 'fp' is not NULL), or
 (fp==NULL) returned in a #vrna_subopt_solution_t * list terminated
 by an entry were the 'structure' member is NULL.

 @ingroup subopt_wuchty

 @note This function requires all multibranch loop DP matrices for unique
       multibranch loop backtracing. Therefore, the supplied #vrna_fold_compound_t
       @p fc (argument 1) must be initialized with #vrna_md_t.uniq_ML = 1, for
       instance like this:
       @code
vrna_md_t md;
vrna_md_set_default(&md);
md.uniq_ML = 1;

vrna_fold_compound_t *fc=vrna_fold_compound("GGGGGGAAAAAACCCCCC", &md, VRNA_OPTION_DEFAULT);
       @endcode

 @see vrna_subopt_cb(), vrna_subopt_zuker()

 @param  fc
 @param  delta
 @param  sorted  Sort results by energy in ascending order
 @param  fp
 @return
### Prototype
```c
vrna_subopt_solution_t * vrna_subopt(vrna_fold_compound_t *fc, int delta, int sorted, FILE *fp);
```
"""
function vrna_subopt(fc, delta, sorted, fp)
    ccall((:vrna_subopt, libRNA), Ptr{vrna_subopt_solution_t}, (Ptr{vrna_fold_compound_t}, Cint, Cint, Ptr{Libc.FILE}), fc, delta, sorted, fp)
end

"""
    vrna_subopt_cb(fc, delta, cb, data)

 @brief  Generate suboptimal structures within an energy band arround the MFE

 This is the most generic implementation of the suboptimal structure generator
 according to Wuchty et al. 1999 @cite wuchty:1999. Identical to vrna_subopt(), it computes all
 secondary structures within an energy band @p delta arround the MFE. However,
 this function does not print the resulting structures and their corresponding
 free energies to a file pointer, or returns them as a list. Instead, it calls
 a user-provided callback function which it passes the structure in dot-bracket
 format, the corresponding free energy in kcal/mol, and a user-provided data
 structure each time a structure was backtracked successfully. This function
 indicates the final output, i.e. the end of the backtracking procedure by
 passing NULL instead of an actual dot-bracket string to the callback.

 @ingroup subopt_wuchty

 @note This function requires all multibranch loop DP matrices for unique
       multibranch loop backtracing. Therefore, the supplied #vrna_fold_compound_t
       @p fc (argument 1) must be initialized with #vrna_md_t.uniq_ML = 1, for
       instance like this:
       @code
vrna_md_t md;
vrna_md_set_default(&md);
md.uniq_ML = 1;

vrna_fold_compound_t *fc=vrna_fold_compound("GGGGGGAAAAAACCCCCC", &md, VRNA_OPTION_DEFAULT);
       @endcode

 @see vrna_subopt_result_f, vrna_subopt(), vrna_subopt_zuker()

 @param  fc      fold compount with the sequence data
 @param  delta   Energy band arround the MFE in 10cal/mol, i.e. deka-calories
 @param  cb      Pointer to a callback function that handles the backtracked structure and its free energy in kcal/mol
 @param  data    Pointer to some data structure that is passed along to the callback
### Prototype
```c
void vrna_subopt_cb(vrna_fold_compound_t *fc, int delta, vrna_subopt_result_f cb, void *data);
```
"""
function vrna_subopt_cb(fc, delta, cb, data)
    ccall((:vrna_subopt_cb, libRNA), Cvoid, (Ptr{vrna_fold_compound_t}, Cint, vrna_subopt_result_f, Ptr{Cvoid}), fc, delta, cb, data)
end

"""
    subopt(seq, structure, delta, fp)


### Prototype
```c
;
```
"""
function subopt(seq, structure, delta, fp)
    ccall((:subopt, libRNA), Ptr{SOLUTION}, (Ptr{Cchar}, Ptr{Cchar}, Cint, Ptr{Libc.FILE}), seq, structure, delta, fp)
end

"""
    subopt_par(seq, structure, parameters, delta, is_constrained, is_circular, fp)


### Prototype
```c
;
```
"""
function subopt_par(seq, structure, parameters, delta, is_constrained, is_circular, fp)
    ccall((:subopt_par, libRNA), Ptr{SOLUTION}, (Ptr{Cchar}, Ptr{Cchar}, Ptr{vrna_param_t}, Cint, Cint, Cint, Ptr{Libc.FILE}), seq, structure, parameters, delta, is_constrained, is_circular, fp)
end

"""
    subopt_circ(seq, sequence, delta, fp)


### Prototype
```c
;
```
"""
function subopt_circ(seq, sequence, delta, fp)
    ccall((:subopt_circ, libRNA), Ptr{SOLUTION}, (Ptr{Cchar}, Ptr{Cchar}, Cint, Ptr{Libc.FILE}), seq, sequence, delta, fp)
end

"""
    zukersubopt(string)


### Prototype
```c
;
```
"""
function zukersubopt(string)
    ccall((:zukersubopt, libRNA), Ptr{SOLUTION}, (Ptr{Cchar},), string)
end

"""
    zukersubopt_par(string, parameters)


### Prototype
```c
;
```
"""
function zukersubopt_par(string, parameters)
    ccall((:zukersubopt_par, libRNA), Ptr{SOLUTION}, (Ptr{Cchar}, Ptr{vrna_param_t}), string, parameters)
end

"""
    vrna_subopt_zuker(fc)

 @brief Compute Zuker type suboptimal structures

 Compute Suboptimal structures according to M. Zuker @cite zuker:1989 , i.e. for every
 possible base pair the minimum energy structure containing the resp. base pair.
 Returns a list of these structures and their energies.

 @ingroup subopt_zuker

 @see vrna_subopt(), zukersubopt(), zukersubopt_par()

 @param  fc  fold compound
 @return     List of zuker suboptimal structures
### Prototype
```c
vrna_subopt_solution_t * vrna_subopt_zuker(vrna_fold_compound_t *fc);
```
"""
function vrna_subopt_zuker(fc)
    ccall((:vrna_subopt_zuker, libRNA), Ptr{vrna_subopt_solution_t}, (Ptr{vrna_fold_compound_t},), fc)
end

"""
    Postorder_list

 @brief Postorder data structure
"""
struct Postorder_list
    type::Cint
    weight::Cint
    father::Cint
    sons::Cint
    leftmostleaf::Cint
end

"""
    Tree

 @brief  Tree data structure
"""
struct Tree
    postorder_list::Ptr{Postorder_list}
    keyroots::Ptr{Cint}
end

"""
    swString

 @brief  Some other data structure
"""
struct swString
    type::Cint
    sign::Cint
    weight::Cfloat
end

"""
    make_tree(struc)

 \\brief Constructs a Tree ( essentially the postorder list ) of the
 structure 'struc', for use in tree_edit_distance().

 \\param  struc may be any rooted structure representation.
 \\return
### Prototype
```c
Tree *make_tree(char *struc);
```
"""
function make_tree(struc)
    ccall((:make_tree, libRNA), Ptr{Tree}, (Ptr{Cchar},), struc)
end

"""
    tree_edit_distance(T1, T2)

 \\brief Calculates the edit distance of the two trees.

 \\param T1
 \\param T2
 \\return
### Prototype
```c
float tree_edit_distance(Tree *T1, Tree *T2);
```
"""
function tree_edit_distance(T1, T2)
    ccall((:tree_edit_distance, libRNA), Cfloat, (Ptr{Tree}, Ptr{Tree}), T1, T2)
end

"""
    print_tree(t)

 \\brief Print a tree (mainly for debugging)
### Prototype
```c
void print_tree(Tree *t);
```
"""
function print_tree(t)
    ccall((:print_tree, libRNA), Cvoid, (Ptr{Tree},), t)
end

"""
    free_tree(t)

 \\brief Free the memory allocated for Tree t.

 \\param t
### Prototype
```c
void free_tree(Tree *t);
```
"""
function free_tree(t)
    ccall((:free_tree, libRNA), Cvoid, (Ptr{Tree},), t)
end

"""
    vrna_alloc(size)

 @brief Allocate space safely

 @param size The size of the memory to be allocated in bytes
 @return     A pointer to the allocated memory
### Prototype
```c
void * vrna_alloc(unsigned size);
```
"""
function vrna_alloc(size)
    ccall((:vrna_alloc, libRNA), Ptr{Cvoid}, (Cuint,), size)
end

"""
    vrna_realloc(p, size)

 @brief Reallocate space safely

 @param p    A pointer to the memory region to be reallocated
 @param size The size of the memory to be allocated in bytes
 @return     A pointer to the newly allocated memory
### Prototype
```c
void * vrna_realloc(void *p, unsigned size);
```
"""
function vrna_realloc(p, size)
    ccall((:vrna_realloc, libRNA), Ptr{Cvoid}, (Ptr{Cvoid}, Cuint), p, size)
end

"""
    vrna_init_rand()

 @brief  Initialize seed for random number generator

 @see  vrna_init_rand_seed(), vrna_urn()
### Prototype
```c
void vrna_init_rand(void);
```
"""
function vrna_init_rand()
    ccall((:vrna_init_rand, libRNA), Cvoid, ())
end

"""
    vrna_init_rand_seed(seed)

 @brief  Initialize the random number generator with a pre-defined seed

 @see  vrna_init_rand(), vrna_urn()

 @param  seed  The seed for the random number generator
### Prototype
```c
void vrna_init_rand_seed(unsigned int seed);
```
"""
function vrna_init_rand_seed(seed)
    ccall((:vrna_init_rand_seed, libRNA), Cvoid, (Cuint,), seed)
end

"""
    vrna_urn()

 @brief get a random number from [0..1]

 @note Usually implemented by calling @e erand48().

 @see  vrna_int_urn(), vrna_init_rand(), vrna_init_rand_seed()

 @return   A random number in range [0..1]
### Prototype
```c
double vrna_urn(void);
```
"""
function vrna_urn()
    ccall((:vrna_urn, libRNA), Cdouble, ())
end

"""
    vrna_int_urn(from, to)

 @brief Generates a pseudo random integer in a specified range

 @see  vrna_urn(), vrna_init_rand()

 @param from   The first number in range
 @param to     The last number in range
 @return       A pseudo random number in range [from, to]
### Prototype
```c
int vrna_int_urn(int from, int to);
```
"""
function vrna_int_urn(from, to)
    ccall((:vrna_int_urn, libRNA), Cint, (Cint, Cint), from, to)
end

"""
    vrna_time_stamp()

 @brief Get a timestamp

 Returns a string containing the current date in the format
 @verbatim Fri Mar 19 21:10:57 1993 @endverbatim

 @return A string containing the timestamp
### Prototype
```c
char * vrna_time_stamp(void);
```
"""
function vrna_time_stamp()
    ccall((:vrna_time_stamp, libRNA), Ptr{Cchar}, ())
end

"""
    get_input_line(string, options)

 Retrieve a line from 'stdin' savely while skipping comment characters and
 other features
 This function returns the type of input it has read if recognized.
 An option argument allows one to switch between different reading modes.\\n
 Currently available options are:\\n
 #VRNA_INPUT_COMMENT, #VRNA_INPUT_NOSKIP_COMMENTS, #VRNA_INPUT_NO_TRUNCATION

 pass a collection of options as one value like this:
 @verbatim get_input_line(string, option_1 | option_2 | option_n) @endverbatim

 If the function recognizes the type of input, it will report it in the return
 value. It also reports if a user defined 'quit' command (@-sign on 'stdin')
 was given. Possible return values are:\\n
 #VRNA_INPUT_FASTA_HEADER, #VRNA_INPUT_ERROR, #VRNA_INPUT_MISC, #VRNA_INPUT_QUIT

 @param string   A pointer to the character array that contains the line read
 @param options  A collection of options for switching the functions behavior
 @return         A flag with information about what has been read
### Prototype
```c
unsigned int get_input_line(char **string, unsigned int options);
```
"""
function get_input_line(string, options)
    ccall((:get_input_line, libRNA), Cuint, (Ptr{Ptr{Cchar}}, Cuint), string, options)
end

"""
    vrna_idx_row_wise(length)

 @brief Get an index mapper array (iindx) for accessing the energy matrices, e.g. in partition function related functions.

 Access of a position "(i,j)" is then accomplished by using @verbatim (i,j) ~ iindx[i]-j @endverbatim
 This function is necessary as most of the two-dimensional energy matrices are actually one-dimensional arrays throughout
 the ViennaRNA Package

 Consult the implemented code to find out about the mapping formula ;)

 @see vrna_idx_col_wise()

 @param length The length of the RNA sequence
 @return       The mapper array
### Prototype
```c
int * vrna_idx_row_wise(unsigned int length);
```
"""
function vrna_idx_row_wise(length)
    ccall((:vrna_idx_row_wise, libRNA), Ptr{Cint}, (Cuint,), length)
end

"""
    vrna_idx_col_wise(length)

 @brief Get an index mapper array (indx) for accessing the energy matrices, e.g. in MFE related functions.

 Access of a position "(i,j)" is then accomplished by using @verbatim (i,j) ~ indx[j]+i @endverbatim
 This function is necessary as most of the two-dimensional energy matrices are actually one-dimensional arrays throughout
 the ViennaRNAPackage

 Consult the implemented code to find out about the mapping formula ;)

 @see vrna_idx_row_wise()

 @param length The length of the RNA sequence
 @return       The mapper array

### Prototype
```c
int * vrna_idx_col_wise(unsigned int length);
```
"""
function vrna_idx_col_wise(length)
    ccall((:vrna_idx_col_wise, libRNA), Ptr{Cint}, (Cuint,), length)
end

"""
    vrna_message_input_seq_simple()

 @brief Print a line to @e stdout that asks for an input sequence

 There will also be a ruler (scale line) printed that helps orientation of the sequence positions
### Prototype
```c
void vrna_message_input_seq_simple(void);
```
"""
function vrna_message_input_seq_simple()
    ccall((:vrna_message_input_seq_simple, libRNA), Cvoid, ())
end

"""
    vrna_message_input_seq(s)

 @brief Print a line with a user defined string and a ruler to stdout.

 (usually this is used to ask for user input)
 There will also be a ruler (scale line) printed that helps orientation of the sequence positions

 @param s A user defined string that will be printed to stdout
### Prototype
```c
void vrna_message_input_seq(const char *s);
```
"""
function vrna_message_input_seq(s)
    ccall((:vrna_message_input_seq, libRNA), Cvoid, (Ptr{Cchar},), s)
end

"""
    vrna_message_input_msa(s)


### Prototype
```c
void vrna_message_input_msa(const char *s);
```
"""
function vrna_message_input_msa(s)
    ccall((:vrna_message_input_msa, libRNA), Cvoid, (Ptr{Cchar},), s)
end

"""
    get_indx(length)


### Prototype
```c
;
```
"""
function get_indx(length)
    ccall((:get_indx, libRNA), Ptr{Cint}, (Cuint,), length)
end

"""
    get_iindx(length)


### Prototype
```c
;
```
"""
function get_iindx(length)
    ccall((:get_iindx, libRNA), Ptr{Cint}, (Cuint,), length)
end

"""
    get_line(fp)


### Prototype
```c
;
```
"""
function get_line(fp)
    ccall((:get_line, libRNA), Ptr{Cchar}, (Ptr{Libc.FILE},), fp)
end

"""
    print_tty_input_seq()


### Prototype
```c
;
```
"""
function print_tty_input_seq()
    ccall((:print_tty_input_seq, libRNA), Cvoid, ())
end

"""
    print_tty_input_seq_str(s)


### Prototype
```c
;
```
"""
function print_tty_input_seq_str(s)
    ccall((:print_tty_input_seq_str, libRNA), Cvoid, (Ptr{Cchar},), s)
end

"""
    warn_user(message)


### Prototype
```c
;
```
"""
function warn_user(message)
    ccall((:warn_user, libRNA), Cvoid, (Ptr{Cchar},), message)
end

"""
    nrerror(message)


### Prototype
```c
;
```
"""
function nrerror(message)
    ccall((:nrerror, libRNA), Cvoid, (Ptr{Cchar},), message)
end

"""
    space(size)


### Prototype
```c
;
```
"""
function space(size)
    ccall((:space, libRNA), Ptr{Cvoid}, (Cuint,), size)
end

"""
    xrealloc(p, size)


### Prototype
```c
;
```
"""
function xrealloc(p, size)
    ccall((:xrealloc, libRNA), Ptr{Cvoid}, (Ptr{Cvoid}, Cuint), p, size)
end

"""
    init_rand()


### Prototype
```c
;
```
"""
function init_rand()
    ccall((:init_rand, libRNA), Cvoid, ())
end

"""
    urn()


### Prototype
```c
;
```
"""
function urn()
    ccall((:urn, libRNA), Cdouble, ())
end

"""
    int_urn(from, to)


### Prototype
```c
;
```
"""
function int_urn(from, to)
    ccall((:int_urn, libRNA), Cint, (Cint, Cint), from, to)
end

"""
    filecopy(from, to)


### Prototype
```c
;
```
"""
function filecopy(from, to)
    ccall((:filecopy, libRNA), Cvoid, (Ptr{Libc.FILE}, Ptr{Libc.FILE}), from, to)
end

"""
    time_stamp()


### Prototype
```c
;
```
"""
function time_stamp()
    ccall((:time_stamp, libRNA), Ptr{Cchar}, ())
end

const GASCONST = 1.98717

const K0 = 273.15

const INF = 10000000

const EMAX = INF ÷ 10

const FORBIDDEN = 9999

const BONUS = 10000

const NBPAIRS = 7

const TURN = 3

const MAXLOOP = 30

const UNIT = 100

const MINPSCORE = -2 * UNIT

const NBASES = 8

const VRNA_MODEL_DEFAULT_TEMPERATURE = 37.0

const VRNA_MODEL_DEFAULT_PF_SCALE = -1

const VRNA_MODEL_DEFAULT_BETA_SCALE = 1.0

const VRNA_MODEL_DEFAULT_DANGLES = 2

const VRNA_MODEL_DEFAULT_SPECIAL_HP = 1

const VRNA_MODEL_DEFAULT_NO_LP = 0

const VRNA_MODEL_DEFAULT_NO_GU = 0

const VRNA_MODEL_DEFAULT_NO_GU_CLOSURE = 0

const VRNA_MODEL_DEFAULT_CIRC = 0

const VRNA_MODEL_DEFAULT_GQUAD = 0

const VRNA_MODEL_DEFAULT_UNIQ_ML = 0

const VRNA_MODEL_DEFAULT_ENERGY_SET = 0

const VRNA_MODEL_DEFAULT_BACKTRACK = 1

const VRNA_MODEL_DEFAULT_BACKTRACK_TYPE = Cchar('F')

const VRNA_MODEL_DEFAULT_COMPUTE_BPP = 1

const VRNA_MODEL_DEFAULT_MAX_BP_SPAN = -1

const VRNA_MODEL_DEFAULT_WINDOW_SIZE = -1

const VRNA_MODEL_DEFAULT_LOG_ML = 0

const VRNA_MODEL_DEFAULT_ALI_OLD_EN = 0

const VRNA_MODEL_DEFAULT_ALI_RIBO = 0

const VRNA_MODEL_DEFAULT_ALI_CV_FACT = 1.0

const VRNA_MODEL_DEFAULT_ALI_NC_FACT = 1.0

const VRNA_MODEL_DEFAULT_PF_SMOOTH = 1

const VRNA_MODEL_DEFAULT_SALT = 1.021

const VRNA_MODEL_DEFAULT_SALT_MLLOWER = 6

const VRNA_MODEL_DEFAULT_SALT_MLUPPER = 24

const VRNA_MODEL_DEFAULT_SALT_DPXINIT = 99999

const VRNA_MODEL_SALT_DPXINIT_FACT_RNA = -45.324

const VRNA_MODEL_SALT_DPXINIT_FACT_DNA = -58.389

const VRNA_MODEL_DEFAULT_SALT_DPXINIT_FACT = VRNA_MODEL_SALT_DPXINIT_FACT_RNA

const VRNA_MODEL_HELICAL_RISE_RNA = 2.8

const VRNA_MODEL_HELICAL_RISE_DNA = 3.4

const VRNA_MODEL_DEFAULT_HELICAL_RISE = VRNA_MODEL_HELICAL_RISE_RNA

const VRNA_MODEL_BACKBONE_LENGTH_RNA = 6.0

const VRNA_MODEL_BACKBONE_LENGTH_DNA = 6.76

const VRNA_MODEL_DEFAULT_BACKBONE_LENGTH = VRNA_MODEL_BACKBONE_LENGTH_RNA

const MAXALPHA = 20

const model_detailsT = vrna_md_t

const VRNA_GQUAD_MAX_STACK_SIZE = 7

const VRNA_GQUAD_MIN_STACK_SIZE = 2

const VRNA_GQUAD_MAX_LINKER_LENGTH = 15

const VRNA_GQUAD_MIN_LINKER_LENGTH = 1

const VRNA_GQUAD_MIN_BOX_SIZE = 4VRNA_GQUAD_MIN_STACK_SIZE + 3VRNA_GQUAD_MIN_LINKER_LENGTH

const VRNA_GQUAD_MAX_BOX_SIZE = 4VRNA_GQUAD_MAX_STACK_SIZE + 3VRNA_GQUAD_MAX_LINKER_LENGTH

const VRNA_SEQUENCE_RNA = Cuint(1)

const VRNA_SEQUENCE_DNA = Cuint(2)

const VRNA_CONSTRAINT_FILE = 0

const VRNA_CONSTRAINT_SOFT_MFE = 0

const VRNA_OPTION_PF = Cuint(2)

const VRNA_CONSTRAINT_SOFT_PF = VRNA_OPTION_PF

const VRNA_DECOMP_PAIR_HP = Cuchar(1)

const VRNA_DECOMP_PAIR_IL = Cuchar(2)

const VRNA_DECOMP_PAIR_ML = Cuchar(3)

const VRNA_DECOMP_PAIR_ML_EXT = Cuchar(23)

const VRNA_DECOMP_PAIR_ML_OUTSIDE = Cuchar(4)

const VRNA_DECOMP_ML_ML_ML = Cuchar(5)

const VRNA_DECOMP_ML_STEM = Cuchar(6)

const VRNA_DECOMP_ML_ML = Cuchar(7)

const VRNA_DECOMP_ML_UP = Cuchar(8)

const VRNA_DECOMP_ML_ML_STEM = Cuchar(9)

const VRNA_DECOMP_ML_COAXIAL = Cuchar(10)

const VRNA_DECOMP_ML_COAXIAL_ENC = Cuchar(11)

const VRNA_DECOMP_EXT_EXT = Cuchar(12)

const VRNA_DECOMP_EXT_UP = Cuchar(13)

const VRNA_DECOMP_EXT_STEM = Cuchar(14)

const VRNA_DECOMP_EXT_EXT_EXT = Cuchar(15)

const VRNA_DECOMP_EXT_STEM_EXT = Cuchar(16)

const VRNA_DECOMP_EXT_STEM_OUTSIDE = Cuchar(17)

const VRNA_DECOMP_EXT_EXT_STEM = Cuchar(18)

const VRNA_DECOMP_EXT_EXT_STEM1 = Cuchar(19)

const VRNA_DECOMP_EXT_STEM_EXT1 = Cuchar(20)

const VRNA_DECOMP_EXT_L = Cuchar(21)

const VRNA_DECOMP_EXT_EXT_L = Cuchar(22)

const VRNA_DECOMP_TYPES_MAX = 32

const VRNA_CONSTRAINT_NO_HEADER = 0

const VRNA_CONSTRAINT_DB = Cuint(16384)

const VRNA_CONSTRAINT_DB_ENFORCE_BP = Cuint(32768)

const VRNA_CONSTRAINT_DB_PIPE = Cuint(65536)

const VRNA_CONSTRAINT_DB_DOT = Cuint(131072)

const VRNA_CONSTRAINT_DB_X = Cuint(262144)

const VRNA_CONSTRAINT_DB_ANG_BRACK = Cuint(524288)

const VRNA_CONSTRAINT_DB_RND_BRACK = Cuint(1048576)

const VRNA_CONSTRAINT_DB_INTRAMOL = Cuint(2097152)

const VRNA_CONSTRAINT_DB_INTERMOL = Cuint(4194304)

const VRNA_CONSTRAINT_DB_GQUAD = Cuint(8388608)

const VRNA_CONSTRAINT_DB_CANONICAL_BP = Cuint(16777216)

const VRNA_CONSTRAINT_DB_WUSS = Cuint(33554432)

const VRNA_CONSTRAINT_DB_DEFAULT = (((((((VRNA_CONSTRAINT_DB | VRNA_CONSTRAINT_DB_PIPE) | VRNA_CONSTRAINT_DB_DOT) | VRNA_CONSTRAINT_DB_X) | VRNA_CONSTRAINT_DB_ANG_BRACK) | VRNA_CONSTRAINT_DB_RND_BRACK) | VRNA_CONSTRAINT_DB_INTRAMOL) | VRNA_CONSTRAINT_DB_INTERMOL) | VRNA_CONSTRAINT_DB_GQUAD

const VRNA_CONSTRAINT_CONTEXT_EXT_LOOP = Cuchar(0x01)

const VRNA_CONSTRAINT_CONTEXT_HP_LOOP = Cuchar(0x02)

const VRNA_CONSTRAINT_CONTEXT_INT_LOOP = Cuchar(0x04)

const VRNA_CONSTRAINT_CONTEXT_INT_LOOP_ENC = Cuchar(0x08)

const VRNA_CONSTRAINT_CONTEXT_MB_LOOP = Cuchar(0x10)

const VRNA_CONSTRAINT_CONTEXT_MB_LOOP_ENC = Cuchar(0x20)

const VRNA_CONSTRAINT_CONTEXT_ENFORCE = Cuchar(0x40)

const VRNA_CONSTRAINT_CONTEXT_NO_REMOVE = Cuchar(0x80)

const VRNA_CONSTRAINT_CONTEXT_NONE = Cuchar(0)

const VRNA_CONSTRAINT_CONTEXT_CLOSING_LOOPS = Cuchar(((VRNA_CONSTRAINT_CONTEXT_EXT_LOOP | VRNA_CONSTRAINT_CONTEXT_HP_LOOP) | VRNA_CONSTRAINT_CONTEXT_INT_LOOP) | VRNA_CONSTRAINT_CONTEXT_MB_LOOP)

const VRNA_CONSTRAINT_CONTEXT_ENCLOSED_LOOPS = Cuchar(VRNA_CONSTRAINT_CONTEXT_INT_LOOP_ENC | VRNA_CONSTRAINT_CONTEXT_MB_LOOP_ENC)

const VRNA_CONSTRAINT_CONTEXT_ALL_LOOPS = Cuchar(VRNA_CONSTRAINT_CONTEXT_CLOSING_LOOPS | VRNA_CONSTRAINT_CONTEXT_ENCLOSED_LOOPS)

const VRNA_CONSTRAINT_WINDOW_UPDATE_5 = Cuint(1)

const VRNA_CONSTRAINT_WINDOW_UPDATE_3 = Cuint(2)

const VRNA_BRACKETS_ALPHA = Cuint(4)

const VRNA_BRACKETS_RND = Cuint(8)

const VRNA_BRACKETS_CLY = Cuint(16)

const VRNA_BRACKETS_ANG = Cuint(32)

const VRNA_BRACKETS_SQR = Cuint(64)

const VRNA_BRACKETS_DEFAULT = ((VRNA_BRACKETS_RND | VRNA_BRACKETS_CLY) | VRNA_BRACKETS_ANG) | VRNA_BRACKETS_SQR

const VRNA_BRACKETS_ANY = (((VRNA_BRACKETS_RND | VRNA_BRACKETS_CLY) | VRNA_BRACKETS_ANG) | VRNA_BRACKETS_SQR) | VRNA_BRACKETS_ALPHA

const VRNA_PLIST_TYPE_BASEPAIR = 0

const VRNA_PLIST_TYPE_GQUAD = 1

const VRNA_PLIST_TYPE_H_MOTIF = 2

const VRNA_PLIST_TYPE_I_MOTIF = 3

const VRNA_PLIST_TYPE_UD_MOTIF = 4

const VRNA_PLIST_TYPE_STACK = 5

const VRNA_PLIST_TYPE_UNPAIRED = 6

const VRNA_PLIST_TYPE_TRIPLE = 7

const VRNA_STRUCTURE_TREE_HIT = Cuint(1)

const VRNA_STRUCTURE_TREE_SHAPIRO_SHORT = Cuint(2)

const VRNA_STRUCTURE_TREE_SHAPIRO = Cuint(3)

const VRNA_STRUCTURE_TREE_SHAPIRO_EXT = Cuint(4)

const VRNA_STRUCTURE_TREE_SHAPIRO_WEIGHT = Cuint(5)

const VRNA_STRUCTURE_TREE_EXPANDED = Cuint(6)

const VRNA_UNSTRUCTURED_DOMAIN_EXT_LOOP = Cuint(1)

const VRNA_UNSTRUCTURED_DOMAIN_HP_LOOP = Cuint(2)

const VRNA_UNSTRUCTURED_DOMAIN_INT_LOOP = Cuint(4)

const VRNA_UNSTRUCTURED_DOMAIN_MB_LOOP = Cuint(8)

const VRNA_UNSTRUCTURED_DOMAIN_MOTIF = Cuint(16)

const VRNA_UNSTRUCTURED_DOMAIN_ALL_LOOPS = ((VRNA_UNSTRUCTURED_DOMAIN_EXT_LOOP | VRNA_UNSTRUCTURED_DOMAIN_HP_LOOP) | VRNA_UNSTRUCTURED_DOMAIN_INT_LOOP) | VRNA_UNSTRUCTURED_DOMAIN_MB_LOOP

const VRNA_MOVESET_INSERTION = 4

const VRNA_MOVESET_DELETION = 8

const VRNA_MOVESET_SHIFT = 16

const VRNA_MOVESET_NO_LP = 32

const VRNA_MOVESET_DEFAULT = VRNA_MOVESET_INSERTION | VRNA_MOVESET_DELETION

const VRNA_VERBOSITY_QUIET = -1

const VRNA_VERBOSITY_DEFAULT = 1

const VRNA_STATUS_MFE_PRE = Cuchar(1)

const VRNA_STATUS_MFE_POST = Cuchar(2)

const VRNA_STATUS_PF_PRE = Cuchar(3)

const VRNA_STATUS_PF_POST = Cuchar(4)

const VRNA_OPTION_DEFAULT = Cuint(0)

const VRNA_OPTION_MFE = Cuint(1)

const VRNA_OPTION_HYBRID = Cuint(4)

const VRNA_OPTION_EVAL_ONLY = Cuint(8)

const VRNA_OPTION_WINDOW = Cuint(16)

const VRNA_NEIGHBOR_CHANGE = 1

const VRNA_NEIGHBOR_INVALID = 2

const VRNA_NEIGHBOR_NEW = 3

const VRNA_PARAMETER_FORMAT_DEFAULT = 0

const VRNA_PBACKTRACK_DEFAULT = 0

const VRNA_PBACKTRACK_NON_REDUNDANT = 1

const VRNA_EXT_LOOP = Cuint(1)

const VRNA_HP_LOOP = Cuint(2)

const VRNA_INT_LOOP = Cuint(4)

const VRNA_MB_LOOP = Cuint(8)

const VRNA_ANY_LOOP = ((VRNA_EXT_LOOP | VRNA_HP_LOOP) | VRNA_INT_LOOP) | VRNA_MB_LOOP

const VRNA_PROBS_WINDOW_BPP = Cuint(4096)

const VRNA_PROBS_WINDOW_UP = Cuint(8192)

const VRNA_PROBS_WINDOW_STACKP = Cuint(16384)

const VRNA_PROBS_WINDOW_UP_SPLIT = Cuint(32768)

const VRNA_PROBS_WINDOW_PF = Cuint(65536)

const VRNA_PLOT_TYPE_SIMPLE = 0

const VRNA_PLOT_TYPE_NAVIEW = 1

const VRNA_PLOT_TYPE_CIRCULAR = 2

const VRNA_PLOT_TYPE_TURTLE = 3

const VRNA_PLOT_TYPE_PUZZLER = 4

const VRNA_PLOT_TYPE_DEFAULT = VRNA_PLOT_TYPE_PUZZLER

const MAXDOS = 1000

const VRNA_UNSORTED = 0

const VRNA_SORT_BY_ENERGY_LEXICOGRAPHIC_ASC = 1

const VRNA_SORT_BY_ENERGY_ASC = 2

# Skipping MacroDefinition: PRIVATE static

const VRNA_INPUT_ERROR = Cuint(1)

const VRNA_INPUT_QUIT = Cuint(2)

const VRNA_INPUT_MISC = Cuint(4)

const VRNA_INPUT_FASTA_HEADER = Cuint(8)

const VRNA_INPUT_SEQUENCE = Cuint(16)

const VRNA_INPUT_CONSTRAINT = Cuint(32)

const VRNA_INPUT_NO_TRUNCATION = Cuint(256)

const VRNA_INPUT_NO_REST = Cuint(512)

const VRNA_INPUT_NO_SPAN = Cuint(1024)

const VRNA_INPUT_NOSKIP_BLANK_LINES = Cuint(2048)

const VRNA_INPUT_BLANK_LINE = Cuint(4096)

const VRNA_INPUT_NOSKIP_COMMENTS = Cuint(128)

const VRNA_INPUT_COMMENT = Cuint(8192)

# exports
const PREFIXES = ["VRNA_", "vrna_"]
for name in names(@__MODULE__; all=true), prefix in PREFIXES
    if startswith(string(name), prefix)
        @eval export $name
    end
end

end # module
